# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['investment_simulator']

package_data = \
{'': ['*']}

install_requires = \
['numpy>=1.20.rc1,<2.0', 'pydantic>=1.8.1,<2.0.0', 'scipy>=1.6.0,<2.0.0']

setup_kwargs = {
    'name': 'investment-simulator',
    'version': '0.2.0',
    'description': 'Library for simulating a persons investment portfolio over time based on risk and return',
    'long_description': '# Investment-Simulator\n\nLibrary for simulating a persons investment portfolio over time based on risk and return. This library makes use of [Markowitz/Modern Portfolio Theory\n](https://www.investopedia.com/terms/m/modernportfoliotheory.asp "Modern Portfolio Theory") to model portfolio return and risk using the covariance\n of assets held. Focusing of modeling Stochastic methods such as [Monte Carlo Simulations](https://corporatefinanceinstitute.com/resources/knowledge/modeling/monte-carlo-simulation/\n "Monte Carlo For Finance") and implemented using functional styled python.\n\n---\n\n## Usage\n### Portfolio Simulation\n\nThe library offers the ability to simulate how a portfolio will grow over time in a stochastic way, showing the variance of possible outcomes based on\n asset allocations and how the assets are related to each other. The library requires the user to give the average annual return, asset weightings,\n  the covariance between the assets, and number of steps in the simulation (investment horizon).\n\nBasic usage:\n```python\nfrom investment_simulator.portfolios import growth_simulation\n\nasset_weights = [0.5, 0.5]\nasset_returns = [0.1, 0.1]\ncovariance = [[1.0, 0.0], [0.0, 1.0]]\nsteps = 10\n\ngrowth_simulation(asset_weights, asset_returns, covariance, steps)\n```\n\nThe result is a [Value Object/Frozen Data Class](https://docs.python.org/3/library/dataclasses.html "Data Classes") containing the mean outcome of\n 1000 simulations over 10 years steps, as well as the calculated risk and return of the modelled portfolio.\n ```python\nPortfolioResults(\n    portfolio_return=0.10000000000000009,\n    portfolio_risk=0.7071067811865476,\n    simulation_mean=[1.0, 1.080889920462147, 1.1770098655116579, 1.372350014835664, 1.7036261053980901,\n                     1.7926598558102225, 1.9825789493200046, 2.621924082582044, 3.200699630098704,\n                     3.2614308258392573, 4.211555444216132],\n    simulation_std=[0.0, 0.8151713183859045, 1.407052616672628, 3.0336270877135734, 4.8721084117880755,\n                    4.915923260576842, 6.394237270341292, 13.456266947236522, 24.550547468886933,\n                    29.54050507961563, 42.62272966366064],\n)\n```\n\n### Investment Goals\n\nThe investment simulator also allows optionally for an investment goal to be input to calculate the likelihood of achieving it.\n This is done in the same growth function when the optional `investment_goal` parameter is input and non-zero. This causes the\n  function to return an `InvestmentResults` object which inherits from `PortfolioResults`\n\nFor example; a person my want to save for a certain amount of money for retirement, where the simulation could be used to determine the percentage outcomes that\n  reach the desired amount, as well what additional payments would be required so that the goal is likely to be achieved. Outcomes are assumed\n   to be normally distributed and additional payments are to achieve a probability of 50% of achieving the goal. This is used as follows:\n```python\nfrom investment_simulator.portfolios import growth_simulation\n\nasset_weights = [0.5, 0.5]\nasset_returns = [0.1, 0.1]\ncovariance = [[1.0, 0.0], [0.0, 1.0]]\nsteps = 10\ninvestment_goal = 2.5\n\ngrowth_simulation(\n        asset_weightings= asset_weights,\n        annual_returns=asset_returns,\n        covariance=covariance,\n        steps=steps,\n        investment_goal=investment_goal,\n    )\n```\n\nThe result of which is:\n```python\nInvestmentResults(\n    portfolio_return=0.10000000000000009,\n    portfolio_risk=0.022360679774997897,\n    simulation_mean=[1.0, 1.0995099544525146, 1.210924506187439, 1.3327478170394897, 1.4653383493423462,\n                     1.6140620708465576, 1.7742526531219482, 1.9512927532196045, 2.1460065841674805,\n                     2.357496976852417, 2.5915284156799316],\n    simulation_std=[0.0, 0.024642884731292725, 0.039426639676094055, 0.052822574973106384, 0.06663929671049118,\n                   0.08260171860456467, 0.10066824406385422, 0.11744718253612518, 0.13588516414165497,\n                   0.1578415483236313, 0.18211820721626282],\n    goal=2.5,\n    probability=0.6923691357161944,\n    additional_savings=-0.0)\n```\nWhere the person has approximately 70% probability of achieving their investment goal, and doesn\'t require any additional savings to improve their\n likelihood above 50%.\n\n### Contribution Functions\n\nThe simulation has the ability to add annual contributions to the portfolio uniformly across simulations. The contribution function should take the\n time step as an input and return a contribution amount. For example a function could be defined as:\n```python\ndef continuous_contributions(\n    initial_contribution: float,\n    contribution_growth: float = 0.0\n) -> Callable[[int], float]:\n    def inner(step: int) -> float:\n        return initial_contribution *  (1 +contribution_growth) ** step\n\n    return inner\n```\n\nWhere a function`continuous_contributions` is defined as the default contributions function. Such that there is the `initial_contribution` added to\n to a portfolio in the simulation which grows annually at a rate of `contributuion_growth` compounded by the step.\n\n---\n\n### Allocations Optimisation\n\nThe library also offers the ability to optimise the allocations of a portfolio, determining the weightings of assets that provide the highest\n return for the lowest risk. This follows the concept of the [Efficient Portfolio Frontier](https://www.investopedia.com/terms/e/efficientfrontier.asp\n "Efficient Portfolio Frontier") by generating a series of random portfolios to build the curve, then maximising for the portfolio with the\n  highest Sharpe Ratio.\n```python\nfrom investment_simulator.allocations import allocations_simulation\n\nannual_returns = [0.1, 0.1]\ncovariance = [[0.001, 0.000], [0.000, 0.001]]\nsimulations = 10\n\nallocations_simulation(annual_returns, covariance, simulations)\n```\n\nThe result is a [Value Object(Frozen Data Class)](https://docs.python.org/3/library/dataclasses.html "Data Classes") containing the portfolio with\n the highest sharpe ratio score.\n```python\nAllocationResults(\n    sharpe_ratio=4.020794467140073,\n    annual_return=0.10000000000000009,\n    risk=0.022383636053900476,\n    weights=[0.52266234, 0.47733766]\n)\n```\n\n---\n\n## Development\nDependencies managed using `poetry` and can be installed using `poetry install`\n\n### Git Hooks\nThis repository uses git hooks for; formatting using black, debug checks, and running tests. This will auto format any commits to a forced styling\n using black, check for debug statements, and block commits where tests fail. Pre Commit can be run using `pre-commit run --all-files` in terminal to\n  check your changes before committing if preferred.\n\n### Tests\nTesting is done in `pytest` and can be initiated using:\n```shell script\npoetry run python -m pytest -v\n```\n\n---\n\n## Done\n* Monte Carlo simulation for an portfolio based on asset weightings and returns.\n* Portfolio Simulation for optimal asset allocations\n* Back solving probabilities of achieving a fixed goal.\n* Git hooks for; formatting using black, debug checks, and running tests.\n* Tax calculation and input to better model income based contribution functions.\n\n## Todo\n* Test Coverage\n* More contribution functions to support usage.\n* Actuarial based formulae and functions for modeling investments.\n',
    'author': 'Siddha Ishmael Ganesan',
    'author_email': 'siddha.ganesan@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/jarden-sid/investment-simulator',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
