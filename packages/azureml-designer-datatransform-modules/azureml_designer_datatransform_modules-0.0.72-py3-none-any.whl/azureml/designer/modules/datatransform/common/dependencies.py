# from azureml.core.conda_dependencies import CondaDependencies


# class Dependencies():
#     # Please update the azure-pipelines.yml as well
#     # when upgrade to a new python version
#     DEFAULT_PYTHON_VERSION = '3.7.3'

#     """A class wraps AzureML Service's CondaDependencies class"""
#     def __init__(self):
#         # Build an underlying CondaDependencies object.
#         # Specify a dummy dict to make CondaDependencies does not have default packages (e.g. azureml-defaults)
#         # Empty dict is ignored by CondaDependencies, so added a dummy entry.
#         self._underlying = CondaDependencies(_underlying_structure={'dummy': 'dummy'})

#     @staticmethod
#     def create_default():
#         """Default conda environment configuration.

#         Yaml description is as follows:

#         name: project_environment
#         channels:
#         - defaults
#         dependencies:
#         - python=3.6.8
#         - pip:
#           - https://download.pytorch.org/whl/cpu/torch-1.0.1.post2-cp36-cp36m-linux_x86_64.whl
#           - pillow==5.2.0
#           - torchvision==0.2.2.post3
#         """
#         d = Dependencies()
#         d.add_conda_packages(f'python={Dependencies.DEFAULT_PYTHON_VERSION}')
#         return d

#     @staticmethod
#     def update_from_default(channels=None, conda_packages=None, pip_options=None, pip_packages=None):
#         """Creates a Dependencies object, updating from the one generated by `create_default()`."""
#         d = Dependencies.create_default()
#         if channels:
#             d.add_channels(*channels)
#         if conda_packages:
#             d.add_conda_packages(*conda_packages)
#         if pip_options:
#             d.add_pip_options(*pip_options)
#         if pip_packages:
#             d.add_pip_packages(*pip_packages)
#         return d

#     @property
#     def channels(self):
#         result = sorted(self._underlying.conda_channels)
#         if not result:
#             result = ['defaults']
#         return result

#     def add_channels(self, *channels):
#         for channel in channels:
#             self._underlying.add_channel(channel)

#     @property
#     def conda_packages(self):
#         return sorted(self._underlying.conda_packages)

#     def add_conda_packages(self, *packages):
#         for package in packages:
#             self._underlying.add_conda_package(package)

#     @property
#     def pip_options(self):
#         return sorted(self._underlying.pip_options)

#     def add_pip_options(self, *options):
#         for option in options:
#             self._underlying.set_pip_option(option)

#     @property
#     def pip_packages(self):
#         return sorted(self._underlying.pip_packages)

#     def add_pip_packages(self, *packages):
#         for package in packages:
#             self._underlying.add_pip_package(package)

#     @property
#     def flat_dict(self):
#         """Output a flat dict describing the dependencies, for SMT/JES/DS usage."""
#         return {
#             'CondaChannels': self.channels,
#             'CondaPackages': self.conda_packages,
#             'PipOptions': self.pip_options,
#             'PipPackages': self.pip_packages,
#         }

#     def to_dict(self):
#         """This is called when extracting module json spec file."""
#         return self.flat_dict

#     @property
#     def conda_dependency_dict(self):
#         """Merge raw data lists into a conda environment compatible dict, which will be dumped to a YAML file.

#         For conda environment file format please refer to:
#         https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-file-manually

#         Rules for generating conda environment YAML file:
#           1. Firstly, sort each of the lists alphabetically.
#           2. Merge PipOptions and PipPackages lists into one list. PipOptions comes before PipPackages.
#           3. Create a dictionary object with key 'pip', value is the list created in step 2.
#           4. Append this dictionary to the end of CondaPackages. (Only if the list created in step 2 is not empty.)
#           5. Create a dictionary with the following keys (make sure to keep the order):
#              * 'name': is hard-coded 'project_environment'
#              * 'channels': the CondaChannel list. if list is empty, set to a default list as ['defaults'].
#              * 'dependencies': is the CondaPackages list with pip appended to the end (if any).
#           6. Dump this dict to a yaml file.

#         WARNING:
#              Do NOT change this implementation.

#              AzureML service will create a hash for the generated YAML file,
#              which will be used as the key of the docker image cache.
#              If the implementation changed, and the image cache may fail to match,
#              causing performance problems.

#         WARNING 2:
#              There is also a C# version of this logic in the JES code base.

#              ref: `ConstructCondaDependency` method in the following code:
#              https://msdata.visualstudio.com/AzureML/_git/StudioCore?path=%2FProduct%2FSource%2FStudioCoreService%2FCommon%2FCommonHelper.cs&version=GBmaster

#              Please keep the C# code synced in case the implementation here
#              must be changed in the future.
#         """

#         dependencies = self.conda_packages
#         pip_options_and_packages = self.pip_options + self.pip_packages
#         if pip_options_and_packages:
#             pip_entry = {'pip': self.pip_options + self.pip_packages}
#             dependencies.append(pip_entry)

#         return {
#             'name': 'project_environment',
#             'channels': self.channels,
#             'dependencies': dependencies,
#         }

#     @property
#     def conda_dependency_yaml(self):
#         """Output a yaml file describing the dependencies, for AzureML Service usage."""
#         cd = CondaDependencies(_underlying_structure=self.conda_dependency_dict)
#         return cd.serialize_to_string()
