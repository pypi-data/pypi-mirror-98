Metadata-Version: 2.1
Name: eppy3000
Version: 0.1.12
Summary: E+ scripting using epJSON file format
Home-page: https://github.com/pyenergyplus/eppy3000
Author: Santosh Philip
Author-email: santosh@noemail.com
License: Mozilla Public License, v. 2.0
Keywords: eppy3000
Platform: UNKNOWN
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Requires-Dist: munch
Requires-Dist: eppy
Requires-Dist: json2html

========
eppy3000
========


.. image:: https://img.shields.io/pypi/v/eppy3000.svg
        :target: https://pypi.python.org/pypi/eppy3000

.. image:: https://img.shields.io/travis/pyenergyplus/eppy3000.svg
        :target: https://travis-ci.org/pyenergyplus/eppy3000

.. image:: https://readthedocs.org/projects/eppy3000/badge/?version=latest
        :target: https://eppy3000.readthedocs.io/en/latest/?badge=latest
        :alt: Documentation Status




E+ scripting using epJSON file format


* Free software: Mozilla Public License, v. 2.0
* Documentation: https://eppy3000.readthedocs.io.
* Home Page: https://github.com/pyenergyplus/eppy3000


Features - so far :-)
---------------------

* Open and read an epJSON file with *some* `eppy <https://github.com/santoshphilip/eppy>`_ functionality.
* Right now the `eppy <https://github.com/santoshphilip/eppy>`_ functionality is only partial


Background
----------

E+ has been moving from the IDD/IDF text format to a JSON format. `Eppy <https://github.com/santoshphilip/eppy>`_ reads the old IDD/IDF format. There is a need to have `eppy <https://github.com/santoshphilip/eppy>`_ read the JSON format and/or have a new package that will read the JSON format.

Whats in a name
---------------

Why is this package called eppy3000 ?

It is a play on the word python3000. Guido van van Rossum said about python in 2007 *"The first time I came up with the idea of Python 3000 was probably at a Python conference in the year 2000. The name was a take on Windows 2000. ...<snip>...  The idea was that Python 3000 would be the first Python release to give up backwards compatibility in favor of making it the best language going forward."*

Eppy3000 will also break backward compatibility with eppy. Also eppy3000 will be written only for python3. Eppy3000 and eppy will continue to remain the best scripting language for modelling :-)


So what is eppy3000
-------------------

This project is an attempt to read JSON file formats and work like eppy. There is some value in trying to do this from scratch. The dot syntax that makes the original eppy useful can be recreated with a couple of lines in eppy3000. It took a lot of deep hacking to make the dot syntax work in the original eppy. Eppy3000 reads the JSON format as a dictionary. The package `Munch <https://github.com/Infinidat/munch>`_ (what was `Bunch <https://github.com/dsc/bunch>`_) allows the use of dot format syntax with a dictionary. The code is as simple as::

    as_json = json.load(open(fname, 'r'))
    for_dot_syntax = DefaultMunch.fromDict(as_json)

At this point eppy3000 is an exploration to find out what is possible. The API in eppy3000 will not be stable as we explore the possibilities. So, don't use it as production code yet :-)


What about eppy
---------------

Eppy will be continue to be developed and maintained. A major task will be to make eppy read the new JSON formats. Initial investigations shows that it is not too hard to develop this functionality. Internally eppy will continue to use the old format. Hopefully this will make the JSON reading functionality trivially easy. At the moment, E+ maintains a one to one mapping between the old IDD/IDF format and the new JSON format. This mapping is embedded in the file Energy+.schema.epJSON, pointing to an easy compatibility strategy.

In the long term, this may not be a viable strategy, as E+ may totally abandon the IDD/IDF file format breaking the link between JSON and IDD/IDF. Discussion thread at `unmethours <https://unmethours.com/question/36062/hvac-templates-to-be-discontinued/>`_ seems to indicate that this is about 5 yers in the future.


Future possibilites
-------------------

A number of possibilites came up in discussions at Simbuild 2018 in Chicago. The biggest takeaway was that the code base for the JSON format and the dot syntax can lead to a universal translator between modelling file formats. The thinking here is that if there exists a schema.JSON for two modelling file structures, the possibility of translating between the two exists.

Of course *the proof is in the pudding*. So we are going to write some quick and dirty translators between E+ and DOE2.1E (or EQuest) as well as between the older idds and the new epJSON. Lets see how that goes.


Credits
-------

This package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.

.. _Cookiecutter: https://github.com/audreyr/cookiecutter
.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage


=======
History
=======

Releases
--------


Release 0.1.11  (2021-03-16)
----------------------------

2021-03-16
~~~~~~~~~~

Fixed #76

:Problem: Need easier conversion from IDF to epJSON
:Solution: ``idffile2epjfile`` will convert a single file and ``idffolder2epjfolder`` will do batch conversion

Date: Mon Jan 18 21:53:40 PST 2021
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

fixed issue #73

:Problem: Would be nice to have an html viewer for epj
:Solution: pytested eppy3000.epjviewer with sphinx user documentation

Date: Tue Jan 12 14:18:37 PST 2021
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

fixed issue #69

:Problem: no EPJ.run() function
:Solution: EPJ.run() function implemented


Release 0.1.4  (2020-07-09)
---------------------------


Date:   Tue Jul 7 08:09:26 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fixed issue #48

:Problem: No Tutorial for eppy3000
:Solution: tutorial for eppy3000

+ This tutorial is based on eppy tutorial
+ Identifies the gaps in the eppy3000 tagged by TODO in the tutorial
+ open issues on these TODOs and resolve


Release 0.1.3 (2020-07-04)
--------------------------

Date:   Wed May 13 14:20:34 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue # 45

    Problem: setup.py not including folders `oldeppy` and `experimental`
    Solution: setup.py updated and tested



Release 0.1.2 (2020-05-12)
--------------------------

Date:   Tue May 12 08:11:39 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue #41

    Problem: function to get an array of xyz points from the surfaces
    Solution: function in eppy300.experimental.listfields.surf2list()


Date:   Mon May 11 08:15:50 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue #34

    Problem: need an easy to use converter between
    epj (epyy300 format) and idf (eppy format)

    Solution: functions idf2epj() epj2idf() do this.
    epj.saveas(filename) and idf.saveas(filename)
    will save it to disk



Date:   Mon May 11 15:35:54 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue #39

    **Problem:** need a place to put experimental functions
    **Solution:** created an experimental folder in eppy3000


Date:   Mon May 11 08:15:50 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue #34

    Problem: need an easy to use converter between
    epj (epyy300 format) and idf (eppy format)

    Solution: functions idf2epj() epj2idf() do this.
    epj.saveas(filename) and idf.saveas(filename)
    will save it to disk



Sun May 10 09:26:32 2020 -0700
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    fixed issue #36

    Problem: modelbuilder.EPJ need savecopy() to fix issue #34
    Solution: coded EPJ.savecopy and EPJ.jsonstr()





Release 0.1.1 (2019-06-06)
--------------------------

2019-06-06
~~~~~~~~~~

- functions to read and write IDF files
    - issue #20

0.1.0 (2018-10-15)
------------------

* First release on PyPI.


