# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/dashboards.ipynb (unless otherwise specified).

__all__ = ['ObjectDetectionDatasetOverview', 'ObjectDetectionDatasetComparison', 'ObjectDetectionDatasetGenerator',
           'ObjectDetectionDatasetGenerator', 'ObjectDetectionResultOverview']

# Cell
from typing import Union, Optional, List
from abc import abstractmethod, ABC
from math import ceil, floor
import itertools

import matplotlib.pyplot as plt

from bokeh.plotting import show, output_notebook, gridplot, figure
from bokeh.models.widgets import DataTable, TableColumn, HTMLTemplateFormatter
from bokeh.models import ColumnDataSource, HoverTool, Title
from bokeh import events

import panel as pn
import panel.widgets as pnw
import numpy as np
import pandas as pd

from .core.dashboards import *
from .plotting import *
from .core.data import *
from .data import *
from .plotting.utils import toggle_legend_js

# Cell
class ObjectDetectionDatasetOverview(DatasetOverview):
    """Dataset overview for object detection datasets"""
    DESCRIPTOR_DATA = "data"
    DESCRIPTOR_STATS_DATASET = "stats_dataset"
    DESCRIPTOR_STATS_IMAGES = "stats_image"
    DESCRIPTOR_STATS_ANNOTATIONS = "stats_class"

    # change these
    IMAGE_IDENTIFIER_COL = "filepath"
    ANNOTATON_LABEL_COL = "label"
    OBJECTS_PER_IMAGE_COL = "num_annotations"
    AREA_COL = "area"

    def _generate_datset_stats_tab(self):
        dataset_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_DATASET), width=self.width, height=self.height//7)
        images_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_IMAGES), width=self.width, height=self.height//7)
        classes_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_ANNOTATIONS), width=self.width, height=self.height//4)

        class_occurances = self.dataset.data.groupby("label").count()["id"]
        class_occurance_barplot = barplot(counts=class_occurances.values, values=np.array(class_occurances.index), bar_type="vertical", height=(self.height//5)*2)

        return pn.Column("<b>Dataset stats</b>", dataset_overview_table, "<b>Image stats</b>", images_overview_table, "<b>Class stats</b>", classes_overview_table, pn.Row(class_occurance_barplot, align="center"))

    def _generate_annotations_tab(self):
        plot_size = floor(min(self.height, self.width)*0.45)
        # mixing of classes
        mixing_matrix_classes_in_images = utils.calculate_mixing_matrix(getattr(self.dataset, self.DESCRIPTOR_DATA), self.IMAGE_IDENTIFIER_COL, self.ANNOTATON_LABEL_COL)
        self.class_mixing_matrix_plot = pn.Column("<b>Class mixing</b>", heatmap(mixing_matrix_classes_in_images, "row_name", "col_name", "values", width=plot_size, height=plot_size), height=self.height)
        # number of object per image, stacked hist
        self.classes_for_objects_per_image_stacked_hist = pn.Column(
            "<b>Objects per Image</b>",
            stacked_hist(getattr(self.dataset, self.DESCRIPTOR_DATA), self.OBJECTS_PER_IMAGE_COL, self.ANNOTATON_LABEL_COL, "Objects per Image", width=plot_size, height=plot_size)
        )
        # categorical overview
        self.categorical_2d_histogram = categorical_2d_histogram_with_gui(
            getattr(self.dataset, self.DESCRIPTOR_DATA),
            category_cols=["label", "num_annotations", "width", "height"],
            hist_cols=["num_annotations", "area", "area_normalized", "area_square_root", "area_square_root_normalized", "bbox_ratio", "bbox_xmin", "bbox_xmax", "bbox_ymin", "bbox_ymax", "width", "height"],
            height=self.height//2, width=self.width//2
        )
        # ratio distribution
        grid =  pn.GridSpec(ncols=2,nrows=2, width=self.width, height=self.height, align="center")
        grid[0,0] = self.class_mixing_matrix_plot
        grid[1,0] = self.classes_for_objects_per_image_stacked_hist
        grid[:,1] = pn.Column(self.categorical_2d_histogram, align="center")
        return grid

    def _generate_gallery_tab(self):
        return pn.Column(Gallery(self.dataset, "data", "filepath", ["num_annotations", "width", "height", "label", "area", "bbox_ratio", "bbox_width", "bbox_height"], height=self.height).show(), align="center", sizing_mode="stretch_both")

    def build_gui(self):
        dataset_tab = super()._generate_dataset_tab()
        dataset_stats_tab = self._generate_datset_stats_tab()
        annotations_tab = self._generate_annotations_tab()
        gallery_tab = self._generate_gallery_tab()
        self.gui = pn.Tabs(("Dataset stats", dataset_stats_tab), ("Annotations", annotations_tab), ("Gallery", gallery_tab), ("Dataset", dataset_tab), align="start")

# Cell
class ObjectDetectionDatasetComparison(DatasetComparison):
    """Dataset comparison for object detection datasets."""
    DESCRIPTOR_DATA = "data"
    DESCRIPTOR_STATS_DATASET = "stats_dataset"
    DESCRIPTOR_STATS_IMAGES = "stats_image"
    DESCRIPTOR_STATS_ANNOTATIONS = "stats_class"

    # change these
    IMAGE_IDENTIFIER_COL = "filepath"
    ANNOTATON_LABEL_COL = "label"
    OBJECTS_PER_IMAGE_COL = "num_annotations"
    AREA_COL = "area"

    def _generate_dataset_tab(self):
        overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA), width=floor(self.width/2), height=self.height)
        return pn.Row(*overview_table)

    def _generate_datset_stats_tab(self):
        dataset_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_DATASET), width=floor(self.width/2), height=self.height//7)
        images_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_IMAGES), width=floor(self.width/2), height=self.height//7)
        classes_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_ANNOTATIONS), width=floor(self.width/2), height=self.height//4)

        class_occurances_values = [dataset.data.groupby("label").count()["id"].values for dataset in self.datasets]
        class_occurances_index = [np.array(dataset.data.groupby("label").count()["id"].index) for dataset in self.datasets]
        class_occurance_barplot = barplot(counts=class_occurances_values, values=class_occurances_index, bar_type="vertical", height=(self.height//5)*2, width=floor(self.width/2))

        dublication_data = {dataset.name if dataset.name is not None else "Dataset_"+str(index): [getattr(dataset, self.DESCRIPTOR_DATA).duplicated().sum()] for index, dataset in enumerate(self.datasets)}
        dublication_data["All"] = pd.concat(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA)).duplicated().sum()
        dublication_df = pd.DataFrame(dublication_data)
        dublication_overview = table_from_dataframe(dublication_df)

        return pn.Column(
            "<b>Dublications</p>", pn.Row(dublication_overview),
            "<b>Dataset stats</b>", pn.Row(*dataset_overview_table),
            "<b>Image stats</b>", pn.Row(*images_overview_table),
            "<b>Class stats</b>", pn.Row(*classes_overview_table),
            pn.Row(*class_occurance_barplot, align="center")
        )

    def _generate_annotations_tab(self):
        plot_size = min(floor(self.width/len(self.datasets)), floor(self.height/2))
        link_plots_checkbox = pnw.Checkbox(name="Link plot axis", value=False)

        @pn.depends(link_plots_checkbox.param.value)
        def _mixing_plots(link_plots):
            # mixing of classes
            mixing_matrix_classes_in_images = [utils.calculate_mixing_matrix(dataset, self.IMAGE_IDENTIFIER_COL, self.ANNOTATON_LABEL_COL) for dataset in self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA)]
            class_mixing_matrix_plot = pn.Row("<b>Class mixing</b>", *heatmap(mixing_matrix_classes_in_images, "row_name", "col_name", "values", link_plots=link_plots, width=plot_size, height=plot_size))
            # number of object per image, stacked hist
            classes_for_objects_per_image_stacked_hist = pn.Row(
                "<b>Objects per Image</b>",
                *stacked_hist(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA), self.OBJECTS_PER_IMAGE_COL, self.ANNOTATON_LABEL_COL, "Objects per Image", link_plots=link_plots, width=plot_size, height=plot_size)
            )
            return pn.Column(link_plots_checkbox, class_mixing_matrix_plot, classes_for_objects_per_image_stacked_hist)

        # categorical overview
        self.categorical_2d_histogram = categorical_2d_histogram_with_gui(
            self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA),
            category_cols=["label", "num_annotations", "width", "height"],
            hist_cols=["num_annotations", "area", "area_normalized", "area_square_root", "area_square_root_normalized", "bbox_ratio", "bbox_xmin", "bbox_xmax", "bbox_ymin", "bbox_ymax", "bbox_width", "bbox_height", "width", "height"],
            height=floor(plot_size*1.5), width=floor(plot_size*1.5)
        )
        return pn.Column(_mixing_plots, self.categorical_2d_histogram, align="center")

    def _generate_gallery_tab(self):
        return pn.Row(*[Gallery(dataset, "data", "filepath", ["num_annotations", "width", "height", "label", "area", "bbox_ratio", "bbox_width", "bbox_height"], width=floor(self.width/len(self.datasets))).show() for dataset in self.datasets], align="start", sizing_mode="stretch_both")

    def build_gui(self):
        dataset_tab = self._generate_dataset_tab()
        dataset_stats_tab = self._generate_datset_stats_tab()
        annotations_tab = self._generate_annotations_tab()
        gallery_tab = self._generate_gallery_tab()
        self.gui = pn.Tabs(("Dataset stats overview", dataset_stats_tab), ("Annotations overivew", annotations_tab), ("Gallery", gallery_tab), ("Dataset overview", dataset_tab), align="start")

# Cell
class ObjectDetectionDatasetGenerator(DatasetGeneratorScatter):
    """Dataset generator for object detection"""
    DESCRIPTOR_STATS = "stats_dataset"
    DATASET_OVERVIEW = ObjectDetectionDatasetOverview
    DATASET_FILTER_COLUMNS = ["width", "height", "label", "area_normalized", "bbox_ratio", "bbox_width", "bbox_height", "num_annotations"]

# Cell
class ObjectDetectionDatasetGenerator(DatasetGenerator):
    """Dataset generator for object detection"""
    DESCRIPTOR_STATS = "stats_dataset"
    DATASET_OVERVIEW = ObjectDetectionDatasetOverview
    DATASET_FILTER_COLUMNS = ["width", "height", "label", "area_normalized", "bbox_ratio", "bbox_width", "bbox_height", "num_annotations"]

# Cell
class ObjectDetectionResultOverview(Dashboard):
    """Overview dashboard """
    def __init__(self, dataset, plotting_backend="matplotlib", height=700, width=1000):
        self.dataset= dataset
        self.plotting_backend = plotting_backend
        super().__init__(width=width, height=height)

    def build_gui(self):
        self.loss_tab = self.build_loss_tab()
        self.ap_tab = self.build_precision_recall_tab()
        self.gui = pn.Tabs(("Loss", self.loss_tab), ("Precision-Recall", self.ap_tab))

    def show(self):
        return self.gui

    def show_loss_tab(self):
        return self.loss_tab

    def show_ap_tab(self):
        return self.ap_tab

    def build_loss_tab(self):
        # loss hists
        if self.plotting_backend == "bokeh":
            bins_input = pnw.IntInput(name="Bins", start=1, end=100, value=10)

            @pn.depends(bins_input.param.value)
            def loss_hists(bins):
                unique_losses = self.dataset.base_data[["filepath", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg", "loss_total"]].drop_duplicates()
                hist_line = plots_as_matrix(
                    histogram(
                        [unique_losses[loss] for loss in ["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"]],
                        title=["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"],
                        bins=bins, linked_axis=False), 5, 1, width=self.width, height=200
                )
                return hist_line
            loss_hists_col = pn.Column(bins_input, loss_hists)
        if self.plotting_backend == "matplotlib":
            fig_loss_hists, ax_loss_hists = plt.subplots(1, 5, figsize=(16*5,9))
            unique_losses = self.dataset.base_data[["filepath", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg", "loss_total"]].drop_duplicates()
            for single_ax, key in zip(ax_loss_hists, ["loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg", "loss_total"]):
                single_ax.hist(unique_losses[key].values, bins=20)
                single_ax.set_title(" ".join(key.split("_")).title(), fontsize=40)
                for tick in single_ax.xaxis.get_major_ticks():
                    tick.label.set_fontsize(34)
                    tick.label.set_rotation(45)
                for tick in single_ax.yaxis.get_major_ticks():
                    tick.label.set_fontsize(34)
            plt.close()
            loss_hists_col = pn.pane.Matplotlib(fig_loss_hists, width=self.width)
        axis_cols = ['score', 'area_normalized', 'area', 'bbox_ratio', 'bbox_width', 'bbox_height', 'num_annotations', 'loss_classifier', 'loss_box_reg', 'loss_objectness', 'loss_rpn_box_reg', 'loss_total', 'width', 'height']
        scatter_overview = scatter_plot_with_gui(
            self.dataset.base_data[self.dataset.base_data["is_prediction"] == True],
            x_cols=axis_cols[1:] + [axis_cols[0]],
            y_cols=axis_cols,
            color_cols=["label", "num_annotations", "filename"]
        )

        cat_2d_hist = categorical_2d_histogram_with_gui(
            self.dataset.base_data[self.dataset.base_data["is_prediction"] == True],
            category_cols=["label", "num_annotations", "filename"],
            hist_cols=['loss_total', 'loss_classifier', 'loss_box_reg', 'loss_objectness', 'loss_rpn_box_reg', 'score', 'area_normalized', 'area', 'bbox_ratio', 'bbox_width', 'bbox_height', 'num_annotations', 'width', 'height', 'label']
        )

        sub_tabs = pn.Tabs(
            ("Histograms", pn.Row(pn.Spacer(sizing_mode="stretch_width"), scatter_overview, pn.Spacer(sizing_mode="stretch_width"), cat_2d_hist, pn.Spacer(sizing_mode="stretch_width"), align="center")),
            ("Gallery", Gallery(self.dataset, "base_data", "filepath", sort_cols=["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"], height=self.height).show())
        )

        return pn.Column(loss_hists_col, sub_tabs)

    def build_ap_overview(self, metric_data):
        map_data = {key: [metric_data[key]["map"], int(len(metric_data[key].keys())-1)] for key in metric_data.keys()}
        map_table = table_from_dataframe(pd.DataFrame(map_data, index=["mAP", "Classes"]).round(4))

        ap_data = {}
        for metric_key, metric_value in metric_data.items():
            if metric_key != "map":
                ap_data[metric_key] = {"class": [], "ap": []}
                for class_name, class_data in metric_value.items():
                    if class_name != "map":
                        ap_data[metric_key]["class"].append(class_name)
                        ap_data[metric_key]["ap"].append(class_data["ap"])
        ap_plots = []
        for ap_key, ap_value in ap_data.items():
            if len(ap_value["ap"]) > 0:
                ap = np.array(ap_value["ap"])[np.array(ap_value["ap"]).argsort()]
                class_names = np.array(ap_value["class"])[np.array(ap_value["ap"]).argsort()]
                ap_plot = barplot(ap, class_names, bar_type="horizontal")
                ap_plot.add_tools(HoverTool(tooltips = [("AP", "@y @right")]))
                ap_plot.title = Title(text="mAP - " + str(metric_data[ap_key]["map"].round(4)), align="center")
                ap_plots.append(pn.Column("<b>"+ap_key.replace("_", " ").title().replace("Ap", "AP")+"</b>", ap_plot))

        return pn.Column(pn.Row(map_table, align="center"), pn.Row(*ap_plots, align="center"))

    @staticmethod
    def precision_recall_plot_bokeh(data, iou):
        plot_data = pd.DataFrame({key: data[key] for key in ["recall", "precision", "scores", "tp", "fp", "fn"]})
        source = ColumnDataSource(plot_data)
        p = figure(x_axis_type=None, height=350, width=400, title="AP@"+str(iou)+" - "+str(round(data["ap"],4)), y_axis_label="precision", tools="")
        p.line("recall", "precision", source=source, legend_label="Actual", color="black", line_width=2)
        p.step(data["ap11_recalls"], data["ap11_precisions"], legend_label="AP11", color="green", line_width=2)
        p.step(data["monotonic_recalls"], data["monotonic_precisions"], legend_label="Monotonic", color="firebrick", line_width=2)
        p.add_tools(HoverTool(tooltips=[("Score", "@scores"), ("TP", "@tp"), ("FP", "@fp"), ("FN", "@fn")], mode="vline"))
        p.js_on_event(events.DoubleTap, toggle_legend_js(p))
        p.legend.click_policy="hide"
        p_score = figure(x_range=p.x_range, height=150, width=400, x_axis_label="recall", y_axis_label="score", tools="")
        p_score.scatter(data["recall"], data["scores"])
        return pn.Row(gridplot([[p],[p_score]]))

    def plot_precision_recall_curves_for_class_bokeh(self, data, class_key):
        plot_list = []
        for iou, plot_data in data.items():
            if iou != "ap":
                plot_list.append(self.precision_recall_plot_bokeh(plot_data, iou))
        return plots_as_matrix(plot_list, 5, 2, width=400*5, height=500*2)

    def plot_additional_stats_bokeh(self, class_data, class_name):
        # histograms
        hist = histogram(list(class_data.values()))
        return pn.pane.Bokeh(hist)

    @staticmethod
    def precision_recall_plot_matplotlib(fig, data, iou, bottom, top, left, right):
        gs = fig.add_gridspec(nrows=4, ncols=1, left=left, right=right, bottom=bottom, top=top, hspace=0)
        ax1 = fig.add_subplot(gs[:3, :])
        ax1.set_title("IOU: " + str(iou))
        ax1.plot(data["recall"], data["precision"], label="Actual", color="black", lw=2)
        ax1.plot(data["ap11_recalls"], data["ap11_precisions"], label="AP11", color="green", lw=2)
        ax1.plot(data["monotonic_recalls"], data["monotonic_precisions"], label="Montonic", color="firebrick", lw=2)
        ax1.set_xticks([])
        ax1.set_ylabel("Precision")
        ax1.legend()
        ax2 = fig.add_subplot(gs[-1, :])
        ax2.plot(data["recall"], data["scores"], ".")
        ax2.set_xlabel("Recall")
        ax2.set_ylabel("Score")

    def plot_precision_recall_curves_for_class_matplotlib(self, data, class_key):
        fig = plt.figure(constrained_layout=False, figsize=(16,9))
        row_coords = [(0.55, 0.95), (0.05, 0.45)]
        col_coords = [(0.05, 0.2), (0.25, 0.4), (0.45, 0.6), (0.65, 0.8), (0.85, 1)]
        coord_combinations = list(itertools.product(row_coords, col_coords))
        ious = sorted([iou for iou in data.keys() if iou != "ap"])
        for index, iou in enumerate(ious):
            if iou != "ap":
                row_coord = coord_combinations[index][0]
                col_coord = coord_combinations[index][1]
                self.precision_recall_plot_matplotlib(fig, data[iou], iou, row_coord[0], row_coord[1], col_coord[0], col_coord[1])
        plt.close()
        return pn.pane.Matplotlib(fig, width=self.width)

    def plot_additional_stats_matplotlib(self, class_data, class_name):
        # histograms
        class_data[0.5]["additional_stats"]
        hist_fig, hist_ax = plt.subplots(1, len(class_data[0.5]["additional_stats"]), figsize=(9*len(class_data[0.5]["additional_stats"]), 9))
        for ax, (stat_name, stat_data) in zip(hist_ax, class_data[0.5]["additional_stats"].items()):
            ax.hist(stat_data, bins=20)
            ax.set_xlabel(" ".join(stat_name.split("_")).title(), fontsize=32)
            ax.set_ylabel("Counts", fontsize=32)
            ax.ticklabel_format(style='sci', axis='x', scilimits=(0,0))
            ax.xaxis.offsetText.set_fontsize(34)
            for x_tick, y_tick in zip(ax.xaxis.get_major_ticks(),  ax.yaxis.get_major_ticks()):
                x_tick.label.set_fontsize(34)
                y_tick.label.set_fontsize(34)
            for x_tick, y_tick in zip(ax.xaxis.get_minor_ticks(),  ax.yaxis.get_minor_ticks()):
                x_tick.label.set_fontsize(34)
                y_tick.label.set_fontsize(34)
        plt.tight_layout()
        plt.close()
        return pn.pane.Matplotlib(hist_fig, width=self.width)

    def build_precison_recall_overview(self, data):
        if len(data) == 1:
            return pn.Column("<h1> No information available</h1>")
        class_select = pnw.Select(options=[key for key in data.keys() if key != "map"])
        @pn.depends(class_select.param.value)
        def _plot(class_name):
            heading = pn.Row("<h1>AP - "+str(data[class_name]["ap"].round(4))+"</h1>", align="center")
            table_data = {"AP": [round(data[class_name][iou_key]["ap"],4) for iou_key in data[class_name].keys() if iou_key != "ap"]}
            table_df = pd.DataFrame(table_data).T
            table_df.columns = [iou_key for iou_key in data[class_name].keys() if iou_key != "ap"]
            table_df.index.names = ["iou"]
            overview_table = table_from_dataframe(table_df)
            if self.plotting_backend == "bokeh":
                precision_recall_curves = self.plot_precision_recall_curves_for_class_bokeh(data[class_name], class_name)
                if "additional_stats" in next(iter(data[class_name].values())).keys():
                    additional_stats_plot = self.plot_additional_stats_bokeh(data[class_name], class_name)
                    return pn.Column(heading, pn.Row(overview_table, align="center"), precision_recall_curves, additional_stats_plot)
            else:
                precision_recall_curves = self.plot_precision_recall_curves_for_class_matplotlib(data[class_name], class_name)
                if "additional_stats" in next(iter(data[class_name].values())).keys():
                    additional_stats_plot = self.plot_additional_stats_matplotlib(data[class_name], class_name)
                    return pn.Column(heading, pn.Row(overview_table, align="center"), precision_recall_curves, additional_stats_plot)
            return pn.Column(heading, pn.Row(overview_table, align="center"), precision_recall_curves)
        return pn.Column(class_select, _plot, width=self.width)

    def build_precision_recall_tab(self):
        overview_tab = self.build_ap_overview(self.dataset.metric_data_ap)
        ap_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP"])
        ap_small_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_small"])
        ap_medium_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_medium"])
        ap_large_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_large"])

        return pn.Tabs(("Overview", overview_tab), ("AP", ap_tab), ("AP_small", ap_small_tab), ("AP_medium", ap_medium_tab), ("AP_large", ap_large_tab))