# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/dashboards.ipynb (unless otherwise specified).

__all__ = ['RecordDatasetOverview', 'MultiDatasetOverview', 'DatasetFilter', 'DatasetFilterThatExportsRecordDataset',
           'DatasetCreator']

# Cell
from typing import Union

from bokeh.plotting import show, output_notebook
from bokeh.models.widgets import DataTable, TableColumn, HTMLTemplateFormatter
from bokeh.models import ColumnDataSource

import panel as pn
import panel.widgets as pnw
import pandas as pd

from .utils import *
from .components import *

# Cell
class RecordDatasetOverview:
    def __init__(self, record_dataset, height=500, width=1500):
        """If records is None no gallery will be generated. If the data is generated with aggregate_record_data and class map is used the class map needs to be provided as well."""
        self.record_dataset = record_dataset
        self.height = height
        self.width = width

    def _generate_dataset_tab(self):
        overview_table = table_from_dataframe(self.record_dataset.data, width=self.width, height=self.height)
        return pn.Column(overview_table)

    def _generate_image_tab(self):
        overview_table = table_from_dataframe(self.record_dataset.image_stats, width=self.width, height=50)
        if self.record_dataset.records is None:
            img_gallery = None
        else:
            img_gallery = gallery(self.record_dataset.records, self.record_dataset.class_map, height=self.height-20)
        return pn.Column(pn.Row(overview_table, align="center"), pn.Row(img_gallery, align="center"))

    def _generate_class_tab(self):
        overview_table = table_from_dataframe(self.record_dataset.class_stats, height=150)
        mixing_matrix_df, mapping = calculate_mixing_matrix(self.record_dataset.data, mixing_col="filepath", mixing_objects="label")
        plot_height = min(self.height-150, int(self.width/2))
        mixing_histogram = histogram_2d(mixing_matrix_df, "row_name", "col_name", "values", height=plot_height, width=plot_height)
        stacked_annotations_per_image_hist = annotations_per_image_stacked_hist(self.record_dataset.data, height=plot_height, width=plot_height)
        return pn.Column(pn.Row(overview_table, align="center"), pn.Row(mixing_histogram, stacked_annotations_per_image_hist, align="start"), align="center")

    def show(self):
        dataset_tab = self._generate_dataset_tab()
        image_tab = self._generate_image_tab()
        class_tab = self._generate_class_tab()

        return pn.Tabs(("Dataset overview", dataset_tab), ("Image stats", image_tab), ("Class stats", class_tab), width=self.width, align="start")

# Cell
class MultiDatasetOverview:
    def __init__(self, datasets, cols=None, height=500, width=1500):
        self._datasets = datasets
        self.cols = cols
        self.width = width
        self.height = height

    def show(self):
        if len(self._datasets) == 0:
            return None
        del_button = pnw.Button(name="Delete", width=self.width)
        datasets_overview = create_datasets_overview(self._datasets, self.cols, width=self.width, height=150)
        dataset_overview = RecordDatasetOverview(self._datasets[datasets_overview.selection[0]], width=self.width, height=self.height-150).show()
        gui = pn.Column(del_button, datasets_overview, dataset_overview)

        def update_on_table_selection(selection):
            nonlocal dataset_overview
            old_active = dataset_overview.active
            dataset_overview = RecordDatasetOverview(self._datasets[selection.new[0]], width=self.width, height=int(self.height*0.7)).show()
            dataset_overview.active = old_active
            gui[-1] = dataset_overview
        datasets_overview.param.watch(update_on_table_selection, 'selection')

        def delete_entry(clicks):
            nonlocal datasets_overview
            nonlocal dataset_overview
            nonlocal gui
            self._datasets.observable_list = [dataset for index, dataset in enumerate(self._datasets) if index not in datasets_overview.selection]
            datasets_overview = create_datasets_overview(self._datasets, self.cols, width=self.width, height=int(0.3*self.height))
            datasets_overview.param.watch(update_on_table_selection, 'selection')
            gui[1] = datasets_overview

            if len(self._datasets) == 0:
                gui[-1] = None
            else:
                old_active = dataset_overview.active
                dataset_overview = RecordDatasetOverview(self._datasets[datasets_overview.selection[0]], width=self.width, height=int(self.height*0.7)).show()
                dataset_overview.active = old_active
                gui[-1] = dataset_overview
        del_button.on_click(delete_entry)

        return gui

# Cell
class DatasetFilter:
    """Creates a gallery with filter options to select subsets of the data. If the export_varialbe is set to a variable, that is a list a dict with the current selection (pd.Dataframe (key: data) and list of records (key: records)) will be append to the list."""
    def __init__(self, record_dataset, export_variable: Union[list, None] = None, height=500, width=500):
        self.record_dataset = record_dataset
        self.export_variable = export_variable
        self.width = width
        self.height = height

        self.filters = []

    @staticmethod
    def _get_mask_from_range(values, selections):
        return (values >= selections[0]) & (values < selections[1])

    @staticmethod
    def export_filter(filtered_records, filtered_data, record_dataset):
        "Filter function applied to the output of get_filtered_records_and_data inside the show function. This is to allow for modification of the exported data."
        return {"data": filtered_data, "records": filtered_records}

    def show(self):
        """Creates a gallery with filter options to select subsets of the data. If the export_varialbe is set to a variable, that is a list a dict with the current selection (pd.Dataframe (key: data) and list of records (key: records)) will be append to the list."""
        # generate bbox filters
        options = self.record_dataset.data["label"].unique()
        options.sort()
        bbox_class_filter = pnw.MultiSelect(name="Class", options=options.tolist(), value=options.tolist())
        bbox_num_annotations_filter = generate_range_filter(self.record_dataset.data["num_annotations"], "Num. Annotations", steps=self.record_dataset.data["num_annotations"].max()+3, width=int(self.width/2))
        bbox_area_filter = generate_range_filter(self.record_dataset.data["area"], "Area", steps=50, width=int(self.width/2))
        bbox_width_filter = generate_range_filter(self.record_dataset.data["bbox_width"], "Bbox width", steps=50, width=int(self.width/2))
        bbox_height_filter = generate_range_filter(self.record_dataset.data["bbox_height"], "Bbbox height", steps=50, width=int(self.width/2))
        bbox_ratio_filter = generate_range_filter(self.record_dataset.data["bbox_ratio"], "Ratio", steps=50, width=int(self.width/2))
        annotation_filters = pn.Row(pn.Column(bbox_class_filter, bbox_num_annotations_filter, bbox_area_filter, width=int(self.width/2)), pn.Column(bbox_width_filter, bbox_height_filter, bbox_ratio_filter, width=int(self.width/2)))

        # generate image filters
        file_creation_modification_time_filter = generate_creation_modification_time_filter(self.record_dataset.data, width=int(self.width/2))
        file_width_filter = generate_range_filter(self.record_dataset.data["width"], "Width", steps=50, width=int(self.width/2))
        file_height_filter = generate_range_filter(self.record_dataset.data["height"], "Height", steps=50, width=int(self.width/2))
        file_filters = pn.Row(pn.Column(file_creation_modification_time_filter, width=int(self.width/2)), pn.Column(file_width_filter, file_height_filter, width=int(self.width/2)))

        filters = pn.Tabs(("File filters", file_filters), ("Annotation filters", annotation_filters), ("Gallery", None), width=self.width, active=1)

        def get_filtered_records_and_data():
            filtered_data = self.record_dataset.data[
                self.record_dataset.data["label"].isin(bbox_class_filter.value)
                & self._get_mask_from_range(self.record_dataset.data["num_annotations"], bbox_num_annotations_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["area"], bbox_area_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["bbox_width"], bbox_width_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["bbox_height"], bbox_height_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["bbox_ratio"], bbox_ratio_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["creation_date"], file_creation_modification_time_filter[1].value)
                & self._get_mask_from_range(self.record_dataset.data["modification_date"], file_creation_modification_time_filter[2].value)
                & self._get_mask_from_range(self.record_dataset.data["width"], file_width_filter[0].value)
                & self._get_mask_from_range(self.record_dataset.data["height"], file_height_filter[0].value)
            ]
            filtered_records = [self.record_dataset.records[i] for i in filtered_data["record_index"].unique()]
            return filtered_records, filtered_data

        @pn.depends(
            bbox_class_filter.param.value, bbox_num_annotations_filter[0].param.value_throttled, bbox_area_filter[0].param.value_throttled,
            bbox_width_filter[0].param.value_throttled, bbox_height_filter[0].param.value_throttled, bbox_ratio_filter[0].param.value_throttled,
            file_creation_modification_time_filter[1].param.value_throttled, file_creation_modification_time_filter[2].param.value_throttled,
            file_width_filter[0].param.value_throttled, file_height_filter[0].param.value_throttled
        )
        def _gallery(
            classes_selection, num_annotation_selection, area_selection, width_selection, height_selection, ratio_selection,
            image_creation_date_selection, image_modification_date_selection, image_with_selection, image_height_selection
        ):
            filtered_records, filtered_data = get_filtered_records_and_data()
            if len(filtered_records) == 0:
                return None
            else:
                # update filter histograms
                bbox_num_annotations_filter[1] = histogram(
                    self.record_dataset.data.groupby("id").count()["width"], bins=20, height=100, width=int(self.width/2),
                    range=(self.record_dataset.data.groupby("id").count()["width"].min(), self.record_dataset.data.groupby("id").count()["width"].max()), remove_tools=True)
                new_bbox_area_filter = histogram(filtered_data["area"], bins=20, height=100, width=int(self.width/2), range=(self.record_dataset.data["area"].min(), self.record_dataset.data["area"].max()), remove_tools=True)
                new_bbox_width_filter = histogram(filtered_data["bbox_width"], bins=20, height=100, width=int(self.width/2), range=(self.record_dataset.data["bbox_width"].min(), self.record_dataset.data["bbox_width"].max()), remove_tools=True)
                new_bbox_height_filter = histogram(filtered_data["bbox_height"], bins=20, height=100, width=int(self.width/2), range=(self.record_dataset.data["bbox_height"].min(), self.record_dataset.data["bbox_height"].max()), remove_tools=True)
                new_bbox_ratio_filter = histogram(filtered_data["bbox_ratio"], bins=20, height=100, width=int(self.width/2), range=(self.record_dataset.data["bbox_ratio"].min(), self.record_dataset.data["bbox_ratio"].max()), remove_tools=True)

                bbox_area_filter[1], bbox_width_filter[1], bbox_height_filter[1], bbox_ratio_filter[1] = new_bbox_area_filter, new_bbox_width_filter, new_bbox_height_filter, new_bbox_ratio_filter

                return gallery(filtered_records, width=self.width, height=self.height)

        if self.export_variable is not None:
            def export(event):
                filtered_records, filtered_data = get_filtered_records_and_data()
                export_result = self.export_filter(filtered_records, filtered_data, self.record_dataset)
                self.export_variable.append(export_result)

            export_button = pnw.Button(name="Export")
            export_button.on_click(export)
            filters[2] = ("Gallery", _gallery)
            return pn.Column(filters, export_button, align="center")
        else:
            return pn.Column(filters, align="center")

# Cell
class DatasetFilterThatExportsRecordDataset(DatasetFilter):
    @staticmethod
    def export_filter(filtered_records, filtered_data, record_dataset):
        return RecordDataset.load_from_record_dataframe(filtered_data, record_dataset.class_map)

# Cell
class DatasetCreator:
    def __init__(self, record_dataset, class_map=None, height=700, width=1000):
        self.height = height
        self.width = width
        self.record_dataset = record_dataset
        self._datasets = ObservableList([])
        self._datasets.register_callback(self.update_datasets_overview)
        self._filter = DatasetFilterThatExportsRecordDataset(self.record_dataset, export_variable=self._datasets, width=self.width, height=self.height).show()
        self._gui = pn.Tabs(("Filter datasets", self._filter), ("Inspect datasets", MultiDatasetOverview(self._datasets, width=self.width, height=self.height).show()), ("Export datasets", self.export_gui()))

    def export_datasets(self, clicks):
        print("Test")
        export_path = self._gui[-1][0].value
        for dataset in self._datasets:
            dataset.save(export_path)


    def export_gui(self):
        export_path = pnw.TextInput(name="Export path", value="datasets")
        export_button = pnw.Button(name="Export")
        export_button.on_click(self.export_datasets)

        datasets_overview = create_datasets_overview(self._datasets)

        dataset_name = "" if len(self._datasets) == 0 else self._datasets[datasets_overview.selection[0]].name
        description_name = "" if len(self._datasets) == 0 else self._datasets[datasets_overview.selection[0]].description
        name_input = pnw.TextInput(name="Dataset name", value=dataset_name)
        description_input = pnw.TextAreaInput(name="Description", value=description_name)

        def update_name_and_description_update(event):
            nonlocal datasets_overview
            nonlocal self
            if event.obj.name == "Dataset name":
                self._datasets[datasets_overview.selection[0]].name = event.new
            elif event.obj.name == "Description":
                self._datasets[datasets_overview.selection[0]].description = event.new
            self.update_datasets_overview(None)

        name_input.param.watch(update_name_and_description_update, "value")
        description_input.param.watch(update_name_and_description_update, "value")

        return pn.Column(export_path, datasets_overview, name_input, description_input, export_button)

    def update_datasets_overview(self, datasets):
        self._gui[1] = ("Inspect datasets", MultiDatasetOverview(self._datasets, width=self.width, height=self.height).show())
        self._gui[-1] = ("Export datasets", self.export_gui())

    def show(self):
        return self._gui