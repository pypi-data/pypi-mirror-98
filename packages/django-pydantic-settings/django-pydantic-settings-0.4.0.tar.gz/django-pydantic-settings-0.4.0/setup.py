# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pydantic_settings']

package_data = \
{'': ['*']}

install_requires = \
['Django>=1.11', 'dj-database-url>=0.5.0,<0.6.0', 'pydantic[email]>=1.8,<2.0']

extras_require = \
{':python_version < "2.8"': ['typing-extensions>=3.7.4,<4.0.0'],
 'sentry': ['sentry-sdk']}

setup_kwargs = {
    'name': 'django-pydantic-settings',
    'version': '0.4.0',
    'description': 'Manage Django settings with Pydantic.',
    'long_description': '# django-pydantic-settings\n\n## Use pydantic settings management to simplify configuration of Django settings.\n\nVery much a work in progress, but reads the standard DJANGO_SETTINGS_MODULE environment variable (defaulting to pydantic_settings.settings.PydanticSettings) to load a sub-class of pydantic_settings.Settings. All settings (that have been defined in pydantic_settings.Settings) can be overridden with environment variables. A special DatabaseSettings class is used to allow multiple databases to be configured simply with DSNs. In theory, django-pydantic-settings should be compatible with any version of Django that runs on Python 3.6.1+ (which means Django 1.11 and on), but is only tested against officially supported versions (currently 2.2, 3.0, and 3.1).\n\nNote: as of django-pydantic-settings 0.4.0, Pydantic 1.8+ is required, which means Python 3.6.1+ is also required. If you need to use Python 3.6, you\'ll need to stick with django-pydantic-settings <0.4.0.\n\n## Installation & Setup\n\nInstall django-pydantic-settings:\n\n```\npip install django-pydantic-settings\n```\n\nModify your Django project\'s `manage.py` file to use django-pydantic-settings, it should look something like this:\n\n```python\n#!/usr/bin/env python\n"""Django\'s command-line utility for administrative tasks."""\nimport sys\n\nfrom pydantic_settings import SetUp\n\n\ndef main():\n    """Run administrative tasks."""\n    SetUp().configure()\n\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            "Couldn\'t import Django. Are you sure it\'s installed and "\n            "available on your PYTHONPATH environment variable? Did you "\n            "forget to activate a virtual environment?"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\n\nif __name__ == "__main__":\n    main()\n```\n\nYour `wsgi.py` and/or `asgi.py` files will need to be modified similarly, and look something like this:\n\n```python\nfrom django.core.wsgi import get_wsgi_application\n\nfrom pydantic_settings import SetUp\n\nSetUp().configure()\napplication = get_wsgi_application()\n```\n\nThe `SetUp` class will automatically look for the standard `DJANGO_SETTINGS_MODULE` environment variable, read it, confirm that it points to an existing Python module, and load that module. Your `DJANGO_SETTINGS_MODULE` variable should point to a `pydantic_settings.settings.PydanticSettings` sub-class (though technically any Python class that defines a `dict()` method which returns a Python dictionary of key/value pairs matching the required Django settings will work). Calling the `configure()` method will then use the specified module to configure your project\'s Django settings.\n\n## Required settings\n\nThere are no settings that must be configured in order to use Django with django-pydantic-settings. All of the possible settings defined by Django ([Settings Reference](https://docs.djangoproject.com/en/3.1/ref/settings/)) are configured in the `pydantic_settings.settings.PydanticSettings` class, using their normal default values provided by Django, or a reasonable calculated value. Settings worth thinking about are `ROOT_URLCONF` and `WSGI_APPLICATION`, which, unless otherwise specified, are calculated based on your `DJANGO_SETTINGS_MODULE` assuming that you\'re using the default Django project layout a provided by `django-admin.py startproject`. So, for example, if your `DJANGO_SETINGS_MODULE` is set to `my_awesome_project.settings.PydanticSettingsSubclass`, then `ROOT_URLCONF` and `WSGI_APPLICATION` will be set to `my_awesome_project.urls` and `my_awesome_project.wsgi` respectively. This default behavior can be overridden by simply specifying `ROOT_URLCONF:str = \'the_actual_urlconf\'` and `WSGI_APPLICATION:str = \'the_actual_wsgi_file.application\'` in your `PydanticSettings` sub-class. Alternatively, rather than individually settings the `ROOT_URLCONF` and `WSGI_APPLICATION` settings, you can set `BASE_DIR`, and that will be used instead of `DJANGO_SETTINGS_MODULE`.\n\nThe other setting worth thinking about is `SECRET_KEY`. By default, `SECRET_KEY` is automatically generated using Django\'s own `get_random_secret_key()` function. This will work just fine, though as it will be re-calculated every time your `PydanticSettings` sub-class is instantiated, you should set this to somethign static if you\'re using Django\'s authentication and don\'t want to lose your session every time the server is restarted.\n\n## Database configuration\n\nBy defining multiple `DatabaseDsn` attributes of the `DatabaseSettings` class, you can easily configure one or more database connections with environment variables. DSNs are parsed using dj-database-url. In order to support Google Cloud SQL database connections from within Google Cloud Run, the DatabaseDsn type will detect and automatically escape DSN strings of the form `postgres://username:password@/cloudsql/project:region:instance/database` so that they can be properly handled by dj-database-url.\n\n```python\nclass DatabaseSettings(BaseSettings):\n    default: DatabaseDsn = Field(env="DATABASE_URL")\n    secondary: DatabaseDsn = Field(env="SECONDARY_DATABASE_URL")\n```\n\n```python\nâ¯ DATABASE_URL=postgres://username:password@/cloudsql/project:region:instance/database SECONDARY_DATABASE_URL=sqlite:///foo poetry run python settings_test/manage.py shell\nPython 3.9.1 (default, Jan 12 2021, 16:45:25) \n[GCC 8.3.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n(InteractiveConsole)\n>>> from rich import print\n>>> from django.conf import settings\n>>> print(settings.DATABASES)\n{\n    \'default\': {\n        \'NAME\': \'database\',\n        \'USER\': \'username\',\n        \'PASSWORD\': \'password\',\n        \'HOST\': \'/cloudsql/project:region:instance\',\n        \'PORT\': \'\',\n        \'CONN_MAX_AGE\': 0,\n        \'ENGINE\': \'django.db.backends.postgresql_psycopg2\'\n    },\n    \'secondary\': {\'NAME\': \'foo\', \'USER\': \'\', \'PASSWORD\': \'\', \'HOST\': \'\', \'PORT\': \'\', \'CONN_MAX_AGE\': 0, \'ENGINE\': \'django.db.backends.sqlite3\'}\n}\n>>> \n```\n\n## Sentry configuration\n\ndjango-pydantic-settings provides built-in functionality for configuring your Django project to use [Sentry](https://sentry.io/). The simplest way to use this is to inherit from `pydantic_settings.sentry.SentrySettings` rather than `pydantic_settings.settings.PydanticSettings`. This adds the setting `SENTRY_DSN`, which uses the `pydantic_settings.sentry.SentryDsn` type. This will automatically be set according to the `DJANGO_SENTRY_DSN` environment variable, and expects a Sentry DSN (obviously). It validates that the provided DSN is a valid URL, and then automatically initializes the Sentry SDK using the built-in DjangoIntegration. Using this functionality required `sentry-sdk` to be installed, which will be included automatically if you install `django-pydantic-settings[sentry]`.\n',
    'author': 'Josh Ourisman',
    'author_email': 'me@josho.io',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/joshourisman/django-pydantic-settings',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.6.1,<4.0.0',
}


setup(**setup_kwargs)
