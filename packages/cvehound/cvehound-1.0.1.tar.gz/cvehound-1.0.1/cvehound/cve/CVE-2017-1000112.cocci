/// Files: net/ipv4/ip_output.c net/ipv6/ip6_output.c
/// Fix: 85f1bd9a7b5a79d5baa8bf44af19658f7bf77bfa
/// Fixes: e89e9cf539a28df7d0eb1d0a545368e9920b34ac

virtual detect

@err__ip_append_data exists@
position p;
@@

\(__ip_append_data\|ip_append_data\)(...)
{
	...
(
*	if ((((length + \((skb ? skb->len : fragheaderlen)\|fragheaderlen\)) > mtu) ||
*	     (skb && skb_is_gso(skb)))@p &&
	    (sk->sk_protocol == IPPROTO_UDP) && ... ) {
		...
		ip_ufo_append_data(...)
		...
	}
|
*	if (((length > mtu) ||@p \((skb && skb_is_gso(skb))\|!skb_queue_empty(&sk->sk_write_queue)\)) &&
	    (sk->sk_protocol == IPPROTO_UDP) && ...) {
		...
		ip_ufo_append_data(...)
		...
	}
|
*	if (((length > mtu) &&@p (sk->sk_protocol == IPPROTO_UDP)) && ...) {
		...
		ip_ufo_append_data(...)
		...
	}
)
	...
}

@err__ip6_append_data exists@
position p;
@@

\(__ip6_append_data\|ip6_append_data\)(...)
{
	...
(
*	if ((((length + \((skb ? skb->len : headersize)\|fragheaderlen\)) > mtu) ||
*	     (skb && skb_is_gso(skb)))@p &&
	    (sk->sk_protocol == IPPROTO_UDP) && ... ) {
		...
		ip6_ufo_append_data(...)
		...
	}
|
*	if (((length > mtu) ||@p (skb && skb_is_gso(skb))) &&
	    (sk->sk_protocol == IPPROTO_UDP) && ...) {
		...
		ip6_ufo_append_data(...)
		...
	}
|
*	if (((length > mtu) &&@p (sk->sk_protocol == IPPROTO_UDP)) && ...) {
		...
		ip6_ufo_append_data(...)
		...
	}
|
	if (length > mtu) {
		...
*		if (proto == IPPROTO_UDP &&@p
*		   (rt->u.dst.dev->features & NETIF_F_UFO)) {
			...
			ip6_ufo_append_data(...)
			...
		}
	}
)
	...
}

@script:python depends on detect@
p << err__ip_append_data.p;
@@

coccilib.report.print_report(p[0], 'ERROR: CVE-2017-1000112')

@script:python depends on detect@
p << err__ip6_append_data.p;
@@

coccilib.report.print_report(p[0], 'ERROR: CVE-2017-1000112')
