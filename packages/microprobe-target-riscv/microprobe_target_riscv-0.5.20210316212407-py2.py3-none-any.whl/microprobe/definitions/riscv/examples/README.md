# RISC-V Microprobe Examples

## Single instruction testcases

```bash
./riscv_ipc.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA] [--uarch UARCH]
                    [--env ENV]
                    [--dependency-distances DEPENDENCY_DISTANCES [DEPENDENCY_DISTANCES ...]]
                    [--instructions INSTRUCTIONS [INSTRUCTIONS ...]]
                    [--loop-size LOOP_SIZE]

```

### Description

The structure of this example is modeled off of [riscv-tests](https://github.com/riscv/riscv-tests).
However, the underlying tests are generated by Microprobe.

For this example, we explore variations in RAW dependency distance.
By dependency distance, we mean the distance (in terms of _number of instructions_) between
which a register result is produced and it is consumed.
The following sequence of instructions has a dependency distance of 1:

```asm
ADD x10, x9, x5
ADD x12, x11, x10
ADD x14, x13, x12
```

Each instruction produces a result that is needed by the next instruction, e.g., `x10` is
produced by the first instruction and consumed by the second.
The following sequence has a dependency distance of 2:

```asm
ADD x11, x10, x9
ADD x13, x12, x5
ADD x15, x14, x11
```

Here, `x11` is produced by the first instruction and consumed by the _third_.

The included program `riscv_ipc.py` will produce microbenchmarks that have different
dependency distances.  Go ahead and run this now with `./riscv_ipc.py`.
This produces a number of benchmarks in `riscv_ipc/`, e.g., `ADD_V0_1.S` and `ADD_V0_2.S`
that produce assembly sequences like those shown above.  Additionally, this produces a
Makefile fragment, `tests.d`, that describes all the microbenchmarks that were generated.
The provided build flow will consume this later.

Now, we need to setup an out-of-source build environment.
These microbenchmarks depend on a number of header files provided by
[`riscv-tests`](https://github.com/riscv/riscv-tests) and [`riscv-test-env`](https://github.com/riscv/riscv-test-env).
Hence, when configuring the project, we need to provide a path to an existing
clone of `riscv-tools`, represented by the bash variable `$RISCV_TOOLS_DIRECTORY`
(substitute in a real path here!).

```bash
autoconf
mkdir build
cd build
../configure --with-riscvtools=$RISCV_TOOLS_DIRECTORY
```

You need to have a suitable RISC-V cross compiler (specifically `riscv64-unknown-elf-gcc`)
available on your path to compile the microbenchmarks.  You can then run `make` to
compile all the Microprobe generated microbenchmarks int `build/riscv_ipc/`.

These can then be run on suitable RISC-V hardware or in a simulation/emulation environment, e.g., :

```
spike riscv_ipc/riscv_ipc-p-ADD_V0_1
```

Note that the loops generated with the examples provided are endless. I.e.
they have a non-conditional branch at the end of the sequence generated that
branch at the start. You can control that behavior by setting the `endless`
parameter accordingly in the example python scripts.

## Permutations of a sequence of instructions

```bash
./riscv_ipc_seq.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA]
                        [--uarch UARCH] [--env ENV]
                        [--dependency-distances DEPENDENCY_DISTANCES [DEPENDENCY_DISTANCES ...]]
                        [--instructions INSTRUCTIONS [INSTRUCTIONS ...]]
                        [--loop-size LOOP_SIZE]
                        [--num_permutations NUM_PERMUTATIONS]
                        [--microbenchmark_name MICROBENCHMARK_NAME]

```

The program `riscv_ipc_seq.py` is used if we need to generate microbenchmarks containing a
sequence of instructions. It generates N microbenchmarks comprising different randomly
selected permutations of the instruction sequence specified, where N is specified by the
optional argument: `num_permutations`. By default this value is 1, which generates a single
randomly selected permutation of the instruction sequence.

It generates the test cases in the same format as the previous example, so you
need to follow the same instructions to compile and check them.

## Single instruction testcases in C format

```bash
./riscv_ipc_c.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA] [--uarch UARCH]
                    [--env ENV]
                    [--dependency-distances DEPENDENCY_DISTANCES [DEPENDENCY_DISTANCES ...]]
                    [--instructions INSTRUCTIONS [INSTRUCTIONS ...]]
                    [--loop-size LOOP_SIZE]

```

This command does exactly the same as the first example provided. The only
difference is the output format of the microbenchmark generated, which in
this case is regular C code with inline assembly statements.

We let you check the differences between both python scripts to figure
which changes are needed to control the output format of the generated
test cases (hint: just 2 lines!).

## Branch pattern testcases

```bash
usage: riscv_branch.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA]
                       [--uarch UARCH] [--env ENV] [--loop-size LOOP_SIZE]
                       [--local-branch-pattern LOCAL_BRANCH_PATTERN]
                       [--global-branch-pattern GLOBAL_BRANCH_PATTERN]
                       [--switch-pattern]
```

This command provides an example on how to generate different branch
patterns by controlling the global branch patterns (across branches at
different addresses) and local branch patterns (for branch at a
particular pattern). Although there is not a particular code generation
pass that generates the requested patterns, the example shows that
with a combination of passes, one can quickly control programatically
the branch patterns. Check out the commented source code to learn
all the steps required to control the branch behavior.

## Other RISCV examples

Besides the python codes examples provided here, **Microprobe** also
includes a set of generic command line tools which are useful to
automate the task of generating common test cases. They are listed
below. Check their documentation for further details.

- [`mp_epi`](https://ibm.github.io/microprobe/tools_mp_epi.html)
- [`mp_seq`](https://ibm.github.io/microprobe/tools_mp_seq.html)
- [`mp_seqtune`](https://ibm.github.io/microprobe/tools_mp_seqtune.html)

The following [`targets`](https://ibm.github.io/microprobe/tools_target_definition.html)
are enabled for the tools aforementioned:

- `riscv_v22-riscv_generic-riscv64_test_p`
- `riscv_v22-riscv_generic-riscv64_linux_gcc`
