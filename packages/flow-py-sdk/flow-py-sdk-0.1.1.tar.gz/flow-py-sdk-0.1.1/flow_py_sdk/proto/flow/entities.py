# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: flow/entities/account.proto, flow/entities/block_header.proto, flow/entities/collection.proto, flow/entities/block_seal.proto, flow/entities/block.proto, flow/entities/event.proto, flow/entities/transaction.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List

import betterproto


class TransactionStatus(betterproto.Enum):
    UNKNOWN = 0
    PENDING = 1
    FINALIZED = 2
    EXECUTED = 3
    SEALED = 4
    EXPIRED = 5


@dataclass
class Account(betterproto.Message):
    address: bytes = betterproto.bytes_field(1)
    balance: int = betterproto.uint64_field(2)
    code: bytes = betterproto.bytes_field(3)
    keys: List["AccountKey"] = betterproto.message_field(4)
    contracts: Dict[str, bytes] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_BYTES
    )


@dataclass
class AccountKey(betterproto.Message):
    index: int = betterproto.uint32_field(1)
    public_key: bytes = betterproto.bytes_field(2)
    sign_algo: int = betterproto.uint32_field(3)
    hash_algo: int = betterproto.uint32_field(4)
    weight: int = betterproto.uint32_field(5)
    sequence_number: int = betterproto.uint32_field(6)
    revoked: bool = betterproto.bool_field(7)


@dataclass
class BlockHeader(betterproto.Message):
    id: bytes = betterproto.bytes_field(1)
    parent_id: bytes = betterproto.bytes_field(2)
    height: int = betterproto.uint64_field(3)
    timestamp: datetime = betterproto.message_field(4)


@dataclass
class Collection(betterproto.Message):
    id: bytes = betterproto.bytes_field(1)
    transaction_ids: List[bytes] = betterproto.bytes_field(2)


@dataclass
class CollectionGuarantee(betterproto.Message):
    collection_id: bytes = betterproto.bytes_field(1)
    signatures: List[bytes] = betterproto.bytes_field(2)


@dataclass
class BlockSeal(betterproto.Message):
    block_id: bytes = betterproto.bytes_field(1)
    execution_receipt_id: bytes = betterproto.bytes_field(2)
    execution_receipt_signatures: List[bytes] = betterproto.bytes_field(3)
    result_approval_signatures: List[bytes] = betterproto.bytes_field(4)


@dataclass
class Block(betterproto.Message):
    id: bytes = betterproto.bytes_field(1)
    parent_id: bytes = betterproto.bytes_field(2)
    height: int = betterproto.uint64_field(3)
    timestamp: datetime = betterproto.message_field(4)
    collection_guarantees: List["CollectionGuarantee"] = betterproto.message_field(5)
    block_seals: List["BlockSeal"] = betterproto.message_field(6)
    signatures: List[bytes] = betterproto.bytes_field(7)


@dataclass
class Event(betterproto.Message):
    type: str = betterproto.string_field(1)
    transaction_id: bytes = betterproto.bytes_field(2)
    transaction_index: int = betterproto.uint32_field(3)
    event_index: int = betterproto.uint32_field(4)
    payload: bytes = betterproto.bytes_field(5)


@dataclass
class Transaction(betterproto.Message):
    script: bytes = betterproto.bytes_field(1)
    arguments: List[bytes] = betterproto.bytes_field(2)
    reference_block_id: bytes = betterproto.bytes_field(3)
    gas_limit: int = betterproto.uint64_field(4)
    proposal_key: "TransactionProposalKey" = betterproto.message_field(5)
    payer: bytes = betterproto.bytes_field(6)
    authorizers: List[bytes] = betterproto.bytes_field(7)
    payload_signatures: List["TransactionSignature"] = betterproto.message_field(8)
    envelope_signatures: List["TransactionSignature"] = betterproto.message_field(9)


@dataclass
class TransactionProposalKey(betterproto.Message):
    address: bytes = betterproto.bytes_field(1)
    key_id: int = betterproto.uint32_field(2)
    sequence_number: int = betterproto.uint64_field(3)


@dataclass
class TransactionSignature(betterproto.Message):
    address: bytes = betterproto.bytes_field(1)
    key_id: int = betterproto.uint32_field(2)
    signature: bytes = betterproto.bytes_field(3)
