"""hdev requirements implementation."""
import os
import re
from pathlib import Path

from hdev.lib import run_tox

MULTI_DEP = re.compile(r".* # via .*,.*$")
COMMENT = re.compile(r"^#")


DEFAULT_REQUIREMENTS_ORDER = [
    "requirements/requirements.in",
    "requirements/format.in",
    "requirements/dockercompose.in",
    "requirements/ssl.in",
    "requirements/build.in",
    "requirements/updatepdfjs.in",
    "requirements/dev.in",
    "requirements/tests.in",
    "requirements/functests.in",
    "requirements/bddtests.in",
    "requirements/lint.in",
]


class PythonRequirements:
    """hdev requirements command."""

    MULTI_DEP = re.compile(r".* # via .*,.*$")
    COMMENT = re.compile(r"^#")

    def __init__(self, config):
        self._config = config

        self.reformat = self._config.get("tool.hdev.requirements.reformat", True)
        self.in_files = self._config.get(
            "tool.hdev.requirements.order", DEFAULT_REQUIREMENTS_ORDER
        )

    @staticmethod
    def _reformat_requirements(requirements_contents: str) -> str:
        def _remove_trailing(string):
            return re.sub(r"[ ]+$", "", string, flags=re.MULTILINE)

        formatted_lines = []

        for line in requirements_contents.splitlines():
            # Comments in the original file
            if COMMENT.match(line):
                formatted_lines.append(line)
                continue

            if not MULTI_DEP.match(line):
                # Requirements with only one entry in "via" are kept in the same line:
                # package==XX # via other_package
                #   becomes
                # package==XX
                #   # via other_package
                formatted = line.replace("# via", "\n    # via")
                formatted_lines.append(_remove_trailing(formatted))
                continue

            # For multiple entries in `# via` gets it's own line
            # package==XX # via other_package, and_another
            #   becomes
            # package==XX
            #   # via
            #   #   other_package
            #   #   and_another
            formatted = line.replace("# via", "\n    # via \n    #  ")
            formatted = formatted.replace(", ", "\n    #   ")
            formatted_lines.append(_remove_trailing(formatted))

        return "\n".join(formatted_lines) + "\n"  # Include new line at EOF

    @classmethod
    def reformat_requirements_txt(cls, requirements_path):  # pragma: no cover
        """Reformat requirements.txt formatted by pip-tools.

        Formats files generated by pip-tools<5.0.5 to the format used by newer versions.

        This is required as dependabot uses the newer version
        but our local environments can't upgrade
        due to venv-update being tied to older version of pip.

        Every dependency update involves a full file
        rewrite which is impossible to review without this script.

        tox 4.0 could potentially deprecate the need for venv-update

        Details about the issue in tox:
            https://github.com/tox-dev/tox/issues/149

        and progress on the 4.0 release:
            https://tox.readthedocs.io/en/rewrite/changelog.html
        """
        with open(requirements_path, "r") as file:
            reformatted_requirements = cls._reformat_requirements(file.read())

        with open(requirements_path, "w") as file:
            file.write(reformatted_requirements)

    def run(self):
        """Entry point for the h-dev requirements command.

        Sync requirements.in files generating the corresponding .txt files
        """
        # Only try to process files that actually exists
        self.in_files = [p for p in self.in_files if Path(p).exists()]
        if not self.in_files:
            return "No requirements .in files found", 0

        txt_files = [in_file.replace(".in", ".txt") for in_file in self.in_files]

        # Get around the year zero problem of not being able to create requirements
        # files because there are no requirements files for the tox environments
        for txt_file in txt_files:
            Path(txt_file).touch()

        for in_file in self.in_files:
            in_filename = os.path.basename(in_file)
            filename, _ = os.path.splitext(in_filename)

            tox_env = filename
            if filename == "requirements":
                # Assume that requirements.txt is the base for the "dev" environment
                tox_env = "dev"

            run_tox(tox_env, f"pip-compile {in_file}")

        if self.reformat:
            for txt_file in txt_files:
                self.reformat_requirements_txt(txt_file)

        return None, 0
