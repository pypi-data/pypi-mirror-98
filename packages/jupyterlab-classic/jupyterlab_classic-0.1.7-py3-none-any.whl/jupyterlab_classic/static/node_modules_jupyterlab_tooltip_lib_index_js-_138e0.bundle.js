/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["node_modules_jupyterlab_tooltip_lib_index_js-_138e0"],{

/***/ "../node_modules/@jupyterlab/tooltip/lib/index.js":
/*!********************************************************!*\
  !*** ../node_modules/@jupyterlab/tooltip/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ITooltipManager\": () => /* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_0__.ITooltipManager,\n/* harmony export */   \"Tooltip\": () => /* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_1__.Tooltip\n/* harmony export */ });\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokens */ \"../node_modules/@jupyterlab/tooltip/lib/tokens.js\");\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./widget */ \"../node_modules/@jupyterlab/tooltip/lib/widget.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module tooltip\n */\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/tooltip/lib/tokens.js":
/*!*********************************************************!*\
  !*** ../node_modules/@jupyterlab/tooltip/lib/tokens.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ITooltipManager\": () => /* binding */ ITooltipManager\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n/* tslint:disable */\n/**\n * The tooltip manager token.\n */\nconst ITooltipManager = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/tooltip:ITooltipManager');\n//# sourceMappingURL=tokens.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/tokens.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/tooltip/lib/widget.js":
/*!*********************************************************!*\
  !*** ../node_modules/@jupyterlab/tooltip/lib/widget.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tooltip\": () => /* binding */ Tooltip\n/* harmony export */ });\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets?5ac6\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils?2f22\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/rendermime */ \"webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime\");\n/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n\n/**\n * The class name added to each tooltip.\n */\nconst TOOLTIP_CLASS = 'jp-Tooltip';\n/**\n * The class name added to the tooltip content.\n */\nconst CONTENT_CLASS = 'jp-Tooltip-content';\n/**\n * The class added to the body when a tooltip exists on the page.\n */\nconst BODY_CLASS = 'jp-mod-tooltip';\n/**\n * The minimum height of a tooltip widget.\n */\nconst MIN_HEIGHT = 20;\n/**\n * The maximum height of a tooltip widget.\n */\nconst MAX_HEIGHT = 250;\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * A tooltip widget.\n */\nclass Tooltip extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {\n    /**\n     * Instantiate a tooltip.\n     */\n    constructor(options) {\n        super();\n        this._content = null;\n        const layout = (this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.PanelLayout());\n        const model = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_2__.MimeModel({ data: options.bundle });\n        this.anchor = options.anchor;\n        this.addClass(TOOLTIP_CLASS);\n        this.hide();\n        this._editor = options.editor;\n        this._rendermime = options.rendermime;\n        const mimeType = this._rendermime.preferredMimeType(options.bundle, 'any');\n        if (!mimeType) {\n            return;\n        }\n        this._content = this._rendermime.createRenderer(mimeType);\n        void this._content.renderModel(model);\n        this._content.addClass(CONTENT_CLASS);\n        layout.addWidget(this._content);\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this._content) {\n            this._content.dispose();\n            this._content = null;\n        }\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || this.isDisposed) {\n            return;\n        }\n        const { node } = this;\n        const target = event.target;\n        switch (event.type) {\n            case 'keydown':\n                if (node.contains(target)) {\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'mousedown':\n                if (node.contains(target)) {\n                    this.activate();\n                    return;\n                }\n                this.dispose();\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this.node.tabIndex = -1;\n        this.node.focus();\n    }\n    /**\n     * Handle `'after-attach'` messages.\n     */\n    onAfterAttach(msg) {\n        document.body.classList.add(BODY_CLASS);\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.addEventListener('scroll', this, USE_CAPTURE);\n        this.update();\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.body.classList.remove(BODY_CLASS);\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('mousedown', this, USE_CAPTURE);\n        this.anchor.node.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `'update-request'` messages.\n     */\n    onUpdateRequest(msg) {\n        if (this.isHidden) {\n            this.show();\n        }\n        this._setGeometry();\n        super.onUpdateRequest(msg);\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (this.node.contains(event.target)) {\n            return;\n        }\n        this.update();\n    }\n    /**\n     * Set the geometry of the tooltip widget.\n     */\n    _setGeometry() {\n        // Find the start of the current token for hover box placement.\n        const editor = this._editor;\n        const cursor = editor.getCursorPosition();\n        const end = editor.getOffsetAt(cursor);\n        const line = editor.getLine(cursor.line);\n        if (!line) {\n            return;\n        }\n        const tokens = line.substring(0, end).split(/\\W+/);\n        const last = tokens[tokens.length - 1];\n        const start = last ? end - last.length : end;\n        const position = editor.getPositionAt(start);\n        if (!position) {\n            return;\n        }\n        const anchor = editor.getCoordinateForPosition(position);\n        const style = window.getComputedStyle(this.node);\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // Calculate the geometry of the tooltip.\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.HoverBox.setGeometry({\n            anchor,\n            host: editor.host,\n            maxHeight: MAX_HEIGHT,\n            minHeight: MIN_HEIGHT,\n            node: this.node,\n            offset: { horizontal: -1 * paddingLeft },\n            privilege: 'below',\n            style: style\n        });\n    }\n}\n//# sourceMappingURL=widget.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/tooltip/lib/widget.js?");

/***/ })

}]);