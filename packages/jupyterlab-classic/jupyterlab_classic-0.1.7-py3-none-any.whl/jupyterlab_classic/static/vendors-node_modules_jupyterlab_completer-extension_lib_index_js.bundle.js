/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_completer-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/completer-extension/lib/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@jupyterlab/completer-extension/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/completer */ \"webpack/sharing/consume/default/@jupyterlab/completer/@jupyterlab/completer\");\n/* harmony import */ var _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/console */ \"webpack/sharing/consume/default/@jupyterlab/console/@jupyterlab/console\");\n/* harmony import */ var _jupyterlab_console__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_console__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/fileeditor */ \"webpack/sharing/consume/default/@jupyterlab/fileeditor/@jupyterlab/fileeditor\");\n/* harmony import */ var _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/notebook */ \"webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook?955e\");\n/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets?5ac6\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module completer-extension\n */\n\n\n\n\n\n\n/**\n * The command IDs used by the completer plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.invoke = 'completer:invoke';\n    CommandIDs.invokeConsole = 'completer:invoke-console';\n    CommandIDs.invokeNotebook = 'completer:invoke-notebook';\n    CommandIDs.invokeFile = 'completer:invoke-file';\n    CommandIDs.select = 'completer:select';\n    CommandIDs.selectConsole = 'completer:select-console';\n    CommandIDs.selectNotebook = 'completer:select-notebook';\n    CommandIDs.selectFile = 'completer:select-file';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A plugin providing code completion for editors.\n */\nconst manager = {\n    id: '@jupyterlab/completer-extension:manager',\n    autoStart: true,\n    provides: _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.ICompletionManager,\n    activate: (app) => {\n        const handlers = {};\n        app.commands.addCommand(CommandIDs.invoke, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.invoke();\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.select, {\n            execute: args => {\n                const id = args && args['id'];\n                if (!id) {\n                    return;\n                }\n                const handler = handlers[id];\n                if (handler) {\n                    handler.completer.selectActive();\n                }\n            }\n        });\n        return {\n            register: (completable, renderer = _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.Completer.defaultRenderer) => {\n                const { connector, editor, parent } = completable;\n                const model = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompleterModel();\n                const completer = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.Completer({ editor, model, renderer });\n                const handler = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionHandler({\n                    completer,\n                    connector\n                });\n                const id = parent.id;\n                // Hide the widget when it first loads.\n                completer.hide();\n                // Associate the handler with the parent widget.\n                handlers[id] = handler;\n                // Set the handler's editor.\n                handler.editor = editor;\n                // Attach the completer widget.\n                _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget.attach(completer, document.body);\n                // Listen for parent disposal.\n                parent.disposed.connect(() => {\n                    delete handlers[id];\n                    model.dispose();\n                    completer.dispose();\n                    handler.dispose();\n                });\n                return handler;\n            }\n        };\n    }\n};\n/**\n * An extension that registers consoles for code completion.\n */\nconst consoles = {\n    id: '@jupyterlab/completer-extension:consoles',\n    requires: [_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.ICompletionManager, _jupyterlab_console__WEBPACK_IMPORTED_MODULE_1__.IConsoleTracker],\n    autoStart: true,\n    activate: (app, manager, consoles) => {\n        // Create a handler for each console that is created.\n        consoles.widgetAdded.connect((sender, widget) => {\n            var _a, _b;\n            const anchor = widget.console;\n            const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = anchor.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: widget });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = anchor.promptCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = anchor.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            anchor.promptCellCreated.connect(updateConnector);\n            anchor.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectConsole, {\n            execute: () => {\n                const id = consoles.currentWidget && consoles.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectConsole,\n            keys: ['Enter'],\n            selector: `.jp-ConsolePanel .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers notebooks for code completion.\n */\nconst notebooks = {\n    id: '@jupyterlab/completer-extension:notebooks',\n    requires: [_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.ICompletionManager, _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_3__.INotebookTracker],\n    autoStart: true,\n    activate: (app, manager, notebooks) => {\n        // Create a handler for each notebook that is created.\n        notebooks.widgetAdded.connect((sender, panel) => {\n            var _a, _b;\n            const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = panel.sessionContext.session;\n            // TODO: CompletionConnector assumes editor and session are not null\n            const connector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionConnector({ session, editor });\n            const handler = manager.register({ connector, editor, parent: panel });\n            const updateConnector = () => {\n                var _a, _b;\n                const editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = panel.sessionContext.session;\n                handler.editor = editor;\n                // TODO: CompletionConnector assumes editor and session are not null\n                handler.connector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionConnector({ session, editor });\n            };\n            // Update the handler whenever the prompt or session changes\n            panel.content.activeCellChanged.connect(updateConnector);\n            panel.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add notebook completer command.\n        app.commands.addCommand(CommandIDs.invokeNotebook, {\n            execute: () => {\n                var _a;\n                const panel = notebooks.currentWidget;\n                if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                    return app.commands.execute(CommandIDs.invoke, { id: panel.id });\n                }\n            }\n        });\n        // Add notebook completer select command.\n        app.commands.addCommand(CommandIDs.selectNotebook, {\n            execute: () => {\n                const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for notebook completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectNotebook,\n            keys: ['Enter'],\n            selector: `.jp-Notebook .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * An extension that registers file editors for completion.\n */\nconst files = {\n    id: '@jupyterlab/completer-extension:files',\n    requires: [_jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.ICompletionManager, _jupyterlab_fileeditor__WEBPACK_IMPORTED_MODULE_2__.IEditorTracker],\n    autoStart: true,\n    activate: (app, manager, editorTracker) => {\n        // Keep a list of active ISessions so that we can\n        // clean them up when they are no longer needed.\n        const activeSessions = {};\n        // When a new file editor is created, make the completer for it.\n        editorTracker.widgetAdded.connect((sender, widget) => {\n            const sessions = app.serviceManager.sessions;\n            const editor = widget.content.editor;\n            const contextConnector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.ContextConnector({ editor });\n            // Initially create the handler with the contextConnector.\n            // If a kernel session is found matching this file editor,\n            // it will be replaced in onRunningChanged().\n            const handler = manager.register({\n                connector: contextConnector,\n                editor,\n                parent: widget\n            });\n            // When the list of running sessions changes,\n            // check to see if there are any kernels with a\n            // matching path for this file editor.\n            const onRunningChanged = (sender, models) => {\n                const oldSession = activeSessions[widget.id];\n                // Search for a matching path.\n                const model = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.find)(models, m => m.path === widget.context.path);\n                if (model) {\n                    // If there is a matching path, but it is the same\n                    // session as we previously had, do nothing.\n                    if (oldSession && oldSession.id === model.id) {\n                        return;\n                    }\n                    // Otherwise, dispose of the old session and reset to\n                    // a new CompletionConnector.\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                    const session = sessions.connectTo({ model });\n                    handler.connector = new _jupyterlab_completer__WEBPACK_IMPORTED_MODULE_0__.CompletionConnector({ session, editor });\n                    activeSessions[widget.id] = session;\n                }\n                else {\n                    // If we didn't find a match, make sure\n                    // the connector is the contextConnector and\n                    // dispose of any previous connection.\n                    handler.connector = contextConnector;\n                    if (oldSession) {\n                        delete activeSessions[widget.id];\n                        oldSession.dispose();\n                    }\n                }\n            };\n            onRunningChanged(sessions, (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_4__.toArray)(sessions.running()));\n            sessions.runningChanged.connect(onRunningChanged);\n            // When the widget is disposed, do some cleanup.\n            widget.disposed.connect(() => {\n                sessions.runningChanged.disconnect(onRunningChanged);\n                const session = activeSessions[widget.id];\n                if (session) {\n                    delete activeSessions[widget.id];\n                    session.dispose();\n                }\n            });\n        });\n        // Add console completer invoke command.\n        app.commands.addCommand(CommandIDs.invokeFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.invoke, { id });\n                }\n            }\n        });\n        // Add console completer select command.\n        app.commands.addCommand(CommandIDs.selectFile, {\n            execute: () => {\n                const id = editorTracker.currentWidget && editorTracker.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            }\n        });\n        // Set enter key for console completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectFile,\n            keys: ['Enter'],\n            selector: `.jp-FileEditor .jp-mod-completer-active`\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    consoles,\n    notebooks,\n    files\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer-extension/lib/index.js?");

/***/ })

}]);