/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_mainmenu-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/mainmenu-extension/lib/index.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@jupyterlab/mainmenu-extension/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CommandIDs\": () => /* binding */ CommandIDs,\n/* harmony export */   \"createEditMenu\": () => /* binding */ createEditMenu,\n/* harmony export */   \"createFileMenu\": () => /* binding */ createFileMenu,\n/* harmony export */   \"createKernelMenu\": () => /* binding */ createKernelMenu,\n/* harmony export */   \"createViewMenu\": () => /* binding */ createViewMenu,\n/* harmony export */   \"createRunMenu\": () => /* binding */ createRunMenu,\n/* harmony export */   \"createSettingsMenu\": () => /* binding */ createSettingsMenu,\n/* harmony export */   \"createTabsMenu\": () => /* binding */ createTabsMenu,\n/* harmony export */   \"createHelpMenu\": () => /* binding */ createHelpMenu,\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets?5ac6\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application?6b93\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils?2f22\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils?f105\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/mainmenu */ \"webpack/sharing/consume/default/@jupyterlab/mainmenu/@jupyterlab/mainmenu?3845\");\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/services */ \"webpack/sharing/consume/default/@jupyterlab/services/@jupyterlab/services\");\n/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation?5414\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module mainmenu-extension\n */\n\n\n\n\n\n\n\n\n/**\n * A namespace for command IDs of semantic extension points.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.openEdit = 'editmenu:open';\n    CommandIDs.undo = 'editmenu:undo';\n    CommandIDs.redo = 'editmenu:redo';\n    CommandIDs.clearCurrent = 'editmenu:clear-current';\n    CommandIDs.clearAll = 'editmenu:clear-all';\n    CommandIDs.find = 'editmenu:find';\n    CommandIDs.goToLine = 'editmenu:go-to-line';\n    CommandIDs.openFile = 'filemenu:open';\n    CommandIDs.closeAndCleanup = 'filemenu:close-and-cleanup';\n    CommandIDs.createConsole = 'filemenu:create-console';\n    CommandIDs.shutdown = 'filemenu:shutdown';\n    CommandIDs.logout = 'filemenu:logout';\n    CommandIDs.openKernel = 'kernelmenu:open';\n    CommandIDs.interruptKernel = 'kernelmenu:interrupt';\n    CommandIDs.reconnectToKernel = 'kernelmenu:reconnect-to-kernel';\n    CommandIDs.restartKernel = 'kernelmenu:restart';\n    CommandIDs.restartKernelAndClear = 'kernelmenu:restart-and-clear';\n    CommandIDs.restartAndRunToSelected = 'notebook:restart-and-run-to-selected';\n    CommandIDs.changeKernel = 'kernelmenu:change';\n    CommandIDs.shutdownKernel = 'kernelmenu:shutdown';\n    CommandIDs.shutdownAllKernels = 'kernelmenu:shutdownAll';\n    CommandIDs.openView = 'viewmenu:open';\n    CommandIDs.wordWrap = 'viewmenu:word-wrap';\n    CommandIDs.lineNumbering = 'viewmenu:line-numbering';\n    CommandIDs.matchBrackets = 'viewmenu:match-brackets';\n    CommandIDs.openRun = 'runmenu:open';\n    CommandIDs.run = 'runmenu:run';\n    CommandIDs.runAll = 'runmenu:run-all';\n    CommandIDs.restartAndRunAll = 'runmenu:restart-and-run-all';\n    CommandIDs.runAbove = 'runmenu:run-above';\n    CommandIDs.runBelow = 'runmenu:run-below';\n    CommandIDs.openTabs = 'tabsmenu:open';\n    CommandIDs.activateById = 'tabsmenu:activate-by-id';\n    CommandIDs.activatePreviouslyUsedTab = 'tabsmenu:activate-previously-used-tab';\n    CommandIDs.openSettings = 'settingsmenu:open';\n    CommandIDs.openHelp = 'helpmenu:open';\n    CommandIDs.openFirst = 'mainmenu:open-first';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing an interface to the main menu.\n */\nconst plugin = {\n    id: '@jupyterlab/mainmenu-extension:plugin',\n    requires: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_2__.IRouter, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.ITranslator],\n    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.ICommandPalette, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_2__.ILabShell],\n    provides: _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_5__.IMainMenu,\n    activate: (app, router, translator, palette, labShell) => {\n        const { commands } = app;\n        const trans = translator.load('jupyterlab');\n        const menu = new _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_5__.MainMenu(commands);\n        menu.id = 'jp-MainMenu';\n        menu.addClass('jp-scrollbar-tiny');\n        // Only add quit button if the back-end supports it by checking page config.\n        const quitButton = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.PageConfig.getOption('quitButton').toLowerCase();\n        menu.fileMenu.quitEntry = quitButton === 'true';\n        // Create the application menus.\n        createEditMenu(app, menu.editMenu, trans);\n        createFileMenu(app, menu.fileMenu, router, trans);\n        createKernelMenu(app, menu.kernelMenu, trans);\n        createRunMenu(app, menu.runMenu, trans);\n        createSettingsMenu(app, menu.settingsMenu, trans);\n        createViewMenu(app, menu.viewMenu, trans);\n        createHelpMenu(app, menu.helpMenu, trans);\n        // Set the Tabs Title so it's visible also in other shells\n        const tabsMenu = menu.tabsMenu;\n        tabsMenu.menu.title.label = trans.__('Tabs');\n        // The tabs menu relies on lab shell functionality.\n        if (labShell) {\n            createTabsMenu(app, tabsMenu, labShell, trans);\n        }\n        // Create commands to open the main application menus.\n        const activateMenu = (item) => {\n            menu.activeMenu = item;\n            menu.openActiveMenu();\n        };\n        commands.addCommand(CommandIDs.openEdit, {\n            label: trans.__('Open Edit Menu'),\n            execute: () => activateMenu(menu.editMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openFile, {\n            label: trans.__('Open File Menu'),\n            execute: () => activateMenu(menu.fileMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openKernel, {\n            label: trans.__('Open Kernel Menu'),\n            execute: () => activateMenu(menu.kernelMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openRun, {\n            label: trans.__('Open Run Menu'),\n            execute: () => activateMenu(menu.runMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openView, {\n            label: trans.__('Open View Menu'),\n            execute: () => activateMenu(menu.viewMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openSettings, {\n            label: trans.__('Open Settings Menu'),\n            execute: () => activateMenu(menu.settingsMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openTabs, {\n            label: trans.__('Open Tabs Menu'),\n            execute: () => activateMenu(menu.tabsMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openHelp, {\n            label: trans.__('Open Help Menu'),\n            execute: () => activateMenu(menu.helpMenu.menu)\n        });\n        commands.addCommand(CommandIDs.openFirst, {\n            label: trans.__('Open First Menu'),\n            execute: () => {\n                menu.activeIndex = 0;\n                menu.openActiveMenu();\n            }\n        });\n        if (palette) {\n            // Add some of the commands defined here to the command palette.\n            if (menu.fileMenu.quitEntry) {\n                palette.addItem({\n                    command: CommandIDs.shutdown,\n                    category: trans.__('Main Area')\n                });\n                palette.addItem({\n                    command: CommandIDs.logout,\n                    category: trans.__('Main Area')\n                });\n            }\n            palette.addItem({\n                command: CommandIDs.shutdownAllKernels,\n                category: trans.__('Kernel Operations')\n            });\n            palette.addItem({\n                command: CommandIDs.activatePreviouslyUsedTab,\n                category: trans.__('Main Area')\n            });\n        }\n        app.shell.add(menu, 'menu', { rank: 100 });\n        return menu;\n    }\n};\n/**\n * Create the basic `Edit` menu.\n */\nfunction createEditMenu(app, menu, trans) {\n    const commands = menu.menu.commands;\n    menu.menu.title.label = trans.__('Edit');\n    // Add the undo/redo commands the the Edit menu.\n    commands.addCommand(CommandIDs.undo, {\n        label: trans.__('Undo'),\n        isEnabled: Private.delegateEnabled(app, menu.undoers, 'undo'),\n        execute: Private.delegateExecute(app, menu.undoers, 'undo')\n    });\n    commands.addCommand(CommandIDs.redo, {\n        label: trans.__('Redo'),\n        isEnabled: Private.delegateEnabled(app, menu.undoers, 'redo'),\n        execute: Private.delegateExecute(app, menu.undoers, 'redo')\n    });\n    menu.addGroup([{ command: CommandIDs.undo }, { command: CommandIDs.redo }], 0);\n    // Add the clear commands to the Edit menu.\n    commands.addCommand(CommandIDs.clearCurrent, {\n        label: () => {\n            const enabled = Private.delegateEnabled(app, menu.clearers, 'clearCurrent')();\n            let localizedLabel = trans.__('Clear');\n            if (enabled) {\n                localizedLabel = Private.delegateLabel(app, menu.clearers, 'clearCurrentLabel');\n            }\n            return localizedLabel;\n        },\n        isEnabled: Private.delegateEnabled(app, menu.clearers, 'clearCurrent'),\n        execute: Private.delegateExecute(app, menu.clearers, 'clearCurrent')\n    });\n    commands.addCommand(CommandIDs.clearAll, {\n        label: () => {\n            const enabled = Private.delegateEnabled(app, menu.clearers, 'clearAll')();\n            let localizedLabel = trans.__('Clear All');\n            if (enabled) {\n                localizedLabel = Private.delegateLabel(app, menu.clearers, 'clearAllLabel');\n            }\n            return localizedLabel;\n        },\n        isEnabled: Private.delegateEnabled(app, menu.clearers, 'clearAll'),\n        execute: Private.delegateExecute(app, menu.clearers, 'clearAll')\n    });\n    menu.addGroup([{ command: CommandIDs.clearCurrent }, { command: CommandIDs.clearAll }], 10);\n    commands.addCommand(CommandIDs.goToLine, {\n        label: trans.__('Go to Line…'),\n        isEnabled: Private.delegateEnabled(app, menu.goToLiners, 'goToLine'),\n        execute: Private.delegateExecute(app, menu.goToLiners, 'goToLine')\n    });\n    menu.addGroup([{ command: CommandIDs.goToLine }], 200);\n}\n/**\n * Create the basic `File` menu.\n */\nfunction createFileMenu(app, menu, router, trans) {\n    const commands = menu.menu.commands;\n    menu.menu.title.label = trans.__('File');\n    menu.newMenu.menu.title.label = trans.__('New');\n    // Add a delegator command for closing and cleaning up an activity.\n    // This one is a bit different, in that we consider it enabled\n    // even if it cannot find a delegate for the activity.\n    // In that case, we instead call the application `close` command.\n    commands.addCommand(CommandIDs.closeAndCleanup, {\n        label: () => {\n            const localizedLabel = Private.delegateLabel(app, menu.closeAndCleaners, 'closeAndCleanupLabel');\n            return localizedLabel ? localizedLabel : trans.__('Close and Shutdown');\n        },\n        isEnabled: () => !!app.shell.currentWidget && !!app.shell.currentWidget.title.closable,\n        execute: () => {\n            // Check if we have a registered delegate. If so, call that.\n            if (Private.delegateEnabled(app, menu.closeAndCleaners, 'closeAndCleanup')()) {\n                return Private.delegateExecute(app, menu.closeAndCleaners, 'closeAndCleanup')();\n            }\n            // If we have no delegate, call the top-level application close.\n            return app.commands.execute('application:close');\n        }\n    });\n    // Add a delegator command for creating a console for an activity.\n    commands.addCommand(CommandIDs.createConsole, {\n        label: () => {\n            const localizedLabel = Private.delegateLabel(app, menu.consoleCreators, 'createConsoleLabel');\n            return localizedLabel\n                ? localizedLabel\n                : trans.__('New Console for Activity');\n        },\n        isEnabled: Private.delegateEnabled(app, menu.consoleCreators, 'createConsole'),\n        execute: Private.delegateExecute(app, menu.consoleCreators, 'createConsole')\n    });\n    commands.addCommand(CommandIDs.shutdown, {\n        label: trans.__('Shut Down'),\n        caption: trans.__('Shut down JupyterLab'),\n        execute: () => {\n            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.showDialog)({\n                title: trans.__('Shutdown confirmation'),\n                body: trans.__('Please confirm you want to shut down JupyterLab.'),\n                buttons: [\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.Dialog.cancelButton(),\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.Dialog.warnButton({ label: trans.__('Shut Down') })\n                ]\n            }).then(result => {\n                if (result.button.accept) {\n                    const setting = _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__.ServerConnection.makeSettings();\n                    const apiURL = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_4__.URLExt.join(setting.baseUrl, 'api/shutdown');\n                    return _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__.ServerConnection.makeRequest(apiURL, { method: 'POST' }, setting)\n                        .then(result => {\n                        if (result.ok) {\n                            // Close this window if the shutdown request has been successful\n                            const body = document.createElement('div');\n                            const p1 = document.createElement('p');\n                            p1.textContent = trans.__('You have shut down the Jupyter server. You can now close this tab.');\n                            const p2 = document.createElement('p');\n                            p2.textContent = trans.__('To use JupyterLab again, you will need to relaunch it.');\n                            body.appendChild(p1);\n                            body.appendChild(p2);\n                            void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.showDialog)({\n                                title: trans.__('Server stopped'),\n                                body: new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget({ node: body }),\n                                buttons: []\n                            });\n                            window.close();\n                        }\n                        else {\n                            throw new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__.ServerConnection.ResponseError(result);\n                        }\n                    })\n                        .catch(data => {\n                        throw new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_6__.ServerConnection.NetworkError(data);\n                    });\n                }\n            });\n        }\n    });\n    commands.addCommand(CommandIDs.logout, {\n        label: trans.__('Log Out'),\n        caption: trans.__('Log out of JupyterLab'),\n        execute: () => {\n            router.navigate('/logout', { hard: true });\n        }\n    });\n    // Add the new group\n    const newGroup = [\n        { type: 'submenu', submenu: menu.newMenu.menu },\n        { command: 'filebrowser:create-main-launcher' }\n    ];\n    const openGroup = [{ command: 'filebrowser:open-path' }];\n    const newViewGroup = [\n        { command: 'docmanager:clone' },\n        { command: CommandIDs.createConsole }\n    ].filter(item => !!item);\n    // Add the close group\n    const closeGroup = [\n        'application:close',\n        'filemenu:close-and-cleanup',\n        'application:close-all'\n    ].map(command => {\n        return { command };\n    });\n    // Add save group.\n    const saveGroup = [\n        'docmanager:save',\n        'docmanager:save-as',\n        'docmanager:save-all'\n    ].map(command => {\n        return { command };\n    });\n    // Add the re group.\n    const reGroup = [\n        'docmanager:reload',\n        'docmanager:restore-checkpoint',\n        'docmanager:rename'\n    ].map(command => {\n        return { command };\n    });\n    // Add the quit group.\n    const quitGroup = [\n        { command: 'filemenu:logout' },\n        { command: 'filemenu:shutdown' }\n    ];\n    const printGroup = [{ command: 'apputils:print' }];\n    menu.addGroup(newGroup, 0);\n    menu.addGroup(openGroup, 1);\n    menu.addGroup(newViewGroup, 2);\n    menu.addGroup(closeGroup, 3);\n    menu.addGroup(saveGroup, 4);\n    menu.addGroup(reGroup, 5);\n    menu.addGroup(printGroup, 98);\n    if (menu.quitEntry) {\n        menu.addGroup(quitGroup, 99);\n    }\n}\n/**\n * Create the basic `Kernel` menu.\n */\nfunction createKernelMenu(app, menu, trans) {\n    const commands = menu.menu.commands;\n    menu.menu.title.label = trans.__('Kernel');\n    commands.addCommand(CommandIDs.interruptKernel, {\n        label: trans.__('Interrupt Kernel'),\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'interruptKernel'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'interruptKernel')\n    });\n    commands.addCommand(CommandIDs.reconnectToKernel, {\n        label: trans.__('Reconnect to Kernel'),\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'reconnectToKernel'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'reconnectToKernel')\n    });\n    commands.addCommand(CommandIDs.restartKernel, {\n        label: trans.__('Restart Kernel…'),\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'restartKernel'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'restartKernel')\n    });\n    commands.addCommand(CommandIDs.restartKernelAndClear, {\n        label: () => {\n            const enabled = Private.delegateEnabled(app, menu.kernelUsers, 'restartKernelAndClear')();\n            let localizedLabel = trans.__('Restart Kernel and Clear…');\n            if (enabled) {\n                localizedLabel = Private.delegateLabel(app, menu.kernelUsers, 'restartKernelAndClearLabel');\n            }\n            return localizedLabel;\n        },\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'restartKernelAndClear'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'restartKernelAndClear')\n    });\n    commands.addCommand(CommandIDs.changeKernel, {\n        label: trans.__('Change Kernel…'),\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'changeKernel'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'changeKernel')\n    });\n    commands.addCommand(CommandIDs.shutdownKernel, {\n        label: trans.__('Shut Down Kernel'),\n        isEnabled: Private.delegateEnabled(app, menu.kernelUsers, 'shutdownKernel'),\n        execute: Private.delegateExecute(app, menu.kernelUsers, 'shutdownKernel')\n    });\n    commands.addCommand(CommandIDs.shutdownAllKernels, {\n        label: trans.__('Shut Down All Kernels…'),\n        isEnabled: () => {\n            return app.serviceManager.sessions.running().next() !== undefined;\n        },\n        execute: () => {\n            return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.showDialog)({\n                title: trans.__('Shut Down All?'),\n                body: trans.__('Shut down all kernels?'),\n                buttons: [\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.Dialog.cancelButton({ label: trans.__('Dismiss') }),\n                    _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_3__.Dialog.warnButton({ label: trans.__('Shut Down All') })\n                ]\n            }).then(result => {\n                if (result.button.accept) {\n                    return app.serviceManager.sessions.shutdownAll();\n                }\n            });\n        }\n    });\n    const restartGroup = [\n        CommandIDs.restartKernel,\n        CommandIDs.restartKernelAndClear,\n        CommandIDs.restartAndRunToSelected,\n        CommandIDs.restartAndRunAll\n    ].map(command => {\n        return { command };\n    });\n    menu.addGroup([{ command: CommandIDs.interruptKernel }], 0);\n    menu.addGroup(restartGroup, 1);\n    menu.addGroup([{ command: CommandIDs.reconnectToKernel }], 1.5);\n    menu.addGroup([\n        { command: CommandIDs.shutdownKernel },\n        { command: CommandIDs.shutdownAllKernels }\n    ], 2);\n    menu.addGroup([{ command: CommandIDs.changeKernel }], 3);\n}\n/**\n * Create the basic `View` menu.\n */\nfunction createViewMenu(app, menu, trans) {\n    const commands = menu.menu.commands;\n    menu.menu.title.label = trans.__('View');\n    commands.addCommand(CommandIDs.lineNumbering, {\n        label: trans.__('Show Line Numbers'),\n        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleLineNumbers'),\n        isToggled: Private.delegateToggled(app, menu.editorViewers, 'lineNumbersToggled'),\n        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleLineNumbers')\n    });\n    commands.addCommand(CommandIDs.matchBrackets, {\n        label: trans.__('Match Brackets'),\n        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleMatchBrackets'),\n        isToggled: Private.delegateToggled(app, menu.editorViewers, 'matchBracketsToggled'),\n        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleMatchBrackets')\n    });\n    commands.addCommand(CommandIDs.wordWrap, {\n        label: trans.__('Wrap Words'),\n        isEnabled: Private.delegateEnabled(app, menu.editorViewers, 'toggleWordWrap'),\n        isToggled: Private.delegateToggled(app, menu.editorViewers, 'wordWrapToggled'),\n        execute: Private.delegateExecute(app, menu.editorViewers, 'toggleWordWrap')\n    });\n    menu.addGroup([{ command: 'apputils:activate-command-palette' }], 0);\n    menu.addGroup([\n        { command: 'application:toggle-mode' },\n        { command: 'application:toggle-presentation-mode' }\n    ], 1);\n    menu.addGroup([\n        { command: 'application:toggle-left-area' },\n        { command: 'application:toggle-right-area' }\n    ], 2);\n    const editorViewerGroup = [\n        CommandIDs.lineNumbering,\n        CommandIDs.matchBrackets,\n        CommandIDs.wordWrap\n    ].map(command => {\n        return { command };\n    });\n    menu.addGroup(editorViewerGroup, 10);\n}\n/**\n * Create the basic `Run` menu.\n */\nfunction createRunMenu(app, menu, trans) {\n    const commands = menu.menu.commands;\n    menu.menu.title.label = trans.__('Run');\n    commands.addCommand(CommandIDs.run, {\n        label: () => {\n            const localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'runLabel');\n            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'run')();\n            return enabled ? localizedLabel : trans.__('Run Selected');\n        },\n        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'run'),\n        execute: Private.delegateExecute(app, menu.codeRunners, 'run')\n    });\n    commands.addCommand(CommandIDs.runAll, {\n        label: () => {\n            let localizedLabel = trans.__('Run All');\n            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'runAll')();\n            if (enabled) {\n                localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'runAllLabel');\n            }\n            return localizedLabel;\n        },\n        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'runAll'),\n        execute: Private.delegateExecute(app, menu.codeRunners, 'runAll')\n    });\n    commands.addCommand(CommandIDs.restartAndRunAll, {\n        label: () => {\n            let localizedLabel = trans.__('Restart Kernel and Run All');\n            const enabled = Private.delegateEnabled(app, menu.codeRunners, 'restartAndRunAll')();\n            if (enabled) {\n                localizedLabel = Private.delegateLabel(app, menu.codeRunners, 'restartAndRunAllLabel');\n            }\n            return localizedLabel;\n        },\n        isEnabled: Private.delegateEnabled(app, menu.codeRunners, 'restartAndRunAll'),\n        execute: Private.delegateExecute(app, menu.codeRunners, 'restartAndRunAll')\n    });\n    const runAllGroup = [CommandIDs.runAll, CommandIDs.restartAndRunAll].map(command => {\n        return { command };\n    });\n    menu.addGroup([{ command: CommandIDs.run }], 0);\n    menu.addGroup(runAllGroup, 999);\n}\n/**\n * Create the basic `Settings` menu.\n */\nfunction createSettingsMenu(_, menu, trans) {\n    menu.menu.title.label = trans.__('Settings');\n    menu.addGroup([{ command: 'settingeditor:open' }], 1000);\n}\n/**\n * Create the basic `Tabs` menu.\n */\nfunction createTabsMenu(app, menu, labShell, trans) {\n    const commands = app.commands;\n    // Add commands for cycling the active tabs.\n    menu.addGroup([\n        { command: 'application:activate-next-tab' },\n        { command: 'application:activate-previous-tab' },\n        { command: 'application:activate-next-tab-bar' },\n        { command: 'application:activate-previous-tab-bar' },\n        { command: CommandIDs.activatePreviouslyUsedTab }\n    ], 0);\n    // A list of the active tabs in the main area.\n    const tabGroup = [];\n    // A disposable for getting rid of the out-of-date tabs list.\n    let disposable;\n    // Command to activate a widget by id.\n    commands.addCommand(CommandIDs.activateById, {\n        label: args => {\n            const id = args['id'] || '';\n            const widget = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(app.shell.widgets('main'), w => w.id === id);\n            return (widget && widget.title.label) || '';\n        },\n        isToggled: args => {\n            const id = args['id'] || '';\n            return !!app.shell.currentWidget && app.shell.currentWidget.id === id;\n        },\n        execute: args => app.shell.activateById(args['id'] || '')\n    });\n    let previousId = '';\n    // Command to toggle between the current\n    // tab and the last modified tab.\n    commands.addCommand(CommandIDs.activatePreviouslyUsedTab, {\n        label: trans.__('Activate Previously Used Tab'),\n        isEnabled: () => !!previousId,\n        execute: () => commands.execute(CommandIDs.activateById, { id: previousId })\n    });\n    if (labShell) {\n        void app.restored.then(() => {\n            // Iterate over the current widgets in the\n            // main area, and add them to the tab group\n            // of the menu.\n            const populateTabs = () => {\n                // remove the previous tab list\n                if (disposable && !disposable.isDisposed) {\n                    disposable.dispose();\n                }\n                tabGroup.length = 0;\n                let isPreviouslyUsedTabAttached = false;\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(app.shell.widgets('main'), widget => {\n                    if (widget.id === previousId) {\n                        isPreviouslyUsedTabAttached = true;\n                    }\n                    tabGroup.push({\n                        command: CommandIDs.activateById,\n                        args: { id: widget.id }\n                    });\n                });\n                disposable = menu.addGroup(tabGroup, 1);\n                previousId = isPreviouslyUsedTabAttached ? previousId : '';\n            };\n            populateTabs();\n            labShell.layoutModified.connect(() => {\n                populateTabs();\n            });\n            // Update the ID of the previous active tab if a new tab is selected.\n            labShell.currentChanged.connect((_, args) => {\n                const widget = args.oldValue;\n                if (!widget) {\n                    return;\n                }\n                previousId = widget.id;\n            });\n        });\n    }\n}\n/**\n * Create the basic `Help` menu.\n */\nfunction createHelpMenu(app, menu, trans) {\n    menu.menu.title.label = trans.__('Help');\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n/**\n * A namespace for Private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Return the first value of the iterable that satisfies the predicate\n     * function.\n     */\n    function find(it, predicate) {\n        for (const value of it) {\n            if (predicate(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * A utility function that delegates a portion of a label to an IMenuExtender.\n     */\n    function delegateLabel(app, s, label) {\n        const widget = app.shell.currentWidget;\n        const extender = widget\n            ? find(s, value => value.tracker.has(widget))\n            : undefined;\n        if (!extender) {\n            return '';\n        }\n        else {\n            const count = extender.tracker.size;\n            // Coerce the result to be a string. When Typedoc is updated to use\n            // Typescript 2.8, we can possibly use conditional types to get Typescript\n            // to recognize this is a string.\n            return extender[label](count);\n        }\n    }\n    Private.delegateLabel = delegateLabel;\n    /**\n     * A utility function that delegates command execution\n     * to an IMenuExtender.\n     */\n    function delegateExecute(app, s, executor) {\n        return () => {\n            const widget = app.shell.currentWidget;\n            const extender = widget\n                ? find(s, value => value.tracker.has(widget))\n                : undefined;\n            if (!extender) {\n                return Promise.resolve(void 0);\n            }\n            // Coerce the result to be a function. When Typedoc is updated to use\n            // Typescript 2.8, we can possibly use conditional types to get Typescript\n            // to recognize this is a function.\n            const f = extender[executor];\n            return f(widget);\n        };\n    }\n    Private.delegateExecute = delegateExecute;\n    /**\n     * A utility function that delegates whether a command is enabled\n     * to an IMenuExtender.\n     */\n    function delegateEnabled(app, s, executor) {\n        return () => {\n            const widget = app.shell.currentWidget;\n            const extender = widget\n                ? find(s, value => value.tracker.has(widget))\n                : undefined;\n            return (!!extender &&\n                !!extender[executor] &&\n                (extender.isEnabled && widget ? extender.isEnabled(widget) : true));\n        };\n    }\n    Private.delegateEnabled = delegateEnabled;\n    /**\n     * A utility function that delegates whether a command is toggled\n     * for an IMenuExtender.\n     */\n    function delegateToggled(app, s, toggled) {\n        return () => {\n            const widget = app.shell.currentWidget;\n            const extender = widget\n                ? find(s, value => value.tracker.has(widget))\n                : undefined;\n            // Coerce extender[toggled] to be a function. When Typedoc is updated to use\n            // Typescript 2.8, we can possibly use conditional types to get Typescript\n            // to recognize this is a function.\n            return (!!extender &&\n                !!extender[toggled] &&\n                !!widget &&\n                !!extender[toggled](widget));\n        };\n    }\n    Private.delegateToggled = delegateToggled;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mainmenu-extension/lib/index.js?");

/***/ })

}]);