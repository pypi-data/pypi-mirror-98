/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_docmanager-extension_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/docmanager-extension/lib/index.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@jupyterlab/docmanager-extension/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"savingStatusPlugin\": () => /* binding */ savingStatusPlugin,\n/* harmony export */   \"pathStatusPlugin\": () => /* binding */ pathStatusPlugin,\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ \"webpack/sharing/consume/default/@jupyterlab/application/@jupyterlab/application?6b93\");\n/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ \"webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils?2f22\");\n/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils?f105\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/docmanager */ \"webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager?5023\");\n/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/mainmenu */ \"webpack/sharing/consume/default/@jupyterlab/mainmenu/@jupyterlab/mainmenu?3845\");\n/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @jupyterlab/settingregistry */ \"webpack/sharing/consume/default/@jupyterlab/settingregistry/@jupyterlab/settingregistry?83bd\");\n/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/statusbar */ \"webpack/sharing/consume/default/@jupyterlab/statusbar/@jupyterlab/statusbar\");\n/* harmony import */ var _jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/translation */ \"webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation?5414\");\n/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lumino/algorithm */ \"webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets?5ac6\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_10__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module docmanager-extension\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The command IDs used by the document manager plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.clone = 'docmanager:clone';\n    CommandIDs.deleteFile = 'docmanager:delete-file';\n    CommandIDs.newUntitled = 'docmanager:new-untitled';\n    CommandIDs.open = 'docmanager:open';\n    CommandIDs.openBrowserTab = 'docmanager:open-browser-tab';\n    CommandIDs.reload = 'docmanager:reload';\n    CommandIDs.rename = 'docmanager:rename';\n    CommandIDs.del = 'docmanager:delete';\n    CommandIDs.restoreCheckpoint = 'docmanager:restore-checkpoint';\n    CommandIDs.save = 'docmanager:save';\n    CommandIDs.saveAll = 'docmanager:save-all';\n    CommandIDs.saveAs = 'docmanager:save-as';\n    CommandIDs.download = 'docmanager:download';\n    CommandIDs.toggleAutosave = 'docmanager:toggle-autosave';\n    CommandIDs.showInFileBrowser = 'docmanager:show-in-file-browser';\n})(CommandIDs || (CommandIDs = {}));\nconst pluginId = '@jupyterlab/docmanager-extension:plugin';\n/**\n * The default document manager provider.\n */\nconst docManagerPlugin = {\n    id: pluginId,\n    provides: _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager,\n    requires: [_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_5__.ISettingRegistry, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.ITranslator],\n    optional: [\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabStatus,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette,\n        _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell,\n        _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__.IMainMenu,\n        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ISessionContextDialogs\n    ],\n    activate: (app, settingRegistry, translator, status, palette, labShell, mainMenu, sessionDialogs) => {\n        var _a;\n        const trans = translator.load('jupyterlab');\n        const manager = app.serviceManager;\n        const contexts = new WeakSet();\n        const opener = {\n            open: (widget, options) => {\n                if (!widget.id) {\n                    widget.id = `document-manager-${++Private.id}`;\n                }\n                widget.title.dataset = Object.assign({ type: 'document-title' }, widget.title.dataset);\n                if (!widget.isAttached) {\n                    app.shell.add(widget, 'main', options || {});\n                }\n                app.shell.activateById(widget.id);\n                // Handle dirty state for open documents.\n                const context = docManager.contextForWidget(widget);\n                if (context && !contexts.has(context)) {\n                    if (status) {\n                        handleContext(status, context);\n                    }\n                    contexts.add(context);\n                }\n            }\n        };\n        const registry = app.docRegistry;\n        const when = app.restored.then(() => void 0);\n        const docManager = new _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.DocumentManager({\n            registry,\n            manager,\n            opener,\n            when,\n            setBusy: (_a = (status && (() => status.setBusy()))) !== null && _a !== void 0 ? _a : undefined,\n            sessionDialogs: sessionDialogs || undefined,\n            translator\n        });\n        // Register the file operations commands.\n        addCommands(app, docManager, opener, settingRegistry, translator, labShell, palette, mainMenu);\n        // Keep up to date with the settings registry.\n        const onSettingsUpdated = (settings) => {\n            // Handle whether to autosave\n            const autosave = settings.get('autosave').composite;\n            docManager.autosave =\n                autosave === true || autosave === false ? autosave : true;\n            app.commands.notifyCommandChanged(CommandIDs.toggleAutosave);\n            // Handle autosave interval\n            const autosaveInterval = settings.get('autosaveInterval').composite;\n            docManager.autosaveInterval = autosaveInterval || 120;\n            // Handle default widget factory overrides.\n            const defaultViewers = settings.get('defaultViewers').composite;\n            const overrides = {};\n            // Filter the defaultViewers and file types for existing ones.\n            Object.keys(defaultViewers).forEach(ft => {\n                if (!registry.getFileType(ft)) {\n                    console.warn(`File Type ${ft} not found`);\n                    return;\n                }\n                if (!registry.getWidgetFactory(defaultViewers[ft])) {\n                    console.warn(`Document viewer ${defaultViewers[ft]} not found`);\n                }\n                overrides[ft] = defaultViewers[ft];\n            });\n            // Set the default factory overrides. If not provided, this has the\n            // effect of unsetting any previous overrides.\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.each)(registry.fileTypes(), ft => {\n                try {\n                    registry.setDefaultWidgetFactory(ft.name, overrides[ft.name]);\n                }\n                catch (_a) {\n                    console.warn(`Failed to set default viewer ${overrides[ft.name]} for file type ${ft.name}`);\n                }\n            });\n        };\n        // Fetch the initial state of the settings.\n        Promise.all([settingRegistry.load(pluginId), app.restored])\n            .then(([settings]) => {\n            settings.changed.connect(onSettingsUpdated);\n            onSettingsUpdated(settings);\n        })\n            .catch((reason) => {\n            console.error(reason.message);\n        });\n        // Register a fetch transformer for the settings registry,\n        // allowing us to dynamically populate a help string with the\n        // available document viewers and file types for the default\n        // viewer overrides.\n        settingRegistry.transform(pluginId, {\n            fetch: plugin => {\n                // Get the available file types.\n                const fileTypes = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.toArray)(registry.fileTypes())\n                    .map(ft => ft.name)\n                    .join('    \\n');\n                // Get the available widget factories.\n                const factories = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.toArray)(registry.widgetFactories())\n                    .map(f => f.name)\n                    .join('    \\n');\n                // Generate the help string.\n                const description = trans.__(`Overrides for the default viewers for file types.\nSpecify a mapping from file type name to document viewer name, for example:\n\ndefaultViewers: {\n  markdown: \"Markdown Preview\"\n}\n\nIf you specify non-existent file types or viewers, or if a viewer cannot\nopen a given file type, the override will not function.\n\nAvailable viewers:\n%1\n\nAvailable file types:\n%2`, factories, fileTypes);\n                const schema = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_9__.JSONExt.deepCopy(plugin.schema);\n                schema.properties.defaultViewers.description = description;\n                return Object.assign(Object.assign({}, plugin), { schema });\n            }\n        });\n        // If the document registry gains or loses a factory or file type,\n        // regenerate the settings description with the available options.\n        registry.changed.connect(() => settingRegistry.reload(pluginId));\n        return docManager;\n    }\n};\n/**\n * A plugin for adding a saving status item to the status bar.\n */\nconst savingStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:saving-status',\n    autoStart: true,\n    requires: [_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_7__.ITranslator],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__.IStatusBar],\n    activate: (_, docManager, labShell, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const saving = new _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.SavingStatus({ docManager, translator });\n        // Keep the currently active widget synchronized.\n        saving.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            saving.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(savingStatusPlugin.id, {\n            item: saving,\n            align: 'middle',\n            isActive: () => true,\n            activeStateChanged: saving.model.stateChanged\n        });\n    }\n};\n/**\n * A plugin providing a file path widget to the status bar.\n */\nconst pathStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:path-status',\n    autoStart: true,\n    requires: [_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager, _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell],\n    optional: [_jupyterlab_statusbar__WEBPACK_IMPORTED_MODULE_6__.IStatusBar],\n    activate: (_, docManager, labShell, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const path = new _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.PathStatus({ docManager });\n        // Keep the file path widget up-to-date with the application active widget.\n        path.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            path.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(pathStatusPlugin.id, {\n            item: path,\n            align: 'right',\n            rank: 0,\n            isActive: () => true\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    docManagerPlugin,\n    pathStatusPlugin,\n    savingStatusPlugin\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugins);\n/* Widget to display the revert to checkpoint confirmation. */\nclass RevertConfirmWidget extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_10__.Widget {\n    /**\n     * Construct a new revert confirmation widget.\n     */\n    constructor(checkpoint, trans, fileType = 'notebook') {\n        super({\n            node: Private.createRevertConfirmNode(checkpoint, fileType, trans)\n        });\n    }\n}\n// Returns the file type for a widget.\nfunction fileType(widget, docManager) {\n    if (!widget) {\n        return 'File';\n    }\n    const context = docManager.contextForWidget(widget);\n    if (!context) {\n        return '';\n    }\n    const fts = docManager.registry.getFileTypesForPath(context.path);\n    return fts.length && fts[0].displayName ? fts[0].displayName : 'File';\n}\n/**\n * Add the file operations commands to the application's command registry.\n */\nfunction addCommands(app, docManager, opener, settingRegistry, translator, labShell, palette, mainMenu) {\n    const trans = translator.load('jupyterlab');\n    const { commands, shell } = app;\n    const category = trans.__('File Operations');\n    const isEnabled = () => {\n        const { currentWidget } = shell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    const isWritable = () => {\n        const { currentWidget } = shell;\n        if (!currentWidget) {\n            return false;\n        }\n        const context = docManager.contextForWidget(currentWidget);\n        return !!(context &&\n            context.contentsModel &&\n            context.contentsModel.writable);\n    };\n    // If inside a rich application like JupyterLab, add additional functionality.\n    if (labShell) {\n        addLabCommands(app, docManager, labShell, opener, translator, palette);\n    }\n    commands.addCommand(CommandIDs.deleteFile, {\n        label: () => `Delete ${fileType(shell.currentWidget, docManager)}`,\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            if (!path) {\n                const command = CommandIDs.deleteFile;\n                throw new Error(`A non-empty path is required for ${command}.`);\n            }\n            return docManager.deleteFile(path);\n        }\n    });\n    commands.addCommand(CommandIDs.newUntitled, {\n        execute: args => {\n            // FIXME-TRANS: Localizing args['error']?\n            const errorTitle = args['error'] || trans.__('Error');\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const options = {\n                type: args['type'],\n                path\n            };\n            if (args['type'] === 'file') {\n                options.ext = args['ext'] || '.txt';\n            }\n            return docManager.services.contents\n                .newUntitled(options)\n                .catch(error => (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showErrorMessage)(errorTitle, error));\n        },\n        label: args => args['label'] || `New ${args['type']}`\n    });\n    commands.addCommand(CommandIDs.open, {\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const factory = args['factory'] || void 0;\n            const kernel = args === null || args === void 0 ? void 0 : args.kernel;\n            const options = args['options'] || void 0;\n            return docManager.services.contents\n                .get(path, { content: false })\n                .then(() => docManager.openOrReveal(path, factory, kernel, options));\n        },\n        icon: args => args['icon'] || '',\n        label: args => (args['label'] || args['factory']),\n        mnemonic: args => args['mnemonic'] || -1\n    });\n    commands.addCommand(CommandIDs.openBrowserTab, {\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            if (!path) {\n                return;\n            }\n            return docManager.services.contents.getDownloadUrl(path).then(url => {\n                const opened = window.open();\n                if (opened) {\n                    opened.opener = null;\n                    opened.location.href = url;\n                }\n                else {\n                    throw new Error('Failed to open new browser tab.');\n                }\n            });\n        },\n        icon: args => args['icon'] || '',\n        label: () => trans.__('Open in New Browser Tab')\n    });\n    commands.addCommand(CommandIDs.reload, {\n        label: () => trans.__('Reload %1 from Disk', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Reload contents from disk'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            const type = fileType(shell.currentWidget, docManager);\n            if (!context) {\n                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                    title: trans.__('Cannot Reload'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            if (context.model.dirty) {\n                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                    title: trans.__('Reload %1 from Disk', type),\n                    body: trans.__('Are you sure you want to reload the %1 from the disk?', type),\n                    buttons: [\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton({ label: trans.__('Reload') })\n                    ]\n                }).then(result => {\n                    if (result.button.accept && !context.isDisposed) {\n                        return context.revert();\n                    }\n                });\n            }\n            else {\n                if (!context.isDisposed) {\n                    return context.revert();\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.restoreCheckpoint, {\n        label: () => trans.__('Revert %1 to Checkpoint', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Revert contents to previous checkpoint'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            if (!context) {\n                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                    title: trans.__('Cannot Revert'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            return context.listCheckpoints().then(checkpoints => {\n                if (checkpoints.length < 1) {\n                    return;\n                }\n                const lastCheckpoint = checkpoints[checkpoints.length - 1];\n                if (!lastCheckpoint) {\n                    return;\n                }\n                const type = fileType(shell.currentWidget, docManager);\n                return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                    title: trans.__('Revert %1 to checkpoint', type),\n                    body: new RevertConfirmWidget(lastCheckpoint, trans, type),\n                    buttons: [\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton({ label: trans.__('Revert') })\n                    ]\n                }).then(result => {\n                    if (context.isDisposed) {\n                        return;\n                    }\n                    if (result.button.accept) {\n                        if (context.model.readOnly) {\n                            return context.revert();\n                        }\n                        return context.restoreCheckpoint().then(() => context.revert());\n                    }\n                });\n            });\n        }\n    });\n    commands.addCommand(CommandIDs.save, {\n        label: () => trans.__('Save %1', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Save and create checkpoint'),\n        isEnabled: isWritable,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(shell.currentWidget);\n                if (!context) {\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Ok') })]\n                    });\n                }\n                if (context.model.readOnly) {\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('Document is read-only'),\n                        buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Ok') })]\n                    });\n                }\n                return context\n                    .save()\n                    .then(() => context.createCheckpoint())\n                    .catch(err => {\n                    // If the save was canceled by user-action, do nothing.\n                    // FIXME-TRANS: Is this using the text on the button or?\n                    if (err.message === 'Cancel') {\n                        return;\n                    }\n                    throw err;\n                });\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.saveAll, {\n        label: () => trans.__('Save All'),\n        caption: trans.__('Save all open documents'),\n        isEnabled: () => {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.some)((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.map)(shell.widgets('main'), w => docManager.contextForWidget(w)), c => { var _a, _b; return (_b = (_a = c === null || c === void 0 ? void 0 : c.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) !== null && _b !== void 0 ? _b : false; });\n        },\n        execute: () => {\n            const promises = [];\n            const paths = new Set(); // Cache so we don't double save files.\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_8__.each)(shell.widgets('main'), widget => {\n                const context = docManager.contextForWidget(widget);\n                if (context && !context.model.readOnly && !paths.has(context.path)) {\n                    paths.add(context.path);\n                    promises.push(context.save());\n                }\n            });\n            return Promise.all(promises);\n        }\n    });\n    commands.addCommand(CommandIDs.saveAs, {\n        label: () => trans.__('Save %1 As…', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Save with new path'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(shell.currentWidget);\n                if (!context) {\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('Ok') })]\n                    });\n                }\n                return context.saveAs();\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.download, {\n        label: trans.__('Download'),\n        caption: trans.__('Download the file to your computer'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(shell.currentWidget);\n                if (!context) {\n                    return (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                        title: trans.__('Cannot Download'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton({ label: trans.__('OK') })]\n                    });\n                }\n                return context.download();\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.toggleAutosave, {\n        label: trans.__('Autosave Documents'),\n        isToggled: () => docManager.autosave,\n        execute: () => {\n            const value = !docManager.autosave;\n            const key = 'autosave';\n            return settingRegistry\n                .set(pluginId, key, value)\n                .catch((reason) => {\n                console.error(`Failed to set ${pluginId}:${key} - ${reason.message}`);\n            });\n        }\n    });\n    // .jp-mod-current added so that the console-creation command is only shown\n    // on the current document.\n    // Otherwise it will delegate to the wrong widget.\n    app.contextMenu.addItem({\n        command: 'filemenu:create-console',\n        selector: '[data-type=\"document-title\"].jp-mod-current',\n        rank: 6\n    });\n    if (palette) {\n        [\n            CommandIDs.reload,\n            CommandIDs.restoreCheckpoint,\n            CommandIDs.save,\n            CommandIDs.saveAs,\n            CommandIDs.download,\n            CommandIDs.toggleAutosave\n        ].forEach(command => {\n            palette.addItem({ command, category });\n        });\n    }\n    if (mainMenu) {\n        mainMenu.settingsMenu.addGroup([{ command: CommandIDs.toggleAutosave }], 5);\n        mainMenu.fileMenu.addGroup([{ command: CommandIDs.download }], 6);\n    }\n}\nfunction addLabCommands(app, docManager, labShell, opener, translator, palette) {\n    const trans = translator.load('jupyterlab');\n    const { commands } = app;\n    // Returns the doc widget associated with the most recent contextmenu event.\n    const contextMenuWidget = () => {\n        var _a;\n        const pathRe = /[Pp]ath:\\s?(.*)\\n?/;\n        const test = (node) => { var _a; return !!((_a = node['title']) === null || _a === void 0 ? void 0 : _a.match(pathRe)); };\n        const node = app.contextMenuHitTest(test);\n        const pathMatch = node === null || node === void 0 ? void 0 : node['title'].match(pathRe);\n        return ((_a = (pathMatch && docManager.findWidget(pathMatch[1], null))) !== null && _a !== void 0 ? _a : \n        // Fall back to active doc widget if path cannot be obtained from event.\n        labShell.currentWidget);\n    };\n    // Returns `true` if the current widget has a document context.\n    const isEnabled = () => {\n        const { currentWidget } = labShell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    commands.addCommand(CommandIDs.clone, {\n        label: () => trans.__('New View for %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: args => {\n            const widget = contextMenuWidget();\n            const options = args['options'] || {\n                mode: 'split-right'\n            };\n            if (!widget) {\n                return;\n            }\n            // Clone the widget.\n            const child = docManager.cloneWidget(widget);\n            if (child) {\n                opener.open(child, options);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.rename, {\n        label: () => trans.__('Rename %1…', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                return (0,_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.renameDialog)(docManager, context.path);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.del, {\n        label: () => trans.__('Delete %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: async () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                if (!context) {\n                    return;\n                }\n                const result = await (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({\n                    title: trans.__('Delete'),\n                    body: trans.__('Are you sure you want to delete %1', context.path),\n                    buttons: [\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.warnButton({ label: trans.__('Delete') })\n                    ]\n                });\n                if (result.button.accept) {\n                    await app.commands.execute('docmanager:delete-file', {\n                        path: context.path\n                    });\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.showInFileBrowser, {\n        label: () => trans.__('Show in File Browser'),\n        isEnabled,\n        execute: async () => {\n            const widget = contextMenuWidget();\n            const context = widget && docManager.contextForWidget(widget);\n            if (!context) {\n                return;\n            }\n            // 'activate' is needed if this command is selected in the \"open tabs\" sidebar\n            await commands.execute('filebrowser:activate', { path: context.path });\n            await commands.execute('filebrowser:go-to-path', { path: context.path });\n        }\n    });\n    app.contextMenu.addItem({\n        command: CommandIDs.rename,\n        selector: '[data-type=\"document-title\"]',\n        rank: 1\n    });\n    app.contextMenu.addItem({\n        command: CommandIDs.del,\n        selector: '[data-type=\"document-title\"]',\n        rank: 2\n    });\n    app.contextMenu.addItem({\n        command: CommandIDs.clone,\n        selector: '[data-type=\"document-title\"]',\n        rank: 3\n    });\n    app.contextMenu.addItem({\n        command: CommandIDs.showInFileBrowser,\n        selector: '[data-type=\"document-title\"]',\n        rank: 4\n    });\n}\n/**\n * Handle dirty state for a context.\n */\nfunction handleContext(status, context) {\n    let disposable = null;\n    const onStateChanged = (sender, args) => {\n        if (args.name === 'dirty') {\n            if (args.newValue === true) {\n                if (!disposable) {\n                    disposable = status.setDirty();\n                }\n            }\n            else if (disposable) {\n                disposable.dispose();\n                disposable = null;\n            }\n        }\n    };\n    void context.ready.then(() => {\n        context.model.stateChanged.connect(onStateChanged);\n        if (context.model.dirty) {\n            disposable = status.setDirty();\n        }\n    });\n    context.disposed.connect(() => {\n        if (disposable) {\n            disposable.dispose();\n        }\n    });\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A counter for unique IDs.\n     */\n    Private.id = 0;\n    function createRevertConfirmNode(checkpoint, fileType, trans) {\n        const body = document.createElement('div');\n        const confirmMessage = document.createElement('p');\n        const confirmText = document.createTextNode(trans.__('Are you sure you want to revert the %1 to the latest checkpoint? ', fileType));\n        const cannotUndoText = document.createElement('strong');\n        cannotUndoText.textContent = trans.__('This cannot be undone.');\n        confirmMessage.appendChild(confirmText);\n        confirmMessage.appendChild(cannotUndoText);\n        const lastCheckpointMessage = document.createElement('p');\n        const lastCheckpointText = document.createTextNode(trans.__('The checkpoint was last updated at: '));\n        const lastCheckpointDate = document.createElement('p');\n        const date = new Date(checkpoint.last_modified);\n        lastCheckpointDate.style.textAlign = 'center';\n        lastCheckpointDate.textContent =\n            _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.Time.format(date, 'dddd, MMMM Do YYYY, h:mm:ss a') +\n                ' (' +\n                _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.Time.formatHuman(date) +\n                ')';\n        lastCheckpointMessage.appendChild(lastCheckpointText);\n        lastCheckpointMessage.appendChild(lastCheckpointDate);\n        body.appendChild(confirmMessage);\n        body.appendChild(lastCheckpointMessage);\n        return body;\n    }\n    Private.createRevertConfirmNode = createRevertConfirmNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager-extension/lib/index.js?");

/***/ })

}]);