#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.progress',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20210316',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  description =
    ('A progress tracker with methods for throughput, ETA and update notification; '    
 'also a compound progress meter composed from other progress meters.'),
  long_description =
    ('A progress tracker with methods for throughput, ETA and update '    
 'notification;\n'    
 'also a compound progress meter composed from other progress meters.\n'    
 '\n'    
 '*Latest release 20210316*:\n'    
 '* Progress.iterbar: only update the status line once per iteration, either '    
 'before or after the yield according to incfirst.\n'    
 '* Progress.iterbar: fix the meaning of update_frequency to count iterations, '    
 'add update_min_size to count progress advance.\n'    
 '\n'    
 '## Function `auto_progressbar(*da, **dkw)`\n'    
 '\n'    
 'Decorator for a function accepting an optional `progress`\n'    
 'keyword parameter.\n'    
 'If `progress` is `None` and the default `Upd` is not disabled,\n'    
 'run the function with a progress bar.\n'    
 '\n'    
 '## Class `BaseProgress`\n'    
 '\n'    
 'The base class for `Progress` and `OverProcess`\n'    
 'with various common methods.\n'    
 '\n'    
 'Note that durations are in seconds\n'    
 'and that absolute time is in seconds since the UNIX epoch\n'    
 '(the basis of `time.time()`).\n'    
 '\n'    
 '### Method `BaseProgress.__init__(self, name=None, start_time=None, '    
 'units_scale=None)`\n'    
 '\n'    
 'Initialise a progress instance.\n'    
 '\n'    
 'Parameters:\n'    
 '* `name`: optional name\n'    
 '* `start_time`: optional UNIX epoch start time, default from `time.time()`\n'    
 '* `units_scale`: a scale for use with `cs.units.transcribe`,\n'    
 '  default `BINARY_BYTES_SCALE`\n'    
 '\n'    
 '### Method `BaseProgress.__eq__(self, other)`\n'    
 '\n'    
 'A Progress is equal to another object `other`\n'    
 'if its position equals `int(other)`.\n'    
 '\n'    
 '### Method `BaseProgress.__ge__(self, other, '    
 'NotImplemented=NotImplemented)`\n'    
 '\n'    
 'Return a >= b.  Computed by @total_ordering from (not a < b).\n'    
 '\n'    
 '### Method `BaseProgress.__gt__(self, other, '    
 'NotImplemented=NotImplemented)`\n'    
 '\n'    
 'Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).\n'    
 '\n'    
 '### Method `BaseProgress.__int__(self)`\n'    
 '\n'    
 '`int(Progress)` returns the current position.\n'    
 '\n'    
 '### Method `BaseProgress.__le__(self, other, '    
 'NotImplemented=NotImplemented)`\n'    
 '\n'    
 'Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).\n'    
 '\n'    
 '### Method `BaseProgress.__lt__(self, other)`\n'    
 '\n'    
 'A Progress is less then another object `other`\n'    
 'if its position is less than `int(other)`.\n'    
 '\n'    
 '### Method `BaseProgress.arrow(self, width, no_padding=False)`\n'    
 '\n'    
 'Construct a progress arrow representing completion\n'    
 'to fit in the specified `width`.\n'    
 '\n'    
 '### Method `BaseProgress.bar(self, label=None, upd=None, proxy=None, '    
 'statusfunc=None, width=None, window=None, report_print=None, insert_pos=1, '    
 'deferred=False)`\n'    
 '\n'    
 'A context manager to create and withdraw a progress bar.\n'    
 'It returns the `UpdProxy` which displays the progress bar.\n'    
 '\n'    
 'Parameters:\n'    
 '* `label`: a label for the progress bar,\n'    
 '  default from `self.name`.\n'    
 '* `proxy`: an optional `UpdProxy` to display the progress bar\n'    
 '* `upd`: an optional `cs.upd.Upd` instance,\n'    
 '  used to produce the progress bar status line if not supplied.\n'    
 '  The default `upd` is `cs.upd.Upd()`\n'    
 '  which uses `sys.stderr` for display.\n'    
 '* `statusfunc`: an optional function to compute the progress bar text\n'    
 '  accepting `(self,label,width)`.\n'    
 '* `width`: an optional width expressioning how wide the progress bar\n'    
 '  text may be.\n'    
 '  The default comes from the `proxy.width` property.\n'    
 '* `window`: optional timeframe to define "recent" in seconds;\n'    
 '  if the default `statusfunc` (`Progress.status`) is used\n'    
 '  this is passed to it\n'    
 '* `report_print`: optional `print` compatible function\n'    
 '  with which to write a report on completion;\n'    
 '  this may also be a `bool`, which if true will use `Upd.print`\n'    
 '  in order to interoperate with `Upd`.\n'    
 '* `insert_pos`: where to insert the progress bar, default `1`\n'    
 '* `deferred`: optional flag; if true do not create the\n'    
 '  progress bar until the first update occurs.\n'    
 '\n'    
 'Example use:\n'    
 '\n'    
 '    # display progress reporting during upload_filename()\n'    
 '    # which updates the supplied Progress instance\n'    
 '    # during its operation\n'    
 '    P = Progress(name=label)\n'    
 '    with P.bar(report_print=True):\n'    
 '        upload_filename(src, progress=P)\n'    
 '\n'    
 '### Property `BaseProgress.elapsed_time`\n'    
 '\n'    
 'Time elapsed since `start_time`.\n'    
 '\n'    
 '### Property `BaseProgress.eta`\n'    
 '\n'    
 'The projected time of completion: now + `remaining_time`.\n'    
 '\n'    
 'If `reamining_time` is `None`, this is also `None`.\n'    
 '\n'    
 '### Method `BaseProgress.format_counter(self, value, scale=None, '    
 "max_parts=2, sep=',')`\n"    
 '\n'    
 'Format `value` accoridng to `scale` and `max_parts`\n'    
 'using `cs.units.transcribe`.\n'    
 '\n'    
 '### Method `BaseProgress.iterbar(self, it, label=None, upd=None, proxy=None, '    
 'itemlenfunc=None, statusfunc=None, incfirst=False, width=None, window=None, '    
 'update_frequency=1, update_min_size=0, report_print=None)`\n'    
 '\n'    
 'An iterable progress bar: a generator yielding values\n'    
 'from the iterable `it` while updating a progress bar.\n'    
 '\n'    
 'Parameters:\n'    
 '* `it`: the iterable to consume and yield.\n'    
 '* `itemlenfunc`: an optional function returning the "size" of each item\n'    
 '  from `it`, used to advance `self.position`.\n'    
 '  The default is to assume a size of `1`.\n'    
 '  A convenient alternative choice may be the builtin function `len`.\n'    
 '* `incfirst`: whether to advance `self.position` before we\n'    
 '  `yield` an item from `it` or afterwards.\n'    
 '  This reflects whether it is considered that progress is\n'    
 '  made as items are obtained or only after items are processed\n'    
 '  by whatever is consuming this generator.\n'    
 '  The default is `False`, advancing after processing.\n'    
 '* `label`: a label for the progress bar,\n'    
 '  default from `self.name`.\n'    
 '* `width`: an optional width expressing how wide the progress bar\n'    
 '  text may be.\n'    
 '  The default comes from the `proxy.width` property.\n'    
 '* `window`: optional timeframe to define "recent" in seconds;\n'    
 '  if the default `statusfunc` (`Progress.status`) is used\n'    
 '  this is passed to it\n'    
 '* `statusfunc`: an optional function to compute the progress bar text\n'    
 '  accepting `(self,label,width)`.\n'    
 '* `proxy`: an optional proxy for displaying the progress bar,\n'    
 '  a callable accepting the result of `statusfunc`.\n'    
 '  The default is a `cs.upd.UpdProxy` created from `upd`,\n'    
 '  which inserts a progress bar above the main status line.\n'    
 '* `upd`: an optional `cs.upd.Upd` instance,\n'    
 '  used only to produce the default `proxy` if that is not supplied.\n'    
 '  The default `upd` is `cs.upd.Upd()`\n'    
 '  which uses `sys.stderr` for display.\n'    
 '* `update_frequency`: optional update frequency, default `1`;\n'    
 '  only update the progress bar after this many iterations,\n'    
 '  useful if the iteration rate is quite high\n'    
 '* `update_min_size`: optional update step size, default `0`;\n'    
 '  only update the progress bar after an advance of this many units,\n'    
 '  useful if the iteration size increment is quite small\n'    
 '* `report_print`: optional `print` compatible function\n'    
 '  with which to write a report on completion;\n'    
 '  this may also be a `bool`, which if true will use `Upd.print`\n'    
 '  in order to interoperate with `Upd`.\n'    
 '\n'    
 'Example use:\n'    
 '\n'    
 '    from cs.units import DECIMAL_SCALE\n'    
 '    rows = [some list of data]\n'    
 '    P = Progress(total=len(rows), units_scale=DECIMAL_SCALE)\n'    
 '    for row in P.iterbar(rows, incfirst=True):\n'    
 '        ... do something with each row ...\n'    
 '\n'    
 "    f = open(data_filename, 'rb')\n"    
 '    datalen = os.stat(f).st_size\n'    
 '    def readfrom(f):\n'    
 '        while True:\n'    
 '            bs = f.read(65536)\n'    
 '            if not bs:\n'    
 '                break\n'    
 '            yield bs\n'    
 '    P = Progress(total=datalen)\n'    
 '    for bs in P.iterbar(readfrom(f), itemlenfunc=len):\n'    
 '        ... process the file data in bs ...\n'    
 '\n'    
 '### Property `BaseProgress.ratio`\n'    
 '\n'    
 'The fraction of progress completed: `(position-start)/(total-start)`.\n'    
 'Returns `None` if `total` is `None` or `total<=start`.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> P = Progress()\n'    
 '     P.ratio\n'    
 '    >>> P.total = 16\n'    
 '    >>> P.ratio\n'    
 '    0.0\n'    
 '    >>> P.update(4)\n'    
 '    >>> P.ratio\n'    
 '    0.25\n'    
 '\n'    
 '### Property `BaseProgress.remaining_time`\n'    
 '\n'    
 'The projected time remaining to end\n'    
 'based on the `throughput` and `total`.\n'    
 '\n'    
 'If `total` is `None`, this is `None`.\n'    
 '\n'    
 '### Method `BaseProgress.status(self, label, width, window=None)`\n'    
 '\n'    
 'A progress string of the form:\n'    
 "*label*`: `*pos*`/`*total*` ==>  ETA '*time*\n"    
 '\n'    
 'Parameters:\n'    
 '* `label`: the label for the status line;\n'    
 '  if `None` use `self.name`\n'    
 '* `width`: the available width for the status line;\n'    
 '  if not an `int` use `width.width`\n'    
 '* `window`: optional timeframe to define "recent" in seconds,\n'    
 '  default : `5`\n'    
 '\n'    
 '### Method `BaseProgress.text_pos_of_total(self, fmt=None, fmt_pos=None, '    
 'fmt_total=None, pos_first=False)`\n'    
 '\n'    
 'Return a "total:position" or "position/total" style progress string.\n'    
 '\n'    
 'Parameters:\n'    
 '* `fmt`: format string interpolating `pos_text` and `total_text`.\n'    
 '  Default: `"{pos_text}/{total_text}"` if `pos_first`,\n'    
 '  otherwise `"{total_text}:{pos_text}"`\n'    
 '* `fmt_pos`: formatting function for `self.position`,\n'    
 '  default `self.format_counter`\n'    
 '* `fmt_total`: formatting function for `self.total`,\n'    
 '  default from `fmt_pos`\n'    
 '* `pos_first`: put the position first if true (default `False`),\n'    
 '  only consulted if `fmt` is `None`\n'    
 '\n'    
 '### Property `BaseProgress.throughput`\n'    
 '\n'    
 'The overall throughput: `self.throughput_overall()`.\n'    
 '\n'    
 'By comparison,\n'    
 'the `Progress.throughput` property is `self.throughput_recent`\n'    
 'if the `throughput_window` is not `None`,\n'    
 'otherwise it falls back to `throughput_overall`.\n'    
 '\n'    
 '### Method `BaseProgress.throughput_overall(self)`\n'    
 '\n'    
 'The overall throughput from `start` to `position`\n'    
 'during `elapsed_time`.\n'    
 '\n'    
 '### Method `BaseProgress.throughput_recent(self, time_window)`\n'    
 '\n'    
 'The recent throughput. Implemented by subclasses.\n'    
 '\n'    
 '## Class `CheckPoint(builtins.tuple)`\n'    
 '\n'    
 'CheckPoint(time, position)\n'    
 '\n'    
 '### Property `CheckPoint.position`\n'    
 '\n'    
 'Alias for field number 1\n'    
 '\n'    
 '### Property `CheckPoint.time`\n'    
 '\n'    
 'Alias for field number 0\n'    
 '\n'    
 '## Class `OverProgress(BaseProgress)`\n'    
 '\n'    
 'A `Progress`-like class computed from a set of subsidiary `Progress`es.\n'    
 '\n'    
 'AN OverProgress instance has an attribute ``notify_update`` which\n'    
 'is a set of callables.\n'    
 'Whenever the position of a subsidiary `Progress` is updated,\n'    
 'each of these will be called with the `Progress` instance and `None`.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> P = OverProgress(name="over")\n'    
 '    >>> P1 = Progress(name="progress1", position=12)\n'    
 '    >>> P1.total = 100\n'    
 '    >>> P1.advance(7)\n'    
 '    >>> P2 = Progress(name="progress2", position=20)\n'    
 '    >>> P2.total = 50\n'    
 '    >>> P2.advance(9)\n'    
 '    >>> P.add(P1)\n'    
 '    >>> P.add(P2)\n'    
 '    >>> P1.total\n'    
 '    100\n'    
 '    >>> P2.total\n'    
 '    50\n'    
 '    >>> P.total\n'    
 '    150\n'    
 '    >>> P1.start\n'    
 '    12\n'    
 '    >>> P2.start\n'    
 '    20\n'    
 '    >>> P.start\n'    
 '    0\n'    
 '    >>> P1.position\n'    
 '    19\n'    
 '    >>> P2.position\n'    
 '    29\n'    
 '    >>> P.position\n'    
 '    16\n'    
 '\n'    
 '### Method `OverProgress.add(self, subprogress)`\n'    
 '\n'    
 'Add a subsidairy `Progress` to the contributing set.\n'    
 '\n'    
 '### Property `OverProgress.eta`\n'    
 '\n'    
 'The `eta` is the maximum of the subsidiary etas.\n'    
 '\n'    
 '### Property `OverProgress.position`\n'    
 '\n'    
 'The `position` is the sum off the subsidiary position offsets\n'    
 'from their respective starts.\n'    
 '\n'    
 '### Method `OverProgress.remove(self, subprogress, accrue=False)`\n'    
 '\n'    
 'Remove a subsidairy `Progress` from the contributing set.\n'    
 '\n'    
 '### Property `OverProgress.start`\n'    
 '\n'    
 'We always return a starting value of 0.\n'    
 '\n'    
 '### Property `OverProgress.throughput`\n'    
 '\n'    
 'The `throughput` is the sum of the subsidiary throughputs.\n'    
 '\n'    
 '### Method `OverProgress.throughput_recent(self, time_window)`\n'    
 '\n'    
 'The `throughput_recent` is the sum of the subsidiary throughput_recentss.\n'    
 '\n'    
 '### Property `OverProgress.total`\n'    
 '\n'    
 'The `total` is the sum of the subsidiary totals.\n'    
 '\n'    
 '## Class `Progress(BaseProgress)`\n'    
 '\n'    
 'A progress counter to track task completion with various utility methods.\n'    
 '\n'    
 'Example:\n'    
 '\n'    
 '    >>> P = Progress(name="example")\n'    
 '    >>> P                         #doctest: +ELLIPSIS\n'    
 '    '    
 "Progress(name='example',start=0,position=0,start_time=...,throughput_window=None,total=None):[CheckPoint(time=..., "    
 'position=0)]\n'    
 '    >>> P.advance(5)\n'    
 '    >>> P                         #doctest: +ELLIPSIS\n'    
 '    '    
 "Progress(name='example',start=0,position=5,start_time=...,throughput_window=None,total=None):[CheckPoint(time=..., "    
 'position=0), CheckPoint(time=..., position=5)]\n'    
 '    >>> P.total = 100\n'    
 '    >>> P                         #doctest: +ELLIPSIS\n'    
 '    '    
 "Progress(name='example',start=0,position=5,start_time=...,throughput_window=None,total=100):[CheckPoint(time=..., "    
 'position=0), CheckPoint(time=..., position=5)]\n'    
 '\n'    
 'A Progress instance has an attribute ``notify_update`` which\n'    
 'is a set of callables. Whenever the position is updated, each\n'    
 'of these will be called with the `Progress` instance and the\n'    
 'latest `CheckPoint`.\n'    
 '\n'    
 '`Progress` objects also make a small pretense of being an integer.\n'    
 'The expression `int(progress)` returns the current position,\n'    
 'and `+=` and `-=` adjust the position.\n'    
 '\n'    
 'This is convenient for coding, but importantly it is also\n'    
 'useful for discretionary use of a Progress with some other\n'    
 'object.\n'    
 'If you want to make a lightweight `Progress` capable class\n'    
 'you can set a position attribute to an `int`\n'    
 'and manipulate it carefully using `+=` and `-=` entirely.\n'    
 'If you decide to incur the cost of maintaining a `Progress` object\n'    
 'you can slot it in:\n'    
 '\n'    
 '    # initial setup with just an int\n'    
 '    my_thing.amount = 0\n'    
 '\n'    
 '    # later, or on some option, use a Progress instance\n'    
 '    my_thing.amount = Progress(my_thing.amount)\n'    
 '\n'    
 '### Method `Progress.__init__(self, position=None, name=None, start=None, '    
 'start_time=None, throughput_window=None, total=None, units_scale=None)`\n'    
 '\n'    
 'Initialise the Progesss object.\n'    
 '\n'    
 'Parameters:\n'    
 '* `position`: initial position, default `0`.\n'    
 '* `name`: optional name for this instance.\n'    
 '* `start`: starting position of progress range,\n'    
 '  default from `position`.\n'    
 '* `start_time`: start time of the process, default now.\n'    
 '* `throughput_window`: length of throughput time window in seconds,\n'    
 '  default None.\n'    
 '* `total`: expected completion value, default None.\n'    
 '\n'    
 '### Method `Progress.__iadd__(self, delta)`\n'    
 '\n'    
 'Operator += form of advance().\n'    
 '\n'    
 '>>> P = Progress()\n'    
 '>>> P.position\n'    
 '0\n'    
 '>>> P += 4\n'    
 '>>> P.position\n'    
 '4\n'    
 '>>> P += 4\n'    
 '>>> P.position\n'    
 '8\n'    
 '\n'    
 '### Method `Progress.__isub__(self, delta)`\n'    
 '\n'    
 'Operator -= form of advance().\n'    
 '\n'    
 '>>> P = Progress()\n'    
 '>>> P.position\n'    
 '0\n'    
 '>>> P += 4\n'    
 '>>> P.position\n'    
 '4\n'    
 '>>> P -= 4\n'    
 '>>> P.position\n'    
 '0\n'    
 '\n'    
 '### Method `Progress.advance(self, delta, update_time=None)`\n'    
 '\n'    
 'Record more progress, return the advanced position.\n'    
 '\n'    
 '>>> P = Progress()\n'    
 '>>> P.position\n'    
 '0\n'    
 '>>> P.advance(4)\n'    
 '>>> P.position\n'    
 '4\n'    
 '>>> P.advance(4)\n'    
 '>>> P.position\n'    
 '8\n'    
 '\n'    
 '### Property `Progress.latest`\n'    
 '\n'    
 'Latest datum.\n'    
 '\n'    
 '### Property `Progress.position`\n'    
 '\n'    
 'Latest position.\n'    
 '\n'    
 '### Property `Progress.throughput`\n'    
 '\n'    
 'Current throughput per second.\n'    
 '\n'    
 'If `self.throughput_window` is not `None`,\n'    
 'calls `self.throughput_recent(throughput_window)`.\n'    
 'Otherwise call `self.throughput_overall()`.\n'    
 '\n'    
 '### Method `Progress.throughput_recent(self, time_window)`\n'    
 '\n'    
 'Recent throughput per second within a time window in seconds.\n'    
 '\n'    
 'The time span overlapping the start of the window is included\n'    
 'on a flat pro rata basis.\n'    
 '\n'    
 '### Property `Progress.total`\n'    
 '\n'    
 'Return the current total.\n'    
 '\n'    
 '### Method `Progress.update(self, new_position, update_time=None)`\n'    
 '\n'    
 'Record more progress.\n'    
 '\n'    
 '>>> P = Progress()\n'    
 '>>> P.position\n'    
 '0\n'    
 '>>> P.update(12)\n'    
 '>>> P.position\n'    
 '12\n'    
 '\n'    
 '## Function `progressbar(it, label=None, position=None, total=None, '    
 "units_scale=((0, ''),), **kw)`\n"    
 '\n'    
 'Convenience function to construct and run a `Progress.iterbar`\n'    
 'wrapping the iterable `it`,\n'    
 'issuing and withdrawning a progress bar during the iteration.\n'    
 '\n'    
 'Parameters:\n'    
 '* `it`: the iterable to consume\n'    
 '* `label`: optional label, doubles as the `Progress.name`\n'    
 '* `position`: optional starting position\n'    
 '* `total`: optional value for `Progress.total`,\n'    
 '  default from `len(it)` if supported.\n'    
 '* `units_scale`: optional units scale for `Progress`,\n'    
 '  default `UNSCALED_SCALE`\n'    
 '\n'    
 'If `total` is `None` and `it` supports `len()`\n'    
 'then the `Progress.total` is set from it.\n'    
 '\n'    
 'All arguments are passed through to `Progress.iterbar`.\n'    
 '\n'    
 'Example use:\n'    
 '\n'    
 '    for row in progressbar(rows):\n'    
 '        ... do something with row ...\n'    
 '\n'    
 '## Function `selftest(argv)`\n'    
 '\n'    
 'Exercise some of the functionality.\n'    
 '\n'    
 '# Release Log\n'    
 '\n'    
 '\n'    
 '\n'    
 '*Release 20210316*:\n'    
 '* Progress.iterbar: only update the status line once per iteration, either '    
 'before or after the yield according to incfirst.\n'    
 '* Progress.iterbar: fix the meaning of update_frequency to count iterations, '    
 'add update_min_size to count progress advance.\n'    
 '\n'    
 '*Release 20210306*:\n'    
 'progressbar: accept new optional `position` parameter, used to initialise '    
 'the Progress.\n'    
 '\n'    
 '*Release 20201102.1*:\n'    
 'DISTINFO: fix module dependencies.\n'    
 '\n'    
 '*Release 20201102*:\n'    
 '* Format/layout changes for the default status line.\n'    
 '* Progress.throughtput_recent: return None if no new positions beyond the '    
 'starting position.\n'    
 '* BaseProgress.status: accept label=None (default to self.name) and '    
 'width=UpdProxy (uses width.width).\n'    
 '* BaseProgress.status: new optional window parameter, default 5, defining '    
 'the recent throughput window size in seconds.\n'    
 '* A few bugfixes.\n'    
 '\n'    
 '*Release 20201025*:\n'    
 '* Some formatting improvements.\n'    
 '* BaseProgress.bar: new insert_pos parameter to position the progress bar, '    
 'default still 1.\n'    
 '* BaseProgress.bar: new deferred parameter putting off the status bar until '    
 'the first update.\n'    
 '* BaseProgress.bar: accept new optional `proxy` parameter to use (and not '    
 'delete) an existing UpdProxy for display.\n'    
 '* Progress.text_pos_of_total: new `pos_first=False` parameter, rendering the '    
 'total before the position by default (less progress bar noise).\n'    
 '* New @auto_progressbar decorator to provide a progress bar and initialise '    
 'progress= parameter to functions which can use a Progress for reporting.\n'    
 '* Assorted fixes.\n'    
 '\n'    
 '*Release 20200718.3*:\n'    
 'BaseProgress.bar, progressbar: new optional report_print parameter for '    
 'reporting on completion.\n'    
 '\n'    
 '*Release 20200718.2*:\n'    
 'Bugfix: BaseProgress.status: handle throughput=0 when total=None.\n'    
 '\n'    
 '*Release 20200718.1*:\n'    
 'BaseProgress.bar, progressbar: new optional update_frequency parameter for '    
 'less frequent updates.\n'    
 '\n'    
 '*Release 20200718*:\n'    
 '* Readability improvement for default status line.\n'    
 '* progressbar: default units_scale=UNSCALED_SCALE.\n'    
 '\n'    
 '*Release 20200716.1*:\n'    
 'BaseProgress.status: round throughput to an int if >=10.\n'    
 '\n'    
 '*Release 20200716*:\n'    
 '* BaseProgress.status: distinguish "idle" (position >= total) from "stalled" '    
 '(position < total).\n'    
 '* BaseProgress.status: make the status very short if the progress is idle.\n'    
 '\n'    
 '*Release 20200627*:\n'    
 '* BaseProgress.status: handle throughput=None (before any activity).\n'    
 '* BaseProgress: drop count_of_total_bytes_text, superceded by format_counter '    
 '(which honours the units_scale).\n'    
 '\n'    
 '*Release 20200626*:\n'    
 '* New Progress.bar generator method iterating over an iterable while '    
 'displaying a progress bar.\n'    
 '* New convenience function progressbar(it,...) which rolls its own Progress '    
 'instance.\n'    
 '* Progress: always support a throughput window, default to '    
 'DEFAULT_THROUGHPUT_WINDOW = 5s.\n'    
 '* Improve the default progress bar render returned by Progress.status().\n'    
 '\n'    
 '*Release 20200613*:\n'    
 '* BaseProgress, Progress and OverProgress now accept an optional '    
 'units_scale, such as cs.units.UNSCALED_SCALE, to use when expressing '    
 'progress - the default remains BINARY_SCALE.\n'    
 '* New arrow(), format_counter() and text_pos_of_total() methods to produce '    
 'components of the status string for tuning or external reuse.\n'    
 '\n'    
 '*Release 20200520*:\n'    
 'OverProgress: throughput and eta implementations.\n'    
 '\n'    
 '*Release 20200129.3*:\n'    
 'Test __version__ machinery again.\n'    
 '\n'    
 '*Release 20200129.2*:\n'    
 "set __version__ to '20200129.2'\n"    
 '\n'    
 '*Release 20200129.1*:\n'    
 'Dummy release to test new __version__.\n'    
 '\n'    
 '*Release 20200129*:\n'    
 'New Progress.count_of_total_bytes_text property presenting "3kB/40MB" style '    
 'text.\n'    
 '\n'    
 '*Release 20190812*:\n'    
 '* New OverProgress class which is a composite of a set of subsidiary '    
 'Progress instances.\n'    
 '* Assorted other small updates.\n'    
 '\n'    
 '*Release 20190220*:\n'    
 '* Progress: be somewhat like an int.\n'    
 '* New status() method returning a convenient one line progress status '    
 'report.\n'    
 '\n'    
 '*Release 20180703.2*:\n'    
 'Progress: make .total into a property in order to fire the update '    
 'notifications.\n'    
 '\n'    
 '*Release 20180703.1*:\n'    
 'Progress: additions and changes to API: new .ratio, .elapsed_time, rename '    
 '.projected to .remaining_time.\n'    
 '\n'    
 '*Release 20180703*:\n'    
 'Initial release of cs.progress.'),
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  install_requires = ['cs.deco', 'cs.logutils', 'cs.py.func', 'cs.seq', 'cs.units', 'cs.upd'],
  keywords = ['python2', 'python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.progress'],
)
