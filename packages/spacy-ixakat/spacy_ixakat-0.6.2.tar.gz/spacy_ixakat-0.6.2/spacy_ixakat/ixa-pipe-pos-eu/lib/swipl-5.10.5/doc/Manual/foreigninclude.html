<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.10.5 Reference Manual: Section 9.4</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=summary HREF="summary.html">
<LINK REL=previous HREF="foreigntypes.html">
<LINK REL=next HREF="plld.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="summary.html"><IMG SRC="info.gif" BORDER=0 ALT="Summary"></A>
<A class="nav" href="foreigntypes.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="plld.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:9.4"><SPAN class="sec-nr">9.4</SPAN> <SPAN class="sec-title">The 
Foreign Include File</SPAN></A></H2>

<A NAME="sec:foreigninclude"></A>

<H3><A NAME="sec:9.4.1"><SPAN class="sec-nr">9.4.1</SPAN> <SPAN class="sec-title">Argument 
Passing and Control</SPAN></A></H3>

<P>If Prolog encounters a foreign predicate at run time it will call a 
function specified in the predicate definition of the foreign predicate. 
The arguments <VAR>1, ... , &lt;<VAR>arity</VAR>&gt;</VAR> pass the 
Prolog arguments to the goal as Prolog terms. Foreign functions should 
be declared of type
<CODE>foreign_t</CODE>. Deterministic foreign functions have two 
alternatives to return control back to Prolog:

<DL class="latex">
<DT class="pubdef"><A NAME="PL_succeed()"><VAR>(return) foreign_t</VAR> <STRONG>PL_succeed</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Succeed deterministically. PL_succeed is defined as
<CODE>return <CODE>TRUE</CODE></CODE>.
</DD>
<DT class="pubdef"><A NAME="PL_fail()"><VAR>(return) foreign_t</VAR> <STRONG>PL_fail</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Fail and start Prolog backtracking. PL_fail is defined as <CODE>return <CODE>FALSE</CODE></CODE>.
</DD>
</DL>

<H4><A NAME="sec:9.4.1.1"><SPAN class="sec-nr">9.4.1.1</SPAN> <SPAN class="sec-title">Non-deterministic 
Foreign Predicates</SPAN></A></H4>

<A NAME="sec:foreignnondet"></A>

<P>By default foreign predicates are deterministic. Using the
<CODE>PL_FA_NONDETERMINISTIC</CODE> attribute (see <A class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</A>) 
it is possible to register a predicate as a non-deterministic predicate. 
Writing non-deterministic foreign predicates is slightly more 
complicated as the foreign function needs context information for 
generating the next solution. Note that the same foreign function should 
be prepared to be simultaneously active in more than one goal. Suppose 
the natural_number_below_n/2 is a non-deterministic foreign predicate, 
backtracking over all natural numbers lower than the first argument. Now 
consider the following predicate:

<PRE class="code">
quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.
</PRE>

<P>In this predicate the function natural_number_below_n/2 
simultaneously generates solutions for both its invocations.

<P>Non-deterministic foreign functions should be prepared to handle 
three different calls from Prolog:

<P>
<UL class="latex">
<LI><I>Initial call (<CODE>PL_FIRST_CALL</CODE>)</I><BR>
Prolog has just created a frame for the foreign function and asks it to 
produce the first answer.
<LI><I>Redo call (<CODE>PL_REDO</CODE>)</I><BR>
The previous invocation of the foreign function associated with the 
current goal indicated it was possible to backtrack. The foreign 
function should produce the next solution.
<LI><I>Terminate call (<CODE>PL_PRUNED</CODE>)</I><BR>
The choice point left by the foreign function has been destroyed by a 
cut. The foreign function is given the opportunity to clean the 
environment.
</UL>

<P>Both the context information and the type of call is provided by an 
argument of type <CODE>control_t</CODE> appended to the argument list 
for deterministic foreign functions. The macro <A class="func" href="foreigninclude.html#PL_foreign_control()">PL_foreign_control()</A> 
extracts the type of call from the control argument. The foreign 
function can pass a context handle using the <TT>PL_retry*()</TT> macros 
and extract the handle from the extra argument using the
<TT>PL_foreign_context*()</TT> macro.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_retry()"><VAR>(return) foreign_t</VAR> <STRONG>PL_retry</STRONG>(<VAR>intptr_t 
value</VAR>)</A></DT>
<DD class="defbody">
The foreign function succeeds while leaving a choice point. On 
backtracking over this goal the foreign function will be called again, 
but the control argument now indicates it is a `Redo' call and the macro <A class="func" href="foreigninclude.html#PL_foreign_context()">PL_foreign_context()</A> 
returns the handle passed via
<A class="func" href="foreigninclude.html#PL_retry()">PL_retry()</A>. 
This handle is a two bits smaller than a pointer (30 or 62 bits) signed 
value (two bits are used for status indication). Defined as <CODE>return 
_<A class="func" href="foreigninclude.html#PL_retry()">PL_retry(n)</A></CODE>. 
See also <A class="func" href="foreigninclude.html#PL_succeed()">PL_succeed()</A>.</DD>
<DT class="pubdef"><A NAME="PL_retry_address()"><VAR>(return) foreign_t</VAR> <STRONG>PL_retry_address</STRONG>(<VAR>void 
*</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_retry()">PL_retry()</A>, 
but ensures an address as returned by malloc() is correctly recovered by <A class="func" href="foreigninclude.html#PL_foreign_context_address()">PL_foreign_context_address()</A>. 
Defined as <CODE>return _<A class="func" href="foreigninclude.html#PL_retry_address()">PL_retry_address(n)</A></CODE>. 
See also
<A class="func" href="foreigninclude.html#PL_succeed()">PL_succeed()</A>.</DD>
<DT class="pubdef"><A NAME="PL_foreign_control()"><VAR>int</VAR> <STRONG>PL_foreign_control</STRONG>(<VAR>control_t</VAR>)</A></DT>
<DD class="defbody">
Extracts the type of call from the control argument. The return values 
are described above. Note that the function should be prepared to handle 
the <CODE>PL_PRUNED</CODE> case and should be aware that the other 
arguments are not valid in this case.</DD>
<DT class="pubdef"><A NAME="PL_foreign_context()"><VAR>intptr_t</VAR> <STRONG>PL_foreign_context</STRONG>(<VAR>control_t</VAR>)</A></DT>
<DD class="defbody">
Extracts the context from the context argument. In the call type is
<CODE>PL_FIRST_CALL</CODE> the context value is 0L. Otherwise it is the 
value returned by the last <A class="func" href="foreigninclude.html#PL_retry()">PL_retry()</A> 
associated with this goal (both if the call type is <CODE>PL_REDO</CODE> 
as <CODE>PL_PRUNED</CODE>).</DD>
<DT class="pubdef"><A NAME="PL_foreign_context_address()"><VAR>void *</VAR> <STRONG>PL_foreign_context_address</STRONG>(<VAR>control_t</VAR>)</A></DT>
<DD class="defbody">
Extracts an address as passed in by <A class="func" href="foreigninclude.html#PL_retry_address()">PL_retry_address()</A>.
</DD>
</DL>

<P>Note: If a non-deterministic foreign function returns using 
PL_succeed or PL_fail, Prolog assumes the foreign function has cleaned 
its environment. <B>No</B> call with control argument <CODE>PL_PRUNED</CODE> 
will follow.

<P>The code of <A class="fig" href="foreigninclude.html#fig:nondetermf">figure 
6</A> shows a skeleton for a non-deterministic foreign predicate 
definition.

<PRE class="code">
typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, control_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
        ...
        PL_retry_address(ctxt);
    case PL_REDO:
        ctxt = PL_foreign_context_address(handle);
        ...
        PL_retry_address(ctxt);
    case PL_PRUNED:
        ctxt = PL_foreign_context_address(handle);
        ...
        free(ctxt);
        PL_succeed;
  }
}
</PRE>

<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Figure 6 : </B>Skeleton for non-deterministic foreign functions</TABLE>

<A NAME="fig:nondetermf"></A>

<H3><A NAME="sec:9.4.2"><SPAN class="sec-nr">9.4.2</SPAN> <SPAN class="sec-title">Atoms 
and functors</SPAN></A></H3>

<P>The following functions provide for communication using atoms and 
functors.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_new_atom()"><VAR>atom_t</VAR> <STRONG>PL_new_atom</STRONG>(<VAR>const 
char *</VAR>)</A></DT>
<DD class="defbody">
Return an atom handle for the given C-string. This function always 
succeeds. The returned handle is valid as long as the atom is referenced 
(see <A class="sec" href="foreigninclude.html">section 9.4.2.1</A>).</DD>
<DT class="pubdef"><A NAME="PL_atom_chars()"><VAR>const char*</VAR> <STRONG>PL_atom_chars</STRONG>(<VAR>atom_t 
atom</VAR>)</A></DT>
<DD class="defbody">
Return a C-string for the text represented by the given atom. The 
returned text will not be changed by Prolog. It is not allowed to modify 
the contents, not even `temporary' as the string may reside in read-only 
memory. The returned string becomes invalid if the atom is 
garbage-collected (see <A class="sec" href="foreigninclude.html">section 
9.4.2.1</A>). Foreign functions that require the text from an atom 
passed in a <CODE>term_t</CODE> normally use
<A class="func" href="foreigninclude.html#PL_get_atom_chars()">PL_get_atom_chars()</A> 
or <A class="func" href="foreigninclude.html#PL_get_atom_nchars()">PL_get_atom_nchars()</A>.</DD>
<DT class="pubdef"><A NAME="PL_new_functor()"><VAR>functor_t</VAR> <STRONG>PL_new_functor</STRONG>(<VAR>atom_t 
name, int arity</VAR>)</A></DT>
<DD class="defbody">
Returns a <EM>functor identifier</EM>, a handle for the name/arity pair. 
The returned handle is valid for the entire Prolog session.
</DD>
<DT class="pubdef"><A NAME="PL_functor_name()"><VAR>atom_t</VAR> <STRONG>PL_functor_name</STRONG>(<VAR>functor_t 
f</VAR>)</A></DT>
<DD class="defbody">
Return an atom representing the name of the given functor.
</DD>
<DT class="pubdef"><A NAME="PL_functor_arity()"><VAR>int</VAR> <STRONG>PL_functor_arity</STRONG>(<VAR>functor_t 
f</VAR>)</A></DT>
<DD class="defbody">
Return the arity of the given functor.
</DD>
</DL>

<H4><A NAME="sec:9.4.2.1"><SPAN class="sec-nr">9.4.2.1</SPAN> <SPAN class="sec-title">Atoms 
and atom-garbage collection</SPAN></A></H4>

<A NAME="sec:atomgc"></A>

<P>With the introduction of atom-garbage collection in version 3.3.0, 
atoms no longer live as long as the process. Instead, their lifetime is 
guaranteed only as long as they are referenced. In the single-threaded 
version, atom garbage collections are only invoked at the
<EM>call-port</EM>. In the multi-threaded version (see <A class="sec" href="threads.html">section 
8</A>), they appear asynchronously, except for the invoking thread.

<P>For dealing with atom garbage collection, two additional functions 
are provided:

<DL class="latex">
<DT class="pubdef"><A NAME="PL_register_atom()"><VAR>void</VAR> <STRONG>PL_register_atom</STRONG>(<VAR>atom_t 
atom</VAR>)</A></DT>
<DD class="defbody">
Increment the reference count of the atom by one. <A class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</A> 
performs this automatically, returning an atom with a reference count of 
at least one.<SUP class="fn">87<SPAN class="fn-text">Otherwise 
asynchronous atom garbage collection might destroy the atom before it is 
used.</SPAN></SUP></DD>
<DT class="pubdef"><A NAME="PL_unregister_atom()"><VAR>void</VAR> <STRONG>PL_unregister_atom</STRONG>(<VAR>atom_t 
atom</VAR>)</A></DT>
<DD class="defbody">
Decrement the reference count of the atom. If the reference-count drops 
below zero, an assertion error is raised.
</DD>
</DL>

<P>Please note that the following two calls are different with respect 
to atom garbage collection:

<PRE class="code">
PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));
</PRE>

<P>The latter increments the reference count of the atom <CODE>text</CODE>, 
which effectively ensures the atom will never be collected. It is 
advised to use the *_chars() or *_nchars() functions whenever 
applicable.

<H3><A NAME="sec:9.4.3"><SPAN class="sec-nr">9.4.3</SPAN> <SPAN class="sec-title">Analysing 
Terms via the Foreign Interface</SPAN></A></H3>

<P>Each argument of a foreign function (except for the control argument) 
is of type <CODE>term_t</CODE>, an opaque handle to a Prolog term. Three 
groups of functions are available for the analysis of terms. The first 
just validates the type, like the Prolog predicates <A NAME="idx:var1:1489"></A><A class="pred" href="typetest.html#var/1">var/1</A>, <A NAME="idx:atom1:1490"></A><A class="pred" href="typetest.html#atom/1">atom/1</A>, 
etc and are called <TT>PL_is_*()</TT>. The second group attempts to 
translate the argument into a C primitive type. These predicates take a <CODE>term_t</CODE> 
and a pointer to the appropriate C-type and return <CODE>TRUE</CODE> or
<CODE>FALSE</CODE> depending on successful or unsuccessful translation. 
If the translation fails, the pointed-to data is never modified.

<H4><A NAME="sec:9.4.3.1"><SPAN class="sec-nr">9.4.3.1</SPAN> <SPAN class="sec-title">Testing 
the type of a term</SPAN></A></H4>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_term_type()"><VAR>int</VAR> <STRONG>PL_term_type</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Obtain the type of a term, which should be a term returned by one of the 
other interface predicates or passed as an argument. The function 
returns the type of the Prolog term. The type identifiers are listed 
below. Note that the extraction functions <TT>PL_ge_t*()</TT> also 
validate the type and thus the two sections below are equivalent.

<PRE class="code">
        if ( PL_is_atom(t) )
        { char *s;

          PL_get_atom_chars(t, &amp;s);
          ...;
        }

or

        char *s;
        if ( PL_get_atom_chars(t, &amp;s) )
        { ...;
        }
</PRE>

<P>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>PL_VARIABLE</CODE> </TD><TD>An unbound 
variable. The value of term as such is a unique identifier for the 
variable. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ATOM</CODE> </TD><TD>A Prolog atom. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_STRING</CODE> </TD><TD>A Prolog string. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_INTEGER</CODE> </TD><TD>A Prolog integer. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_FLOAT</CODE> </TD><TD>A Prolog floating 
point number. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_TERM</CODE> </TD><TD>A compound term. Note 
that a list is a compound term <CODE><CODE>.</CODE>/2</CODE>. </TD></TR>
</TABLE>

</DD>
</DL>

<P>The functions PL_is_&lt;<VAR>type</VAR>&gt; are an alternative to <A class="func" href="foreigninclude.html#PL_term_type()">PL_term_type()</A>. 
The test <CODE><A class="func" href="foreigninclude.html#PL_is_variable()">PL_is_variable(term)</A></CODE> 
is equivalent to
<CODE><A class="func" href="foreigninclude.html#PL_term_type()">PL_term_type(term)</A> 
== PL_VARIABLE</CODE>, but the first is considerably faster. On the 
other hand, using a switch over <A class="func" href="foreigninclude.html#PL_term_type()">PL_term_type()</A> 
is faster and more readable then using an if-then-else using the 
functions below. All these functions return either <CODE>TRUE</CODE> or <CODE>FALSE</CODE>.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_is_variable()"><VAR>int</VAR> <STRONG>PL_is_variable</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a variable.
</DD>
<DT class="pubdef"><A NAME="PL_is_ground()"><VAR>int</VAR> <STRONG>PL_is_ground</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a ground term. See also <A NAME="idx:ground1:1491"></A><A class="pred" href="typetest.html#ground/1">ground/1</A>. 
This function is cycle-safe.
</DD>
<DT class="pubdef"><A NAME="PL_is_atom()"><VAR>int</VAR> <STRONG>PL_is_atom</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is an atom.
</DD>
<DT class="pubdef"><A NAME="PL_is_string()"><VAR>int</VAR> <STRONG>PL_is_string</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a string.
</DD>
<DT class="pubdef"><A NAME="PL_is_integer()"><VAR>int</VAR> <STRONG>PL_is_integer</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is an integer.
</DD>
<DT class="pubdef"><A NAME="PL_is_float()"><VAR>int</VAR> <STRONG>PL_is_float</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a float.
</DD>
<DT class="pubdef"><A NAME="PL_is_compound()"><VAR>int</VAR> <STRONG>PL_is_compound</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a compound term.
</DD>
<DT class="pubdef"><A NAME="PL_is_functor()"><VAR>int</VAR> <STRONG>PL_is_functor</STRONG>(<VAR>term_t, 
functor_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is compound and its functor is <VAR>functor</VAR>. 
This test is equivalent to <A class="func" href="foreigninclude.html#PL_get_functor()">PL_get_functor()</A>, 
followed by testing the functor, but easier to write and faster.
</DD>
<DT class="pubdef"><A NAME="PL_is_list()"><VAR>int</VAR> <STRONG>PL_is_list</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a compound term with functor ./2 
or the atom <CODE>[]</CODE>. See also <A class="func" href="foreigninclude.html#PL_is_pair()">PL_is_pair()</A> 
and <A class="func" href="foreigninclude.html#PL_skip_list()">PL_skip_list()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_is_pair()"><VAR>int</VAR> <STRONG>PL_is_pair</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is a compound term with functor ./2. 
See also <A class="func" href="foreigninclude.html#PL_is_list()">PL_is_list()</A> 
and <A class="func" href="foreigninclude.html#PL_skip_list()">PL_skip_list()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_is_atomic()"><VAR>int</VAR> <STRONG>PL_is_atomic</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is atomic (not variable or 
compound).
</DD>
<DT class="pubdef"><A NAME="PL_is_number()"><VAR>int</VAR> <STRONG>PL_is_number</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is an integer or float.
</DD>
<DT class="pubdef"><A NAME="PL_is_acyclic()"><VAR>int</VAR> <STRONG>PL_is_acyclic</STRONG>(<VAR>term_t</VAR>)</A></DT>
<DD class="defbody">
Returns non-zero if <VAR>term</VAR> is acyclic (i.e. a finite tree).
</DD>
</DL>

<H4><A NAME="sec:9.4.3.2"><SPAN class="sec-nr">9.4.3.2</SPAN> <SPAN class="sec-title">Reading 
data from a term</SPAN></A></H4>

<P>The functions <TT>PL_get_*()</TT> read information from a Prolog 
term. Most of them take two arguments. The first is the input term and 
the second is a pointer to the output value or a term-reference.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_atom()"><VAR>int</VAR> <STRONG>PL_get_atom</STRONG>(<VAR>term_t 
+t, atom_t *a</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is an atom, store the unique atom identifier over <VAR>a</VAR>. 
See also <A class="func" href="foreigninclude.html#PL_atom_chars()">PL_atom_chars()</A> 
and <A class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</A>. 
If there is no need to access the data (characters) of an atom, it is 
advised to manipulate atoms using their handle. As the atom is 
referenced by <VAR>t</VAR>, it will live at least as long as <VAR>t</VAR> 
does. If longer live-time is required, the atom should be locked using <A class="func" href="foreigninclude.html#PL_register_atom()">PL_register_atom()</A>.</DD>
<DT class="pubdef"><A NAME="PL_get_atom_chars()"><VAR>int</VAR> <STRONG>PL_get_atom_chars</STRONG>(<VAR>term_t 
+t, char **s</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is an atom, store a pointer to a 0-terminated C-string 
in
<VAR>s</VAR>. It is explicitly <STRONG>not</STRONG> allowed to modify 
the contents of this string. Some built-in atoms may have the string 
allocated in read-only memory, so `temporary manipulation' can cause an 
error.</DD>
<DT class="pubdef"><A NAME="PL_get_string_chars()"><VAR>int</VAR> <STRONG>PL_get_string_chars</STRONG>(<VAR>term_t 
+t, char **s, int *len</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a string object, store a pointer to a 0-terminated 
C-string in <VAR>s</VAR> and the length of the string in <VAR>len</VAR>. 
Note that this pointer is invalidated by backtracking, 
garbage-collection and stack-shifts, so generally the only save 
operations are to pass it immediately to a C-function that doesn't 
involve Prolog.</DD>
<DT class="pubdef"><A NAME="PL_get_chars()"><VAR>int</VAR> <STRONG>PL_get_chars</STRONG>(<VAR>term_t 
+t, char **s, unsigned flags</VAR>)</A></DT>
<DD class="defbody">
Convert the argument term <VAR>t</VAR> to a 0-terminated C-string. <EM>flags</EM> 
is a bitwise disjunction from two groups of constants. The first 
specifies which term-types should converted and the second how the 
argument is stored. Below is a specification of these constants. <CODE>BUF_RING</CODE> 
implies, if the data is not static (as from an atom), the data is copied 
to the next buffer from a ring of 16 buffers. This is a convenient way 
of converting multiple arguments passed to a foreign predicate to 
C-strings. If BUF_MALLOC is used, the data must be freed using <A class="func" href="foreignnotes.html#PL_free()">PL_free()</A> 
when not needed any longer.

<P>With the introduction of wide-characters (see <A class="sec" href="widechars.html">section 
2.17.1</A>), not all atoms can be converted into a <CODE>char*</CODE>. 
This function fails if <VAR>t</VAR> is of the wrong type, but also if 
the text cannot be represented. See the <CODE>REP_*</CODE> flags below 
for details.

<P>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>CVT_ATOM</CODE> </TD><TD>Convert if term is an 
atom </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_STRING</CODE> </TD><TD>Convert if term is a 
string </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_LIST</CODE> </TD><TD>Convert if term is a 
list of integers between 1 and 255 </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_INTEGER</CODE> </TD><TD>Convert if term is 
an integer (using <CODE>%d</CODE>) </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_FLOAT</CODE> </TD><TD>Convert if term is a 
float (using <CODE>%f</CODE>) </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_NUMBER</CODE> </TD><TD>Convert if term is a 
integer or float </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_ATOMIC</CODE> </TD><TD>Convert if term is 
atomic </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_VARIABLE</CODE></TD><TD>Convert variable to 
print-name </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_WRITE</CODE> </TD><TD>Convert any term that 
is not converted by any of the other flags using <A NAME="idx:write1:1492"></A><A class="pred" href="termrw.html#write/1">write/1</A>. 
If no <CODE>BUF_*</CODE> is provided, <CODE>BUF_RING</CODE> is implied. </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_WRITE_CANINICAL</CODE> </TD><TD>As 
CVT_WRITE, but use <A NAME="idx:writecanonical2:1493"></A><A class="pred" href="termrw.html#write_canonical/2">write_canonical/2</A>. </TD></TR>
<TR VALIGN=top><TD><CODE>CVT_ALL</CODE> </TD><TD>Convert if term is any 
of the above, except for
<CODE>CVT_VARIABLE</CODE> and <CODE>CVT_WRITE</CODE> </TD></TR>
<TBODY>
<TR VALIGN=top><TD><CODE>CVT_EXCEPTION</CODE></TD><TD>If conversion 
fails due to a type error, raise a Prolog type error exception in 
addition to failure </TD></TR>
<TBODY>
<TR VALIGN=top><TD><CODE>BUF_DISCARDABLE</CODE> </TD><TD>Data must 
copied immediately </TD></TR>
<TR VALIGN=top><TD><CODE>BUF_RING</CODE> </TD><TD>Data is stored in a 
ring of buffers </TD></TR>
<TR VALIGN=top><TD><CODE>BUF_MALLOC</CODE> </TD><TD>Data is copied to a 
new buffer returned by
<STRONG>PL_malloc</STRONG>(3). When no longer needed the user must call <A class="func" href="foreignnotes.html#PL_free()">PL_free()</A> 
on the data. </TD></TR>
<TBODY>
<TR VALIGN=top><TD><CODE>REP_ISO_LATIN_1</CODE> </TD><TD>(0, default). 
Text is in ISO Latin-1 encoding and the call fails if text cannot be 
represented. </TD></TR>
<TR VALIGN=top><TD><CODE>REP_UTF8</CODE> </TD><TD>Convert the text to a 
UTF-8 string. This works for all text. </TD></TR>
<TR VALIGN=top><TD><CODE>REP_MB</CODE> </TD><TD>Convert to default 
locale-defined 8-bit string. Success depends on the locale. Conversion 
is done using the wcrtomb() C-library function. </TD></TR>
</TABLE>

</DD>
<DT class="pubdef"><A NAME="PL_get_list_chars()"><VAR>int</VAR> <STRONG>PL_get_list_chars</STRONG>(<VAR>+term_t 
l, char **s, unsigned flags</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE><A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars(<VAR>l</VAR>, <VAR>s</VAR>, 
CVT_LIST|<VAR>flags</VAR>)</A></CODE>, provided <VAR>flags</VAR> 
contains no of the <TT>CVT_*</TT> flags.
</DD>
<DT class="pubdef"><A NAME="PL_get_integer()"><VAR>int</VAR> <STRONG>PL_get_integer</STRONG>(<VAR>+term_t 
t, int *i</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a Prolog integer, assign its value over <VAR>i</VAR>. 
On 32-bit machines, this is the same as <A class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</A>, 
but avoids a warning from the compiler. See also <A class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</A>.</DD>
<DT class="pubdef"><A NAME="PL_get_long()"><VAR>int</VAR> <STRONG>PL_get_long</STRONG>(<VAR>term_t 
+t, long *i</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a Prolog integer that can be represented as a long, 
assign its value over <VAR>i</VAR>. If <VAR>t</VAR> is an integer that 
cannot be represented by a C long, this function returns <CODE>FALSE</CODE>. 
If <VAR>t</VAR> is a floating point number that can be represented as a 
long, this function succeeds as well. See also PL_get_int64()</DD>
<DT class="pubdef"><A NAME="PL_get_int64()"><VAR>int</VAR> <STRONG>PL_get_int64</STRONG>(<VAR>term_t 
+t, int64_t *i</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a Prolog integer or float that can be represented as 
a
<CODE>int64_t</CODE>, assign its value over <VAR>i</VAR>. Currently all 
Prolog integers can be represented using this type, but this might 
change if SWI-Prolog introduces unbounded integers.</DD>
<DT class="pubdef"><A NAME="PL_get_intptr()"><VAR>int</VAR> <STRONG>PL_get_intptr</STRONG>(<VAR>term_t 
+t, intptr_t *i</VAR>)</A></DT>
<DD class="defbody">
Get an integer that is at least as wide a as a pointer. On most 
platforms this is the same as <A class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</A>, 
but on Win64 pointers are 8 bytes and longs only 4. Unlike <A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A>, 
the value is not modified.</DD>
<DT class="pubdef"><A NAME="PL_get_bool()"><VAR>int</VAR> <STRONG>PL_get_bool</STRONG>(<VAR>term_t 
+t, int *val</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> has the value <CODE>true</CODE> or <CODE>false</CODE>, 
set <VAR>val</VAR> to the C constant <CODE>TRUE</CODE> or <CODE>FALSE</CODE> 
and return success. otherwise return failure.
</DD>
<DT class="pubdef"><A NAME="PL_get_pointer()"><VAR>int</VAR> <STRONG>PL_get_pointer</STRONG>(<VAR>term_t 
+t, void **ptr</VAR>)</A></DT>
<DD class="defbody">
In the current system, pointers are represented by Prolog integers, but 
need some manipulation to make sure they do not get truncated due to the 
limited Prolog integer range. <A class="func" href="foreigninclude.html#PL_put_pointer()">PL_put_pointer()</A>/<A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A> 
guarantees pointers in the range of malloc() are handled without 
truncating.
</DD>
<DT class="pubdef"><A NAME="PL_get_float()"><VAR>int</VAR> <STRONG>PL_get_float</STRONG>(<VAR>term_t 
+t, double *f</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a float or integer, its value is assigned over <VAR>f</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_get_functor()"><VAR>int</VAR> <STRONG>PL_get_functor</STRONG>(<VAR>term_t 
+t, functor_t *f</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is compound or an atom, the Prolog representation of the 
name-arity pair will be assigned over <VAR>f</VAR>. See also
<A class="func" href="foreigninclude.html#PL_get_name_arity()">PL_get_name_arity()</A> 
and <A class="func" href="foreigninclude.html#PL_is_functor()">PL_is_functor()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_get_name_arity()"><VAR>int</VAR> <STRONG>PL_get_name_arity</STRONG>(<VAR>term_t 
+t, atom_t *name, int *arity</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is compound or an atom, the functor-name will be 
assigned over <VAR>name</VAR> and the arity over <VAR>arity</VAR>. See 
also
<A class="func" href="foreigninclude.html#PL_get_functor()">PL_get_functor()</A> 
and <A class="func" href="foreigninclude.html#PL_is_functor()">PL_is_functor()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_get_module()"><VAR>int</VAR> <STRONG>PL_get_module</STRONG>(<VAR>term_t 
+t, module_t *module</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is an atom, the system will lookup or create the 
corresponding module and assign an opaque pointer to it over <EM>module</EM>,.
</DD>
<DT class="pubdef"><A NAME="PL_get_arg()"><VAR>int</VAR> <STRONG>PL_get_arg</STRONG>(<VAR>int 
index, term_t +t, term_t -a</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is compound and index is between 1 and arity 
(including), assign <VAR>a</VAR> with a term-reference to the argument.
</DD>
<DT class="pubdef"><A NAME="_PL_get_arg()"><VAR>int</VAR> <STRONG>_PL_get_arg</STRONG>(<VAR>int 
index, term_t +t, term_t -a</VAR>)</A></DT>
<DD class="defbody">
Same as <A class="func" href="foreigninclude.html#PL_get_arg()">PL_get_arg()</A>, 
but no checking is performed, nor whether <VAR>t</VAR> is actually a 
term, nor whether <VAR>index</VAR> is a valid argument-index.
</DD>
</DL>

<H4><A NAME="sec:9.4.3.3"><SPAN class="sec-nr">9.4.3.3</SPAN> <SPAN class="sec-title">Exchanging 
text using length and string</SPAN></A></H4>

<P>All internal text-representation of SWI-Prolog is represented using
<CODE>char *</CODE> plus length and allow for <EM>0-bytes</EM> in them. 
The foreign library supports this by implementing a *_nchars() function 
for each applicable *_chars() function. Below we briefly present the 
signatures of these functions. For full documentation consult the 
*_chars() function.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_atom_nchars()"><VAR>int</VAR> <STRONG>PL_get_atom_nchars</STRONG>(<VAR>term_t 
t, size_t *len, char **s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_get_atom_chars()">PL_get_atom_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_get_list_nchars()"><VAR>int</VAR> <STRONG>PL_get_list_nchars</STRONG>(<VAR>term_t 
t, size_t *len, char **s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_get_list_chars()">PL_get_list_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_get_nchars()"><VAR>int</VAR> <STRONG>PL_get_nchars</STRONG>(<VAR>term_t 
t, size_t *len, char **s, unsigned int flags</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_atom_nchars()"><VAR>int</VAR> <STRONG>PL_put_atom_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_put_atom_chars()">PL_put_atom_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_string_nchars()"><VAR>int</VAR> <STRONG>PL_put_string_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_put_string_chars()">PL_put_string_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_list_ncodes()"><VAR>int</VAR> <STRONG>PL_put_list_ncodes</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <B>PL_put_list_codes()</B>.
</DD>
<DT class="pubdef"><A NAME="PL_put_list_nchars()"><VAR>int</VAR> <STRONG>PL_put_list_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_put_list_chars()">PL_put_list_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_atom_nchars()"><VAR>int</VAR> <STRONG>PL_unify_atom_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_string_nchars()"><VAR>int</VAR> <STRONG>PL_unify_string_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_unify_string_chars()">PL_unify_string_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_list_ncodes()"><VAR>int</VAR> <STRONG>PL_unify_list_ncodes</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <B>PL_unify_codes()</B>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_list_nchars()"><VAR>int</VAR> <STRONG>PL_unify_list_nchars</STRONG>(<VAR>term_t 
t, size_t len, const char *s</VAR>)</A></DT>
<DD class="defbody">
See <A class="func" href="foreigninclude.html#PL_unify_list_chars()">PL_unify_list_chars()</A>.
</DD>
</DL>

<P>In addition, the following functions are available for creating and 
inspecting atoms:

<DL class="latex">
<DT class="pubdef"><A NAME="PL_new_atom_nchars()"><VAR>atom_t</VAR> <STRONG>PL_new_atom_nchars</STRONG>(<VAR>size_t 
len, const char *s</VAR>)</A></DT>
<DD class="defbody">
Create a new atom as <A class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</A>, 
but from length and characters.
</DD>
<DT class="pubdef"><A NAME="PL_atom_nchars()"><VAR>const char *</VAR> <STRONG>PL_atom_nchars</STRONG>(<VAR>atom_t 
a, size_t *len</VAR>)</A></DT>
<DD class="defbody">
Extract text and length of an atom.
</DD>
</DL>

<H4><A NAME="sec:9.4.3.4"><SPAN class="sec-nr">9.4.3.4</SPAN> <SPAN class="sec-title">Wide 
character versions</SPAN></A></H4>

<P>Support for exchange of wide character strings is still under 
consideration. The functions dealing with 8-bit character strings return 
failure when operating on a wide character atom or Prolog string object. 
The functions below can extract and unify both 8-bit and wide atoms and 
string objects. Wide character strings are represented as C arrays of 
objects of the type <CODE>pl_wchar_t</CODE>, which is guaranteed to be 
the same as <CODE>wchar_t</CODE> on platforms supporting this type. For 
example, on MS-Windows, this represents 16-bit UCS2 characters, while 
using the GNU C library (glibc) this represents 32-bit UCS4 characters.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_new_atom_wchars()"><VAR>atom_t</VAR> <STRONG>PL_new_atom_wchars</STRONG>(<VAR>size_t 
len, const pl_wchar_t *s</VAR>)</A></DT>
<DD class="defbody">
Create atom from wide-character string as <A class="func" href="foreigninclude.html#PL_new_atom_nchars()">PL_new_atom_nchars()</A> 
does for ISO-Latin-1 strings. If <VAR>s</VAR> only contains ISO-Latin-1 
characters a normal byte-array atom is created.</DD>
<DT class="pubdef"><A NAME="PL_atom_wchars()"><VAR>pl_wchar_t*</VAR> <STRONG>PL_atom_wchars</STRONG>(<VAR>atom_t 
atom, int *len</VAR>)</A></DT>
<DD class="defbody">
Extract characters from a wide-character atom. Fails (returns
<CODE>NULL</CODE>) if <VAR>atom</VAR> is not a wide-character atom. This 
is the wide-character version of <A class="func" href="foreigninclude.html#PL_atom_nchars()">PL_atom_nchars()</A>. 
Note that only one of these functions succeeds on a particular atom. 
Especially, after creating an atom with <A class="func" href="foreigninclude.html#PL_new_atom_wchars()">PL_new_atom_wchars()</A>, 
extracting the text using
<A class="func" href="foreigninclude.html#PL_atom_wchars()">PL_atom_wchars()</A> 
will fail if the atom only contains ISO-Latin-1 characters.</DD>
<DT class="pubdef"><A NAME="PL_get_wchars()"><VAR>int</VAR> <STRONG>PL_get_wchars</STRONG>(<VAR>term_t 
t, size_t *len, pl_wchar_t **s, unsigned flags</VAR>)</A></DT>
<DD class="defbody">
Wide-character version of <A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A>. 
The <VAR>flags</VAR> argument is the same as for <A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A>.</DD>
<DT class="pubdef"><A NAME="PL_unify_wchars()"><VAR>int</VAR> <STRONG>PL_unify_wchars</STRONG>(<VAR>term_t 
t, int type, size_t len, const pl_wchar_t *s</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a textual representation of the C wide character 
array <VAR>s</VAR>. The <VAR>arg</VAR>type argument defines the Prolog 
representation and is one of <CODE>PL_ATOM</CODE>, <CODE>PL_STRING</CODE>,
<CODE>PL_CODE_LIST</CODE> or <CODE>PL_CHAR_LIST</CODE>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_wchars_diff()"><VAR>int</VAR> <STRONG>PL_unify_wchars_diff</STRONG>(<VAR>term_t 
+t, term_t -tail, int type, size_t len, const pl_wchar_t *s</VAR>)</A></DT>
<DD class="defbody">
Difference list version of <A class="func" href="foreigninclude.html#PL_unify_wchars()">PL_unify_wchars()</A>, 
only supporting the types <CODE>PL_CODE_LIST</CODE> and <CODE>PL_CHAR_LIST</CODE>. 
It serves two purposes. It allows for returning very long lists from 
data read from a stream without the need for a resizing buffer in C. 
Also, the use of difference lists is often practical for further 
processing in Prolog. Examples can be found in <CODE>packages/clib/readutil.c</CODE> 
from the source distribution.
</DD>
</DL>

<H4><A NAME="sec:9.4.3.5"><SPAN class="sec-nr">9.4.3.5</SPAN> <SPAN class="sec-title">Reading 
a list</SPAN></A></H4>

<P>The functions from this section are intended to read a Prolog list 
from C. Suppose we expect a list of atoms, the following code will print 
the atoms, each on a line:

<PRE class="code">
foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();      /* variable for the elements */
  term_t list = PL_copy_term_ref(l);    /* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &amp;s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);              /* test end for [] */
}
</PRE>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_list()"><VAR>int</VAR> <STRONG>PL_get_list</STRONG>(<VAR>term_t 
+l, term_t -h, term_t -t</VAR>)</A></DT>
<DD class="defbody">
If <VAR>l</VAR> is a list and not <CODE>[]</CODE> assign a 
term-reference to the head to <VAR>h</VAR> and to the tail to <VAR>t</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_get_head()"><VAR>int</VAR> <STRONG>PL_get_head</STRONG>(<VAR>term_t 
+l, term_t -h</VAR>)</A></DT>
<DD class="defbody">
If <VAR>l</VAR> is a list and not <CODE>[]</CODE> assign a 
term-reference to the head to <VAR>h</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_get_tail()"><VAR>int</VAR> <STRONG>PL_get_tail</STRONG>(<VAR>term_t 
+l, term_t -t</VAR>)</A></DT>
<DD class="defbody">
If <VAR>l</VAR> is a list and not <CODE>[]</CODE> assign a 
term-reference to the tail to <VAR>t</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_get_nil()"><VAR>int</VAR> <STRONG>PL_get_nil</STRONG>(<VAR>term_t 
+l</VAR>)</A></DT>
<DD class="defbody">
Succeeds if <EM></EM> represents the atom <CODE>[]</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_skip_list()"><VAR>int</VAR> <STRONG>PL_skip_list</STRONG>(<VAR>term_t 
+list, term_t -tail, size_t *len</VAR>)</A></DT>
<DD class="defbody">
This is a multi-purpose function to deal with lists. It allows for 
finding the length of a list, checking whether something is a list, etc. 
The reference <VAR>tail</VAR> is set to point to the end of the list,
<VAR>len</VAR> is filled with the number of list-cells skipped and the 
return-value indicates the status of the list:

<DL class="latex">
<DT><A NAME="PL_LIST"><STRONG>PL_LIST</STRONG></A></DT>
<DD class="defbody">
The list is a `proper' list: one that ends in <CODE>[]</CODE> and
<VAR>tail</VAR> is filled with <CODE>[]</CODE></DD>
<DT><A NAME="PL_PARTIAL_LIST"><STRONG>PL_PARTIAL_LIST</STRONG></A></DT>
<DD class="defbody">
The list is `partial' list: one that ends in a variable and
<VAR>tail</VAR> is a reference to this variable.</DD>
<DT><A NAME="PL_CYCLIC_TERM"><STRONG>PL_CYCLIC_TERM</STRONG></A></DT>
<DD class="defbody">
The list is cyclic (e.g. X = [a|X]). <VAR>tail</VAR> points to an 
arbitrary cell of the list and <VAR>len</VAR> is at most twice the 
cycle-length of the list.</DD>
<DT><A NAME="PL_NOT_A_LIST"><STRONG>PL_NOT_A_LIST</STRONG></A></DT>
<DD class="defbody">
The term <VAR>list</VAR> is not a list at all. <VAR>tail</VAR> is bound 
to the non-list term and <VAR>len</VAR> is set to the number of 
list-cells skipped.
</DD>
</DL>

<P>It is allowed to pass 0 for <VAR>tail</VAR> and <CODE>NULL</CODE> for <VAR>len</VAR>.
</DD>
</DL>

<H4><A NAME="sec:9.4.3.6"><SPAN class="sec-nr">9.4.3.6</SPAN> <SPAN class="sec-title">An 
example: defining write/1 in C</SPAN></A></H4>

<P><A class="fig" href="foreigninclude.html#fig:pl-display">Figure 7</A> 
shows a simplified definition of <A NAME="idx:write1:1495"></A><A class="pred" href="termrw.html#write/1">write/1</A> 
to illustrate the described functions. This simplified version does not 
deal with operators. It is called <A NAME="idx:display1:1496"></A><SPAN class="pred-ext">display/1</SPAN>, 
because it mimics closely the behaviour of this Edinburgh predicate.

<PRE class="code">
foreign_t
pl_display(term_t t)
{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:
    case PL_FLOAT:
      PL_get_chars(t, &amp;s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &amp;s, &amp;len);
      Sprintf("\"%s\"", s);
      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &amp;name, &amp;arity);
      Sprintf("%s(", PL_atom_chars(name));
      for(n=1; n&lt;=arity; n++)
      { PL_get_arg(n, t, a);
        if ( n &gt; 1 )
          Sprintf(", ");
        pl_display(a);
      }
      Sprintf(")");
      break;
    default:
      PL_fail;                          /* should not happen */
    }
  }

  PL_succeed;
}
</PRE>

<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Figure 7 : </B>A Foreign definition of <A NAME="idx:display1:1497"></A><SPAN class="pred-ext">display/1</SPAN></TABLE>

<A NAME="fig:pl-display"></A>

<H3><A NAME="sec:9.4.4"><SPAN class="sec-nr">9.4.4</SPAN> <SPAN class="sec-title">Constructing 
Terms</SPAN></A></H3>

<P>Terms can be constructed using functions from the <TT>PL_put_*()</TT> 
and
<TT>PL_cons_*()</TT> families. This approach builds the term 
`inside-out', starting at the leaves and subsequently creating compound 
terms. Alternatively, terms may be created `top-down', first creating a 
compound holding only variables and subsequently unifying the arguments. 
This section discusses functions for the first approach. This approach 
is generally used for creating arguments for <A class="func" href="foreigninclude.html#PL_call()">PL_call()</A> 
and PL_open_query.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_put_variable()"><VAR>void</VAR> <STRONG>PL_put_variable</STRONG>(<VAR>term_t 
-t</VAR>)</A></DT>
<DD class="defbody">
Put a fresh variable in the term, resetting the term-reference to its 
initial state.<SUP class="fn">88<SPAN class="fn-text">Older versions 
created a variable on the global stack.</SPAN></SUP>
</DD>
<DT class="pubdef"><A NAME="PL_put_atom()"><VAR>void</VAR> <STRONG>PL_put_atom</STRONG>(<VAR>term_t 
-t, atom_t a</VAR>)</A></DT>
<DD class="defbody">
Put an atom in the term reference from a handle. See also
<A class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</A> 
and <A class="func" href="foreigninclude.html#PL_atom_chars()">PL_atom_chars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_atom_chars()"><VAR>int</VAR> <STRONG>PL_put_atom_chars</STRONG>(<VAR>term_t 
-t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Put an atom in the term-reference constructed from the 0-terminated 
string. The string itself will never be referenced by Prolog after this 
function.
</DD>
<DT class="pubdef"><A NAME="PL_put_string_chars()"><VAR>int</VAR> <STRONG>PL_put_string_chars</STRONG>(<VAR>term_t 
-t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Put a zero-terminated string in the term-reference. The data will be 
copied. See also <A class="func" href="foreigninclude.html#PL_put_string_nchars()">PL_put_string_nchars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_string_nchars()"><VAR>int</VAR> <STRONG>PL_put_string_nchars</STRONG>(<VAR>term_t 
-t, size_t len, const char *chars</VAR>)</A></DT>
<DD class="defbody">

<P>Put a string, represented by a length/start pointer pair in the 
term-reference. The data will be copied. This interface can deal with 
0-bytes in the string. See also <A class="sec" href="foreigninclude.html">section 
9.4.20</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_list_chars()"><VAR>int</VAR> <STRONG>PL_put_list_chars</STRONG>(<VAR>term_t 
-t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Put a list of ASCII values in the term-reference.
</DD>
<DT class="pubdef"><A NAME="PL_put_integer()"><VAR>int</VAR> <STRONG>PL_put_integer</STRONG>(<VAR>term_t 
-t, long i</VAR>)</A></DT>
<DD class="defbody">
Put a Prolog integer in the term reference.
</DD>
<DT class="pubdef"><A NAME="PL_put_int64()"><VAR>int</VAR> <STRONG>PL_put_int64</STRONG>(<VAR>term_t 
-t, int64_t i</VAR>)</A></DT>
<DD class="defbody">
Put a Prolog integer in the term reference.
</DD>
<DT class="pubdef"><A NAME="PL_put_pointer()"><VAR>int</VAR> <STRONG>PL_put_pointer</STRONG>(<VAR>term_t 
-t, void *ptr</VAR>)</A></DT>
<DD class="defbody">
Put a Prolog integer in the term-reference. Provided ptr is in the 
`malloc()-area', <A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A> 
will get the pointer back.
</DD>
<DT class="pubdef"><A NAME="PL_put_float()"><VAR>int</VAR> <STRONG>PL_put_float</STRONG>(<VAR>term_t 
-t, double f</VAR>)</A></DT>
<DD class="defbody">
Put a floating-point value in the term-reference.
</DD>
<DT class="pubdef"><A NAME="PL_put_functor()"><VAR>int</VAR> <STRONG>PL_put_functor</STRONG>(<VAR>term_t 
-t, functor_t functor</VAR>)</A></DT>
<DD class="defbody">
Create a new compound term from <VAR>functor</VAR> and bind <VAR>t</VAR> 
to this term. All arguments of the term will be variables. To create a 
term with instantiated arguments, either instantiate the arguments using 
the <TT>PL_unify_*()</TT> functions or use <A class="func" href="foreigninclude.html#PL_cons_functor()">PL_cons_functor()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_put_list()"><VAR>int</VAR> <STRONG>PL_put_list</STRONG>(<VAR>term_t 
-l</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE><A class="func" href="foreigninclude.html#PL_put_functor()">PL_put_functor(l, 
PL_new_functor(PL_new_atom(".")</A>, 2))</CODE>.
</DD>
<DT class="pubdef"><A NAME="PL_put_nil()"><VAR>void</VAR> <STRONG>PL_put_nil</STRONG>(<VAR>term_t 
-l</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE><A class="func" href="foreigninclude.html#PL_put_atom_chars()">PL_put_atom_chars("[]")</A></CODE>.
</DD>
<DT class="pubdef"><A NAME="PL_put_term()"><VAR>void</VAR> <STRONG>PL_put_term</STRONG>(<VAR>term_t 
-t1, term_t +t2</VAR>)</A></DT>
<DD class="defbody">
Make <VAR>t1</VAR> point to the same term as <VAR>t2</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_cons_functor()"><VAR>int</VAR> <STRONG>PL_cons_functor</STRONG>(<VAR>term_t 
-h, functor_t f, ...</VAR>)</A></DT>
<DD class="defbody">
Create a term, whose arguments are filled from variable argument list 
holding the same number of term_t objects as the arity of the functor. 
To create the term <CODE>animal(gnu, 50)</CODE>, use:

<PRE class="code">
{ term_t a1 = PL_new_term_ref();
  term_t a2 = PL_new_term_ref();
  term_t t  = PL_new_term_ref();
  functor_t animal2;

  /* animal2 is a constant that may be bound to a global
     variable and re-used
  */
  animal2 = PL_new_functor(PL_new_atom("animal"), 2);

  PL_put_atom_chars(a1, "gnu");
  PL_put_integer(a2, 50);
  PL_cons_functor(t, animal2, a1, a2);
}
</PRE>

<P>After this sequence, the term-references <VAR>a1</VAR> and <VAR>a2</VAR> 
may be used for other purposes.
</DD>
<DT class="pubdef"><A NAME="PL_cons_functor_v()"><VAR>int</VAR> <STRONG>PL_cons_functor_v</STRONG>(<VAR>term_t 
-h, functor_t f, term_t a0</VAR>)</A></DT>
<DD class="defbody">
Creates a compound term like <A class="func" href="foreigninclude.html#PL_cons_functor()">PL_cons_functor()</A>, 
but <VAR>a0</VAR> is an array of term references as returned by <A class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs()</A>. 
The length of this array should match the number of arguments required 
by the functor.
</DD>
<DT class="pubdef"><A NAME="PL_cons_list()"><VAR>int</VAR> <STRONG>PL_cons_list</STRONG>(<VAR>term_t 
-l, term_t +h, term_t +t</VAR>)</A></DT>
<DD class="defbody">
Create a list (cons-) cell in <VAR>l</VAR> from the head and tail. The 
code below creates a list of atoms from a <CODE>char **</CODE>. The list 
is built tail-to-head. The <TT>PL_unify_*()</TT> functions can be used 
to build a list head-to-tail.

<PRE class="code">
void
put_list(term_t l, int n, char **words)
{ term_t a = PL_new_term_ref();

  PL_put_nil(l);
  while( --n &gt;= 0 )
  { PL_put_atom_chars(a, words[n]);
    PL_cons_list(l, a, l);
  }
}
</PRE>

<P>Note that <VAR>l</VAR> can be redefined within a <TT>PL_cons_list</TT> 
call as shown here because operationally its old value is consumed 
before its new value is set.
</DD>
</DL>

<H3><A NAME="sec:9.4.5"><SPAN class="sec-nr">9.4.5</SPAN> <SPAN class="sec-title">Unifying 
data</SPAN></A></H3>

<P>The functions of this sections <EM>unify</EM> terms with other terms 
or translated C-data structures. Except for <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A>, 
the functions of this section are specific to SWI-Prolog. They have been 
introduced because they shorten the code for returning data to Prolog 
and at the same time make this more efficient by avoiding the need to 
allocate temporary term-references and reduce the number of calls to the 
Prolog API. Consider the case where we want a foreign function to return 
the host name of the machine Prolog is running on. Using the <TT>PL_get_*()</TT> 
and <TT>PL_put_*()</TT> functions, the code becomes:

<PRE class="code">
foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, tmp);
  }

  PL_fail;
}
</PRE>

<P>Using <A class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</A>, 
this becomes:

<PRE class="code">
foreign_t
pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}
</PRE>

<P>Note that unification functions that perform multiple bindings may 
leave part of the bindings in case of failure. See <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A> 
for details.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_unify()"><VAR>int</VAR> <STRONG>PL_unify</STRONG>(<VAR>term_t 
?t1, term_t ?t2</VAR>)</A></DT>
<DD class="defbody">
Unify two Prolog terms and return <CODE>TRUE</CODE> on success.

<P>Care is needed if <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A> 
returns <CODE>FAIL</CODE> and the foreign function does not <EM>immediately</EM> 
return to Prolog with <CODE>FAIL</CODE>. Unification may perform 
multiple changes to either <VAR>t1</VAR> or <VAR>t2</VAR>. A failing 
unification may have created bindings before failure is detected. <EM>Already 
created bindings are not undone</EM>. For example, calling <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A> 
on <CODE>a(X, a)</CODE> and <CODE>a(c,b)</CODE> binds
<VAR>X</VAR> to <CODE>c</CODE> and fails when trying to unify <CODE>a</CODE> 
to
<CODE>b</CODE>. If control remains in C or even if we want to return 
success to Prolog, we <EM>must</EM> undo such bindings. This is achieved 
using
<A class="func" href="foreigninclude.html#PL_open_foreign_frame()">PL_open_foreign_frame()</A> 
and <A class="func" href="foreigninclude.html#PL_rewind_foreign_frame()">PL_rewind_foreign_frame()</A>, 
as show in the snippid below.

<PRE class="code">
    { fid_t fid = PL_open_foreign_frame();

      ...
      if ( !PL_unify(t1, t2) )
        PL_rewind_foreign_frame(fid);
      ...

      PL_close_foreign_frame(fid);
    }
</PRE>

<P>In addition, <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A> 
may have failed on an <B>exception</B>, typically a resource (stack) 
overflow. This can be tested using
<A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A>, 
passing 0 (zero) for the query-id argument. Foreign functions that 
encounter an exception must return <CODE>FAIL</CODE> to Prolog as soon 
as possible or call <B>PL_clear_exception()</B> if they wish to ignore 
the exception.</DD>
<DT class="pubdef"><A NAME="PL_unify_atom()"><VAR>int</VAR> <STRONG>PL_unify_atom</STRONG>(<VAR>term_t 
?t, atom_t a</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with the atom <VAR>a</VAR> and return non-zero on 
success.</DD>
<DT class="pubdef"><A NAME="PL_unify_bool()"><VAR>int</VAR> <STRONG>PL_unify_bool</STRONG>(<VAR>term_t 
?t, int a</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with either <CODE>true</CODE> or <CODE>false</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_unify_chars()"><VAR>int</VAR> <STRONG>PL_unify_chars</STRONG>(<VAR>term_t 
?t, int flags, size_t len, const char *chars</VAR>)</A></DT>
<DD class="defbody">
New function to deal with unification of <CODE>char*</CODE> with various 
encodings to a Prolog representation. The <VAR>flags</VAR> argument is a 
bitwise <EM>or</EM> specifying the Prolog target type and the encoding 
of
<VAR>chars</VAR>. Prolog types is one of <CODE>PL_ATOM</CODE>, <CODE>PL_STRING</CODE>,
<CODE>PL_CODE_LIST</CODE> or <CODE>PL_CHAR_LIST</CODE>. Representations 
is one of
<CODE>REP_ISO_LATIN_1</CODE>, <CODE>REP_UTF8</CODE> or <CODE>REP_MB</CODE>. 
See
<A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A> 
for a definition of the representation types. If
<VAR>len</VAR> is <CODE>-1</CODE> <VAR>chars</VAR> must be 0-terminated 
and the length is computed from <VAR>chars</VAR> using strlen().

<P>If <VAR>flags</VAR> includes <CODE>PL_DIFF_LIST</CODE> and type is 
one of
<CODE>PL_CODE_LIST</CODE> or <CODE>PL_CHAR_LIST</CODE>, the text is 
converted to a <EM>difference list</EM>. The tail of the difference list 
is
<VAR>t+1</VAR>.</DD>
<DT class="pubdef"><A NAME="PL_unify_atom_chars()"><VAR>int</VAR> <STRONG>PL_unify_atom_chars</STRONG>(<VAR>term_t 
?t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with an atom created from <VAR>chars</VAR> and return 
non-zero on success.</DD>
<DT class="pubdef"><A NAME="PL_unify_list_chars()"><VAR>int</VAR> <STRONG>PL_unify_list_chars</STRONG>(<VAR>term_t 
?t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a list of ASCII characters constructed from
<VAR>chars</VAR>.</DD>
<DT class="pubdef"><A NAME="PL_unify_string_chars()"><VAR>void</VAR> <STRONG>PL_unify_string_chars</STRONG>(<VAR>term_t 
?t, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog string object created from the 
zero-terminated string <VAR>chars</VAR>. The data will be copied. See 
also <A class="func" href="foreigninclude.html#PL_unify_string_nchars()">PL_unify_string_nchars()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_string_nchars()"><VAR>void</VAR> <STRONG>PL_unify_string_nchars</STRONG>(<VAR>term_t 
?t, size_t len, const char *chars</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog string object created from the string 
created from the <VAR>len</VAR>/<VAR>chars</VAR> pair. The data will be 
copied. This interface can deal with 0-bytes in the string. See also
<A class="sec" href="foreigninclude.html">section 9.4.20</A>.</DD>
<DT class="pubdef"><A NAME="PL_unify_integer()"><VAR>int</VAR> <STRONG>PL_unify_integer</STRONG>(<VAR>term_t 
?t, intptr_t n</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog integer from <VAR>n</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_int64()"><VAR>int</VAR> <STRONG>PL_unify_int64</STRONG>(<VAR>term_t 
?t, int64_t n</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog integer from <VAR>n</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_float()"><VAR>int</VAR> <STRONG>PL_unify_float</STRONG>(<VAR>term_t 
?t, double f</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog float from <VAR>f</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_pointer()"><VAR>int</VAR> <STRONG>PL_unify_pointer</STRONG>(<VAR>term_t 
?t, void *ptr</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a Prolog integer describing the pointer. See 
also
<A class="func" href="foreigninclude.html#PL_put_pointer()">PL_put_pointer()</A> 
and <A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_functor()"><VAR>int</VAR> <STRONG>PL_unify_functor</STRONG>(<VAR>term_t 
?t, functor_t f</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is a compound term with the given functor, just succeed. 
If it is unbound, create a term and bind the variable, else fails. Note 
that this function does not create a term if the argument is already 
instantiated.
</DD>
<DT class="pubdef"><A NAME="PL_unify_list()"><VAR>int</VAR> <STRONG>PL_unify_list</STRONG>(<VAR>term_t 
?l, term_t -h, term_t -t</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>l</VAR> with a list-cell (<TT>./2</TT>). If successful, write 
a reference to the head of the list to <VAR>h</VAR> and a reference to 
the tail of the list into <VAR>t</VAR>. This reference may be used for 
subsequent calls to this function. Suppose we want to return a list of 
atoms from a <CODE>char **</CODE>. We could use the example described by
<A class="func" href="foreigninclude.html#PL_put_list()">PL_put_list()</A>, 
followed by a call to <A class="func" href="foreigninclude.html#PL_unify()">PL_unify()</A>, 
or we can use the code below. If the predicate argument is unbound, the 
difference is minimal (the code based on <A class="func" href="foreigninclude.html#PL_put_list()">PL_put_list()</A> 
is probably slightly faster). If the argument is bound, the code below 
may fail before reaching the end of the word-list, but even if the 
unification succeeds, this code avoids a duplicate (garbage) list and a 
deep unification.

<PRE class="code">
foreign_t
pl_get_environ(term_t env)
{ term_t l = PL_copy_term_ref(env);
  term_t a = PL_new_term_ref();
  extern char **environ;
  char **e;

  for(e = environ; *e; e++)
  { if ( !PL_unify_list(l, a, l) ||
         !PL_unify_atom_chars(a, *e) )
      PL_fail;
  }

  return PL_unify_nil(l);
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_unify_nil()"><VAR>int</VAR> <STRONG>PL_unify_nil</STRONG>(<VAR>term_t 
?l</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>l</VAR> with the atom <CODE>[]</CODE>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_arg()"><VAR>int</VAR> <STRONG>PL_unify_arg</STRONG>(<VAR>int 
index, term_t ?t, term_t ?a</VAR>)</A></DT>
<DD class="defbody">
Unifies the <EM>index-th</EM> argument (1-based) of <VAR>t</VAR> with
<VAR>a</VAR>.
</DD>
<DT class="pubdef"><A NAME="PL_unify_term()"><VAR>int</VAR> <STRONG>PL_unify_term</STRONG>(<VAR>term_t 
?t, ...</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a (normally) compound term. The remaining 
arguments is a sequence of a type identifier, followed by the required 
arguments. This predicate is an extension to the Quintus and SICStus 
foreign interface from which the SWI-Prolog foreign interface has been 
derived, but has proved to be a powerful and comfortable way to create 
compound terms from C. Due to the vararg packing/unpacking and the 
required type-switching this interface is slightly slower than using the 
primitives. Please note that some bad C-compilers have fairly low limits 
on the number of arguments that may be passed to a function.

<P>Special attention is required when passing numbers. C `promotes' any 
integral smaller than <CODE>int</CODE> to <CODE>int</CODE>. I.e. the 
types
<CODE>char</CODE>, <CODE>short</CODE> and <CODE>int</CODE> are all 
passed as <CODE>int</CODE>. In addition, on most 32-bit platforms <CODE>int</CODE> 
and <CODE>long</CODE> are the same. Up-to version 4.0.5, only <CODE>PL_INTEGER</CODE> 
could be specified which was taken from the stack as <CODE>long</CODE>. 
Such code fails when passing small integral types on machines where <CODE>int</CODE> 
is smaller than <CODE>long</CODE>. It is advised to use <CODE>PL_SHORT</CODE>, <CODE>PL_INT</CODE> 
or <CODE>PL_LONG</CODE> as appropriate. Similar, C compilers promote
<CODE>float</CODE> to <CODE>double</CODE> and therefore <CODE>PL_FLOAT</CODE> 
and
<CODE>PL_DOUBLE</CODE> are synonyms.

<P>The type identifiers are:

<DL class="latex">
<DT><B><CODE>PL_VARIABLE</CODE> <VAR>none</VAR></B></DT>
<DD class="defbody">
No op. Used in arguments of <CODE>PL_FUNCTOR</CODE>.
</DD>
<DT><B><CODE>PL_BOOL</CODE> <VAR>int</VAR></B></DT>
<DD class="defbody">
Unify the argument with <CODE>true</CODE> or <CODE>false</CODE>.
</DD>
<DT><B><CODE>PL_ATOM</CODE> <VAR>atom_t</VAR></B></DT>
<DD class="defbody">
Unify the argument with an atom, as in <A class="func" href="foreigninclude.html#PL_unify_atom()">PL_unify_atom()</A>.
</DD>
<DT><B><CODE>PL_CHARS</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Unify the argument with an atom, constructed from the C <CODE>char *</CODE>, 
as in <A class="func" href="foreigninclude.html#PL_unify_atom_chars()">PL_unify_atom_chars()</A>.
</DD>
<DT><B><CODE>PL_NCHARS</CODE> <VAR>size_t, const char *</VAR></B></DT>
<DD class="defbody">
Unify the argument with an atom, constructed from length and
<CODE>char*</CODE> as in <A class="func" href="foreigninclude.html#PL_unify_atom_nchars()">PL_unify_atom_nchars()</A>.
</DD>
<DT><B><CODE>PL_UTF8_CHARS</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Create an atom from a UTF-8 string.
</DD>
<DT><B><CODE>PL_UTF8_STRING</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Create a packed string object from a UTF-8 string.
</DD>
<DT><B><CODE>PL_MBCHARS</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Create an atom from a multi-byte string in the current locale.
</DD>
<DT><B><CODE>PL_MBCODES</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Create a list of character codes from a multi-byte string in the current 
locale.
</DD>
<DT><B><CODE>PL_MBSTRING</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Create a packed string object from a multi-byte string in the current 
locale.
</DD>
<DT><B><CODE>PL_NWCHARS</CODE> <VAR>size_t, const wchar_t *</VAR></B></DT>
<DD class="defbody">
Create an atom from a length and a wide character pointer.
</DD>
<DT><B><CODE>PL_NWCODES</CODE> <VAR>size_t, const wchar_t *</VAR></B></DT>
<DD class="defbody">
Create an list of character codes from a length and a wide character 
pointer.
</DD>
<DT><B><CODE>PL_NWSTRING</CODE> <VAR>size_t, const wchar_t *</VAR></B></DT>
<DD class="defbody">
Create a packed string object from a length and a wide character 
pointer.
</DD>
<DT><B><CODE>PL_SHORT</CODE> <VAR>short</VAR></B></DT>
<DD class="defbody">
Unify the argument with an integer, as in <A class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</A>. 
As
<CODE>short</CODE> is promoted to <CODE>int</CODE>, <CODE>PL_SHORT</CODE> 
is a synonym for <CODE>PL_INT</CODE>.
</DD>
<DT><B><CODE>PL_INTEGER</CODE> <VAR>long</VAR></B></DT>
<DD class="defbody">
Unify the argument with an integer, as in <A class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</A>.
</DD>
<DT><B><CODE>PL_INT</CODE> <VAR>int</VAR></B></DT>
<DD class="defbody">
Unify the argument with an integer, as in <A class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</A>.
</DD>
<DT><B><CODE>PL_LONG</CODE> <VAR>long</VAR></B></DT>
<DD class="defbody">
Unify the argument with an integer, as in <A class="func" href="foreigninclude.html#PL_unify_integer()">PL_unify_integer()</A>.
</DD>
<DT><B><CODE>PL_INT64</CODE> <VAR>int64_t</VAR></B></DT>
<DD class="defbody">
Unify the argument with a 64-bit integer, as in PL_unify_int64().
</DD>
<DT><B><CODE>PL_INTPTR</CODE> <VAR>intptr_t</VAR></B></DT>
<DD class="defbody">
Unify the argument with an integer with the same width as a pointer. On 
most machines this is the same as <CODE>PL_LONG</CODE>. but on 64-bit 
MS-Windows pointers are 64-bit while longs are only 32-bits.
</DD>
<DT><B><CODE>PL_DOUBLE</CODE> <VAR>double</VAR></B></DT>
<DD class="defbody">
Unify the argument with a float, as in <A class="func" href="foreigninclude.html#PL_unify_float()">PL_unify_float()</A>. 
Note that, as the argument is passed using the C vararg conventions, a 
float must be casted to a double explicitly.
</DD>
<DT><B><CODE>PL_FLOAT</CODE> <VAR>double</VAR></B></DT>
<DD class="defbody">
Unify the argument with a float, as in <A class="func" href="foreigninclude.html#PL_unify_float()">PL_unify_float()</A>.
</DD>
<DT><B><CODE>PL_POINTER</CODE> <VAR>void *</VAR></B></DT>
<DD class="defbody">
Unify the argument with a pointer, as in <A class="func" href="foreigninclude.html#PL_unify_pointer()">PL_unify_pointer()</A>.
</DD>
<DT><B><CODE>PL_STRING</CODE> <VAR>const char *</VAR></B></DT>
<DD class="defbody">
Unify the argument with a string object, as in <A class="func" href="foreigninclude.html#PL_unify_string_chars()">PL_unify_string_chars()</A>.
</DD>
<DT><B><CODE>PL_TERM</CODE> <VAR>term_t</VAR></B></DT>
<DD class="defbody">
Unify a subterm. Note this may the return value of a <A class="func" href="foreigntypes.html#PL_new_term_ref()">PL_new_term_ref()</A> 
call to get access to a variable.
</DD>
<DT><B><CODE>PL_FUNCTOR</CODE> <VAR>functor_t, ...</VAR></B></DT>
<DD class="defbody">
Unify the argument with a compound term. This specification should be 
followed by exactly as many specifications as the number of arguments of 
the compound term.
</DD>
<DT><B><CODE>PL_FUNCTOR_CHARS</CODE> <VAR>const char *name, int arity, 
...</VAR></B></DT>
<DD class="defbody">
Create a functor from the given name and arity and then behave as
<CODE>PL_FUNCTOR</CODE>.
</DD>
<DT><B><CODE>PL_LIST</CODE> <VAR>int length, ...</VAR></B></DT>
<DD class="defbody">
Create a list of the indicated length. The following arguments contain 
the elements of the list.
</DD>
</DL>

<P>For example, to unify an argument with the term <CODE>language(dutch)</CODE>, 
the following skeleton may be used:

<PRE class="code">
static functor_t FUNCTOR_language1;

static void
init_constants()
{ FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"), 1);
}

foreign_t
pl_get_lang(term_t r)
{ return PL_unify_term(r,
                       PL_FUNCTOR, FUNCTOR_language1,
                           PL_CHARS, "dutch");
}

install_t
install()
{ PL_register_foreign("get_lang", 1, pl_get_lang, 0);
  init_constants();
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_chars_to_term()"><VAR>int</VAR> <STRONG>PL_chars_to_term</STRONG>(<VAR>const 
char *chars, term_t -t</VAR>)</A></DT>
<DD class="defbody">
Parse the string <VAR>chars</VAR> and put the resulting Prolog term into
<VAR>t</VAR>. <VAR>chars</VAR> may or may not be closed using a Prolog 
full-stop (i.e., a dot followed by a blank). Returns <CODE>FALSE</CODE> 
if a syntax error was encountered and <CODE>TRUE</CODE> after successful 
completion. In addition to returning <CODE>FALSE</CODE>, the 
exception-term is returned in <VAR>t</VAR> on a syntax error. See also <A NAME="idx:termtoatom2:1498"></A><A class="pred" href="manipatom.html#term_to_atom/2">term_to_atom/2</A>.

<P>The following example build a goal-term from a string and calls it.

<PRE class="code">
int
call_chars(const char *goal)
{ fid_t fid = PL_open_foreign_frame();
  term_t g = PL_new_term_ref();
  BOOL rval;

  if ( PL_chars_to_term(goal, g) )
    rval = PL_call(goal, NULL);
  else
    rval = FALSE;

  PL_discard_foreign_frame(fid);
  return rval;
}

  ...
  call_chars("consult(load)");
  ...
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_quote()"><VAR>char *</VAR> <STRONG>PL_quote</STRONG>(<VAR>int 
chr, const char *string</VAR>)</A></DT>
<DD class="defbody">
Return a quoted version of <VAR>string</VAR>. If <VAR>chr</VAR> is
<CODE>'\''</CODE>, the result is a quoted atom. If <VAR>chr</VAR> is
<CODE>'"'</CODE>, the result is a string. The result string is stored in 
the same ring of buffers as described with the <CODE>BUF_RING</CODE> 
argument of <A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A>;

<P>In the current implementation, the string is surrounded by
<VAR>chr</VAR> and any occurrence of <VAR>chr</VAR> is doubled. In the 
future the behaviour will depend on the
<A class="flag" href="flags.html#flag:character_escapes">character_escapes</A> 
Prolog flag.
</DD>
</DL>

<H3><A NAME="sec:9.4.6"><SPAN class="sec-nr">9.4.6</SPAN> <SPAN class="sec-title">Convience 
functions to generate Prolog exceptions</SPAN></A></H3>

<A NAME="sec:cerror"></A>

<P>The typical implementation of a foreign predicate first uses the 
PL_get_*() functions to extract C datatypes from the Prolog terms. 
Failure of any of these functions is normally because the Prolog term is 
of the wrong type. The *_ex() family of functions are wrappers around 
(mostly) the PL_get_*() functions, such that we can write code in the 
style below and get proper exceptions if an argument is uninstantiated 
or of the wrong type.

<PRE class="code">
/** set_size(+Name:atom, +Width:int, +Height:int) is det.

static foreign_t
set_size(term_t name, term_t width, term_t height)
{ char *n;
  int w, h;

  if ( !PL_get_chars(name, &amp;n, CVT_ATOM|CVT_EXCEPTION) ||
       !PL_get_integer_ex(with, &amp;w) ||
       !PL_get_integer_ex(height, &amp;h) )
    return FALSE;

  ...

}
</PRE>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_atom_ex()"><VAR>int</VAR> <STRONG>PL_get_atom_ex</STRONG>(<VAR>term_t 
t, atom_t *a</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_atom()">PL_get_atom()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an atom.</DD>
<DT class="pubdef"><A NAME="PL_get_integer_ex()"><VAR>int</VAR> <STRONG>PL_get_integer_ex</STRONG>(<VAR>term_t 
t, int *i</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_integer()">PL_get_integer()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an integer or a representation error if the Prolog 
integer does not fit in a C <CODE>int</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_get_long_ex()"><VAR>int</VAR> <STRONG>PL_get_long_ex</STRONG>(<VAR>term_t 
t, long *i</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_long()">PL_get_long()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an atom or a representation error if the Prolog 
integer does not fit in a C <CODE>long</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_get_int64_ex()"><VAR>int</VAR> <STRONG>PL_get_int64_ex</STRONG>(<VAR>term_t 
t, int64_t *i</VAR>)</A></DT>
<DD class="defbody">
As PL_get_int64(), but raises a type or instantiation error if
<VAR>t</VAR> is not an atom or a representation error if the Prolog 
integer does not fit in a C <CODE>int64_t</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_get_intptr_ex()"><VAR>int</VAR> <STRONG>PL_get_intptr_ex</STRONG>(<VAR>term_t 
t, intptr_t *i</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_intptr()">PL_get_intptr()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an atom or a representation error if the Prolog 
integer does not fit in a C <CODE>intptr_t</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_get_size_ex()"><VAR>int</VAR> <STRONG>PL_get_size_ex</STRONG>(<VAR>term_t 
t, size_t *i</VAR>)</A></DT>
<DD class="defbody">
As <B>PL_get_size()</B>, but raises a type or instantiation error if
<VAR>t</VAR> is not an atom or a representation error if the Prolog 
integer does not fit in a C <CODE>size_t</CODE>.</DD>
<DT class="pubdef"><A NAME="PL_get_bool_ex()"><VAR>int</VAR> <STRONG>PL_get_bool_ex</STRONG>(<VAR>term_t 
t, int *i</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_atom_ex()">PL_get_atom_ex()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an atom.</DD>
<DT class="pubdef"><A NAME="PL_get_float_ex()"><VAR>int</VAR> <STRONG>PL_get_float_ex</STRONG>(<VAR>term_t 
t, double *f</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_atom_ex()">PL_get_atom_ex()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not an atom.</DD>
<DT class="pubdef"><A NAME="PL_get_char_ex()"><VAR>int</VAR> <STRONG>PL_get_char_ex</STRONG>(<VAR>term_t 
t, int *p, int eof</VAR>)</A></DT>
<DD class="defbody">
Get a character code from <VAR>t</VAR>, where <VAR>t</VAR> is either an 
integer or an atom with length one. If <VAR>eof</VAR> is <CODE>TRUE</CODE> 
and <VAR>t</VAR> is -1, <VAR>p</VAR> is filled with -1. Raises an 
appropriate error if the conversion is not possible.</DD>
<DT class="pubdef"><A NAME="PL_get_pointer_ex()"><VAR>int</VAR> <STRONG>PL_get_pointer_ex</STRONG>(<VAR>term_t 
t, void **addrp</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not a pointer.</DD>
<DT class="pubdef"><A NAME="PL_get_list_ex()"><VAR>int</VAR> <STRONG>PL_get_list_ex</STRONG>(<VAR>term_t 
l, term_t h, term_t t</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_list()">PL_get_list()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not a list.</DD>
<DT class="pubdef"><A NAME="PL_get_nil_ex()"><VAR>int</VAR> <STRONG>PL_get_nil_ex</STRONG>(<VAR>term_t 
l</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_get_nil()">PL_get_nil()</A>, 
but raises a type or instantiation error if
<VAR>t</VAR> is not the empty list.</DD>
<DT class="pubdef"><A NAME="PL_unify_list_ex()"><VAR>int</VAR> <STRONG>PL_unify_list_ex</STRONG>(<VAR>term_t 
l, term_t h, term_t t</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_unify_list()">PL_unify_list()</A>, 
but raises a type error if <VAR>t</VAR> is not a variable, list-cell or 
the empty list.</DD>
<DT class="pubdef"><A NAME="PL_unify_nil_ex()"><VAR>int</VAR> <STRONG>PL_unify_nil_ex</STRONG>(<VAR>term_t 
l</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_unify_nil()">PL_unify_nil()</A>, 
but raises a type error if <VAR>t</VAR> is not a variable, list-cell or 
the empty list.</DD>
<DT class="pubdef"><A NAME="PL_unify_bool_ex()"><VAR>int</VAR> <STRONG>PL_unify_bool_ex</STRONG>(<VAR>term_t 
t, int val</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_unify_bool()">PL_unify_bool()</A>, 
but raises a type error if <VAR>t</VAR> is not a variable, or a boolean.
</DD>
</DL>

<P>The second family of functions in this section simplifies the 
generation of ISO compatible error terms. Any foreign function that 
calls this function must return to Prolog with the return code of the 
error function or the constant <CODE>FALSE</CODE>. If available, these 
error functions add the name of the calling predicate to the error 
context. See also <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A>.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_instantiation_error()"><VAR>int</VAR> <STRONG>PL_instantiation_error</STRONG>(<VAR>term_t 
culprit</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>instantiation_error</CODE>. <VAR>Culprit</VAR> is ignored, 
but should be bound to the term that is not a variable. See
<A NAME="idx:instantiationerror1:1499"></A><SPAN class="pred-ext">instantiation_error/1</SPAN>.</DD>
<DT class="pubdef"><A NAME="PL_representation_error()"><VAR>int</VAR> <STRONG>PL_representation_error</STRONG>(<VAR>const 
char *resource</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>representation_error(resource)</CODE>. See <A NAME="idx:representationerror1:1500"></A><SPAN class="pred-ext">representation_error/1</SPAN>.</DD>
<DT class="pubdef"><A NAME="PL_type_error()"><VAR>int</VAR> <STRONG>PL_type_error</STRONG>(<VAR>const 
char *expected, term_t culprit</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>type_error(expected, culprit)</CODE>. See <A NAME="idx:typeerror2:1501"></A><SPAN class="pred-ext">type_error/2</SPAN>.</DD>
<DT class="pubdef"><A NAME="PL_domain_error()"><VAR>int</VAR> <STRONG>PL_domain_error</STRONG>(<VAR>const 
char *expected, term_t culprit</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>domain_error(expected, culprit)</CODE>. See <A NAME="idx:domainerror2:1502"></A><SPAN class="pred-ext">domain_error/2</SPAN>.</DD>
<DT class="pubdef"><A NAME="PL_existence_error()"><VAR>int</VAR> <STRONG>PL_existence_error</STRONG>(<VAR>const 
char *type, term_t culprit</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>existence_error(type, culprit)</CODE>. See <A NAME="idx:typeerror2:1503"></A><SPAN class="pred-ext">type_error/2</SPAN>.</DD>
<DT class="pubdef"><A NAME="PL_permission_error()"><VAR>int</VAR> <STRONG>PL_permission_error</STRONG>(<VAR>const 
char *operation, const char *type, term_t culprit</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>permission_error(operation, type, culprit)</CODE>. See
<A NAME="idx:permissionerror3:1504"></A><SPAN class="pred-ext">permission_error/3</SPAN>.
</DD>
<DT class="pubdef"><A NAME="PL_resource_error()"><VAR>int</VAR> <STRONG>PL_resource_error</STRONG>(<VAR>const 
char *resource</VAR>)</A></DT>
<DD class="defbody">
Raise <CODE>resource_error(resource)</CODE>. See <A NAME="idx:resourceerror1:1505"></A><SPAN class="pred-ext">resource_error/1</SPAN>.
</DD>
</DL>

<H3><A NAME="sec:9.4.7"><SPAN class="sec-nr">9.4.7</SPAN> <SPAN class="sec-title">BLOBS: 
Using atoms to store arbitrary binary data</SPAN></A></H3>

<A NAME="sec:blob"></A>

<P><A NAME="idx:Java:1506"></A><A NAME="idx:COM:1507"></A>SWI-Prolog 
atoms as well as strings can represent arbitrary binary data of 
arbitrary length. This facility is attractive for storing foreign data 
such as images in an atom. An atom is a unique handle to this data and 
the atom garbage collector is able to destroy atoms that are no longer 
referenced by the Prolog engine. This property of atoms makes them 
attractive as a handle to foreign resources, such as Java atoms, 
Microsoft's COM objects, etc., providing safe combined garbage 
collection.

<P>To exploit these features safely and in an organised manner the 
SWI-Prolog foreign interface allows for creating `atoms' with additional 
type information. The type is represented by a structure holding C 
function pointers that tell Prolog how to handle releasing the atom, 
writing it, sorting it, etc. Two atoms created with different types can 
represent the same sequence of bytes. Atoms are first ordered on the 
rank number of the type and then on the result of the
<A class="func" href="foreigninclude.html#compare()">compare()</A> 
function. Rank numbers are assigned when the type is registered.

<H4><A NAME="sec:9.4.7.1"><SPAN class="sec-nr">9.4.7.1</SPAN> <SPAN class="sec-title">Defining 
a BLOB type</SPAN></A></H4>

<A NAME="sec:blobtype"></A>

<P>The type <CODE>PL_blob_t</CODE> represents a structure with the 
layout displayed above. The structure contains additional fields at the 
... for internal bookkeeping as well as future extension.

<PRE class="code">
typedef struct PL_blob_t
{ unsigned long         magic;          /* PL_BLOB_MAGIC */
  unsigned long         flags;          /* Bitwise or of PL_BLOB_* */
  char *                name;           /* name of the type */
  int                   (*release)(atom_t a);
  int                   (*compare)(atom_t a, atom_t b);
  int                   (*write)(IOSTREAM *s, atom_t a, int flags);
  void                  (*acquire)(atom_t a);
  ...
} PL_blob_t;
</PRE>

<P>For each type exactly one such structure should be allocated. Its 
first field must be initialised to <CODE>PL_BLOB_MAGIC</CODE>. The
<VAR>flags</VAR> is a bitwise or of the following constants:

<DL class="latex">
<DT><A NAME="PL_BLOB_TEXT"><STRONG>PL_BLOB_TEXT</STRONG></A></DT>
<DD class="defbody">
If specified the blob is assumed to contain text and is considered a 
normal Prolog atom.</DD>
<DT><A NAME="PL_BLOB_UNIQUE"><STRONG>PL_BLOB_UNIQUE</STRONG></A></DT>
<DD class="defbody">
If specified the system ensures that the blob-handle is a unique 
reference for a blob with the given type, length and content. If this 
flag is not specified each lookup creates a new blob.</DD>
<DT><A NAME="PL_BLOB_NOCOPY"><STRONG>PL_BLOB_NOCOPY</STRONG></A></DT>
<DD class="defbody">
By default the content of the blob is copied. Using this flag the blob 
references the external data directly. The user must ensure the provided 
pointer is valid as long as the atom lives. If <CODE>PL_BLOB_UNIQUE</CODE> 
is also specified uniqueness is determined by comparing the pointer 
rather than the data pointed at.
</DD>
</DL>

<P>The <VAR>name</VAR> field represents the type name as available to 
Prolog. See also <A NAME="idx:currentblob2:1508"></A><A class="pred" href="examineprog.html#current_blob/2">current_blob/2</A>. 
The other field are function pointers that must be initialised to proper 
functions or <CODE>NULL</CODE> to get the default behaviour of built-in 
atoms. Below are the defined member functions:

<DL class="latex">
<DT class="pubdef"><A NAME="acquire()"><VAR>void</VAR> <STRONG>acquire</STRONG>(<VAR>atom_t 
a</VAR>)</A></DT>
<DD class="defbody">
Called if a new blob of this type is created through <A class="func" href="foreigninclude.html#PL_put_blob()">PL_put_blob()</A> 
or <A class="func" href="foreigninclude.html#PL_unify_blob()">PL_unify_blob()</A>. 
This callback may be used together with the release hook to deal with 
reference counted external objects.</DD>
<DT class="pubdef"><A NAME="release()"><VAR>int</VAR> <STRONG>release</STRONG>(<VAR>atom_t 
a</VAR>)</A></DT>
<DD class="defbody">
The blob (atom) <VAR>a</VAR> is about to be released. This function can 
retrieve the data of the blob using <A class="func" href="foreigninclude.html#PL_blob_data()">PL_blob_data()</A>. 
If it returns <CODE>FALSE</CODE> the atom garbage collector will <EM>not</EM> 
reclaim the atom.</DD>
<DT class="pubdef"><A NAME="compare()"><VAR>int</VAR> <STRONG>compare</STRONG>(<VAR>atom_t 
a, atom_t b</VAR>)</A></DT>
<DD class="defbody">
Compare the blobs <VAR>a</VAR> and <VAR>b</VAR>, both of which are of 
the type associated to this blob-type. Return values are, as memcmp(),
<VAR>&lt; 0</VAR> if <VAR>a</VAR> is less then <VAR>b</VAR>, <VAR>= 0</VAR> 
if both are equal and
<VAR>&gt; 0</VAR> otherwise.</DD>
<DT class="pubdef"><A NAME="write()"><VAR>int</VAR> <STRONG>write</STRONG>(<VAR>IOSTREAM 
*s, atom_t a, int flags</VAR>)</A></DT>
<DD class="defbody">
Write the content of the blob <VAR>a</VAR> to the stream <VAR>s</VAR> 
and respecting the <VAR>flags</VAR>. The <VAR>flags</VAR> are a bitwise 
or of zero or more of the <CODE>PL_WRT_*</CODE> flags defined in
<CODE>SWI-Prolog.h</CODE>. This prototype is available if the 
undocumented <CODE>SWI-Stream.h</CODE> is included <EM>before</EM>
<CODE>SWI-Prolog.h</CODE>.

<P>If this function is not provided, <A NAME="idx:write1:1509"></A><A class="pred" href="termrw.html#write/1">write/1</A> 
emits the content of the blob for blobs of type <CODE>PL_BLOB_TEXT</CODE> 
or a string of the format <CODE>&lt;#</CODE><I>hex data</I><CODE>&gt;</CODE> 
for binary blobs.
</DD>
</DL>

<P>If a blob type is registered from a loadable object (shared object or 
DLL) the blob-type must be deregistered before the object may be 
released.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_unregister_blob_type()"><VAR>int</VAR> <STRONG>PL_unregister_blob_type</STRONG>(<VAR>PL_blob_t 
*type</VAR>)</A></DT>
<DD class="defbody">
Unlink the blob type from the registered type and transform the type of 
possible living blobs to <CODE>unregistered</CODE>, avoiding further 
reference to the type structure, functions referred by it as well as the 
data. This function returns <CODE>TRUE</CODE> if no blobs of this type 
existed and <CODE>FALSE</CODE> otherwise. <A class="func" href="foreigninclude.html#PL_unregister_blob_type()">PL_unregister_blob_type()</A> 
is intended for the uninstall() hook of foreign modules, avoiding 
further references to the module.
</DD>
</DL>

<H4><A NAME="sec:9.4.7.2"><SPAN class="sec-nr">9.4.7.2</SPAN> <SPAN class="sec-title">Accessing 
blobs</SPAN></A></H4>

<A NAME="sec:blobaccess"></A>

<P>The blob access functions are similar to the atom accessing 
functions. Blobs being atoms, the atom functions operate on blobs and 
visa versa. For clarity and possible future compatibility issues however 
it is not advised to rely on this.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_is_blob()"><VAR>int</VAR> <STRONG>PL_is_blob</STRONG>(<VAR>term_t 
t, PL_blob_t **type</VAR>)</A></DT>
<DD class="defbody">
Succeeds if <VAR>t</VAR> refers to a blob, in which case <VAR>type</VAR> 
is filled with the type of the blob.</DD>
<DT class="pubdef"><A NAME="PL_unify_blob()"><VAR>int</VAR> <STRONG>PL_unify_blob</STRONG>(<VAR>term_t 
t, void *blob, size_t len, PL_blob_t *type</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> to a new blob constructed from the given data and 
associated to the given type. See also <A class="func" href="foreigninclude.html#PL_unify_atom_nchars()">PL_unify_atom_nchars()</A>.</DD>
<DT class="pubdef"><A NAME="PL_put_blob()"><VAR>int</VAR> <STRONG>PL_put_blob</STRONG>(<VAR>term_t 
t, void *blob, size_t len, PL_blob_t *type</VAR>)</A></DT>
<DD class="defbody">
Store the described blob in <VAR>t</VAR>. The return value indicates 
whether a new blob was allocated (<CODE>FALSE</CODE>) or the blob is a 
reference to an existing blob (<CODE>TRUE</CODE>). Reporting 
new/existing can be used to deal with external objects having their own 
reference counts. If the return is <CODE>TRUE</CODE> this reference 
count must be incremented and it must be decremented on blob destruction 
callback. See also
<A class="func" href="foreigninclude.html#PL_put_atom_nchars()">PL_put_atom_nchars()</A>.</DD>
<DT class="pubdef"><A NAME="PL_get_blob()"><VAR>int</VAR> <STRONG>PL_get_blob</STRONG>(<VAR>term_t 
t, void **blob, size_t *len, PL_blob_t **type</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> holds a blob or atom get the data and type and return
<CODE>TRUE</CODE>. Otherwise return <CODE>FALSE</CODE>. Each result 
pointer may be <CODE>NULL</CODE>, in which case the requested 
information is ignored.</DD>
<DT class="pubdef"><A NAME="PL_blob_data()"><VAR>void *</VAR> <STRONG>PL_blob_data</STRONG>(<VAR>atom_t 
a, size_t *len, PL_blob_t **type</VAR>)</A></DT>
<DD class="defbody">
Get the data and type associated to a blob. This function is mainly used 
from the callback functions described in <A class="sec" href="foreigninclude.html">section 
9.4.7.1</A>.
</DD>
</DL>

<H3><A NAME="sec:9.4.8"><SPAN class="sec-nr">9.4.8</SPAN> <SPAN class="sec-title">Exchanging 
GMP numbers</SPAN></A></H3>

<A NAME="sec:gmpforeign"></A>

<P>If SWI-Prolog is linked with the GNU Multiple Precision Arithmetic 
Library (GMP, used by default), the foreign interface provides functions 
for exchanging numeric values to GMP types. To access these functions 
the header <CODE>&lt;gmp.h&gt;</CODE> must be included <EM>before</EM>
<CODE>&lt;SWI-Prolog.h&gt;</CODE>. Foreign code using GMP linked to 
SWI-Prolog asks for some considerations.

<P>
<UL class="latex">
<LI>SWI-Prolog normally rebinds the GMP allocation functions using 
mp_set_memory_functions(). This means SWI-Prolog must be initialised 
before the foreign code touches any GMP function. You can call
<CODE>\funcref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, TRUE}</CODE> to 
force Prolog's GMP initialization without doing the rest of the Prolog 
initialization. If you do not want Prolog rebinding the GMP allocation, 
call <CODE>\funcref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, FALSE}</CODE>
<EM>before</EM> initializing Prolog.

<P>
<LI>On Windows, each DLL has its own memory pool. To make exchange of 
GMP numbers between Prolog and foreign code possible you must either let 
Prolog rebind the allocation functions (default) or you must recompile 
SWI-Prolog to link to a DLL version of the GMP library.
</UL>

<P>Here is an example exploiting the function mpz_nextprime():

<PRE class="code">
#include &lt;gmp.h&gt;
#include &lt;SWI-Prolog.h&gt;

static foreign_t
next_prime(term_t n, term_t prime)
{ mpz_t mpz;
  int rc;

  mpz_init(mpz);
  if ( PL_get_mpz(n, mpz) )
  { mpz_nextprime(mpz, mpz);

    rc = PL_unify_mpz(prime, mpz);
  } else
    rc = FALSE;

  mpz_clear(mpz);
  return rc;
}

install_t
install()
{ PL_register_foreign("next_prime", 2, next_prime, 0);
}
</PRE>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_mpz()"><VAR>int</VAR> <STRONG>PL_get_mpz</STRONG>(<VAR>term_t 
t, mpz_t mpz</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> represents an integer <VAR>mpz</VAR> is filled with the 
value and the function returns <CODE>TRUE</CODE>. Otherwise <VAR>mpz</VAR> 
is untouched and the function returns <CODE>FALSE</CODE>. Note that <VAR>mpz</VAR> 
must have been initialised before calling this function and must be 
cleared using mpz_clear() to reclaim any storage associated with it.</DD>
<DT class="pubdef"><A NAME="PL_get_mpq()"><VAR>int</VAR> <STRONG>PL_get_mpq</STRONG>(<VAR>term_t 
t, mpq_t mpq</VAR>)</A></DT>
<DD class="defbody">
If <VAR>t</VAR> is an integer or rational number (term <CODE>rdiv/2</CODE>)
<VAR>mpq</VAR> is filled with the <EM>normalise</EM> rational number and 
the function returns <CODE>TRUE</CODE>. Otherwise <VAR>mpq</VAR> is 
untouched and the function returns <CODE>FALSE</CODE>. Note that <VAR>mpq</VAR> 
must have been initialised before calling this function and must be 
cleared using mpq_clear() to reclaim any storage associated with it.</DD>
<DT class="pubdef"><A NAME="PL_unify_mpz()"><VAR>int</VAR> <STRONG>PL_unify_mpz</STRONG>(<VAR>term_t 
t, mpz_t mpz</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with the integer value represented by <VAR>mpz</VAR> 
and return
<VAR>TRUE</VAR> on success. The <VAR>mpz</VAR> argument is not changed.</DD>
<DT class="pubdef"><A NAME="PL_unify_mpq()"><VAR>int</VAR> <STRONG>PL_unify_mpq</STRONG>(<VAR>term_t 
t, mpq_t mpq</VAR>)</A></DT>
<DD class="defbody">
Unify <VAR>t</VAR> with a rational number represented by <VAR>mpq</VAR> 
and return
<VAR>TRUE</VAR> on success. Note that <VAR>t</VAR> is unified with an 
integer if the denominator is 1. The <VAR>mpq</VAR> argument is not 
changed.
</DD>
</DL>

<H3><A NAME="sec:9.4.9"><SPAN class="sec-nr">9.4.9</SPAN> <SPAN class="sec-title">Calling 
Prolog from C</SPAN></A></H3>

<P>The Prolog engine can be called from C. There are two interfaces for 
this. For the first, a term is created that could be used as an argument 
to <A NAME="idx:call1:1510"></A><A class="pred" href="metacall.html#call/1">call/1</A> 
and next <A class="func" href="foreigninclude.html#PL_call()">PL_call()</A> 
is used to call Prolog. This system is simple, but does not allow to 
inspect the different answers to a non-deterministic goal and is 
relatively slow as the runtime system needs to find the predicate. The 
other interface is based on
<A class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</A>, <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
and <A class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</A> 
or
<A class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</A>. 
This mechanism is more powerful, but also more complicated to use.

<H4><A NAME="sec:9.4.9.1"><SPAN class="sec-nr">9.4.9.1</SPAN> <SPAN class="sec-title">Predicate 
references</SPAN></A></H4>

<P>This section discusses the functions used to communicate about 
predicates. Though a Prolog predicate may defined or not, redefined, 
etc., a Prolog predicate has a handle that is not destroyed, nor moved. 
This handle is known by the type <CODE>predicate_t</CODE>.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_pred()"><VAR>predicate_t</VAR> <STRONG>PL_pred</STRONG>(<VAR>functor_t 
f, module_t m</VAR>)</A></DT>
<DD class="defbody">
Return a handle to a predicate for the specified name/arity in the given 
module. This function always succeeds, creating a handle for an 
undefined predicate if no handle was available. If the module argument
<VAR>m</VAR> is <CODE>NULL</CODE>, the current context module is used.</DD>
<DT class="pubdef"><A NAME="PL_predicate()"><VAR>predicate_t</VAR> <STRONG>PL_predicate</STRONG>(<VAR>const 
char *name, int arity, const char* module</VAR>)</A></DT>
<DD class="defbody">
Same a <A class="func" href="foreigninclude.html#PL_pred()">PL_pred()</A>, 
but provides a more convenient interface to the C-programmer.</DD>
<DT class="pubdef"><A NAME="PL_predicate_info()"><VAR>void</VAR> <STRONG>PL_predicate_info</STRONG>(<VAR>predicate_t 
p, atom_t *n, int *a, module_t *m</VAR>)</A></DT>
<DD class="defbody">
Return information on the predicate <VAR>p</VAR>. The name is stored 
over
<VAR>n</VAR>, the arity over <VAR>a</VAR>, while <VAR>m</VAR> receives 
the definition module. Note that the latter need not be the same as 
specified with
<A class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</A>. 
If the predicate is imported into the module given to
<A class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</A>, 
this function will return the module where the predicate is defined. Any 
of the arguments <VAR>n</VAR>, <VAR>a</VAR> and <VAR>m</VAR> can be
<CODE>NULL</CODE>.
</DD>
</DL>

<H4><A NAME="sec:9.4.9.2"><SPAN class="sec-nr">9.4.9.2</SPAN> <SPAN class="sec-title">Initiating 
a query from C</SPAN></A></H4>

<P>This section discusses the functions for creating and manipulating 
queries from C. Note that a foreign context can have at most one active 
query. This implies it is allowed to make strictly nested calls between 
C and Prolog (Prolog calls C, calls Prolog, calls C, etc., but it is <STRONG>not</STRONG> 
allowed to open multiple queries and start generating solutions for each 
of them by calling <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A>. 
Be sure to call <A class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</A> 
or <A class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</A> 
on any query you opened before opening the next or returning control 
back to Prolog.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_open_query()"><VAR>qid_t</VAR> <STRONG>PL_open_query</STRONG>(<VAR>module_t 
ctx, int flags, predicate_t p, term_t +t0</VAR>)</A></DT>
<DD class="defbody">

<P>Opens a query and returns an identifier for it. <VAR>ctx</VAR> is the <EM>context 
module</EM> of the goal. When <CODE>NULL</CODE>, the context module of 
the calling context will be used, or <CODE>user</CODE> if there is no 
calling context (as may happen in embedded systems). Note that the 
context module only matters for <EM>meta-predicates</EM>. See <A NAME="idx:metapredicate1:1511"></A><A class="pred" href="metapred.html#meta_predicate/1">meta_predicate/1</A>,
<A NAME="idx:contextmodule1:1512"></A><A class="pred" href="ctxmodule.html#context_module/1">context_module/1</A> 
and <A NAME="idx:moduletransparent1:1513"></A><A class="pred" href="ctxmodule.html#module_transparent/1">module_transparent/1</A>. 
The <VAR>p</VAR> argument specifies the predicate, and should be the 
result of a call to <A class="func" href="foreigninclude.html#PL_pred()">PL_pred()</A> 
or <A class="func" href="foreigninclude.html#PL_predicate()">PL_predicate()</A>. 
Note that it is allowed to store this handle as global data and reuse it 
for future queries. The term-reference <VAR>t0</VAR> is the first of a 
vector of term-references as returned by
<A class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs(n)</A>.

<P>The <VAR>flags</VAR> arguments provides some additional options 
concerning debugging and exception handling. It is a bitwise or of the 
following values:

<DL class="latex">
<DT><B><CODE>PL_Q_NORMAL</CODE></B></DT>
<DD class="defbody">
Normal operation. The debugger inherits its settings from the 
environment. If an exception occurs that is not handled in Prolog, a 
message is printed and the tracer is started to debug the error.<SUP class="fn">89<SPAN class="fn-text">Do 
not pass the integer 0 for normal operation, as this is interpreted as <CODE>PL_Q_NODEBUG</CODE> 
for backward compatibility reasons.</SPAN></SUP>
</DD>
<DT><B><CODE>PL_Q_NODEBUG</CODE></B></DT>
<DD class="defbody">
Switch off the debugger while executing the goal. This option is used by 
many calls to hook-predicates to avoid tracing the hooks. An example is <A NAME="idx:print1:1514"></A><A class="pred" href="termrw.html#print/1">print/1</A> 
calling <A NAME="idx:portray1:1515"></A><A class="pred" href="termrw.html#portray/1">portray/1</A> 
from foreign code.
</DD>
<DT><B><CODE>PL_Q_CATCH_EXCEPTION</CODE></B></DT>
<DD class="defbody">
If an exception is raised while executing the goal, do not report it, 
but make it available for <A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A>.
</DD>
<DT><B><CODE>PL_Q_PASS_EXCEPTION</CODE></B></DT>
<DD class="defbody">
As <CODE>PL_Q_CATCH_EXCEPTION</CODE>, but do not invalidate the 
exception-term while calling <A class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</A>. 
This option is experimental.
</DD>
</DL>

<P><A class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</A> 
can return a query-identifier `0' if there is not enough space on the 
environment stack. This function succeeds, even if the referenced 
predicate is not defined. In this case, running the query using <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
will return an existence_error. See
<A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A>.

<P>The example below opens a query to the predicate is_a/2 to find the 
ancestor of `me'. The reference to the predicate is valid for the 
duration of the process and may be cached by the client.

<PRE class="code">
char *
ancestor(const char *me)
{ term_t a0 = PL_new_term_refs(2);
  static predicate_t p;

  if ( !p )
    p = PL_predicate("is_a", 2, "database");

  PL_put_atom_chars(a0, me);
  PL_open_query(NULL, PL_Q_NORMAL, p, a0);
  ...
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_next_solution()"><VAR>int</VAR> <STRONG>PL_next_solution</STRONG>(<VAR>qid_t 
qid</VAR>)</A></DT>
<DD class="defbody">
Generate the first (next) solution for the given query. The return value 
is <CODE>TRUE</CODE> if a solution was found, or <CODE>FALSE</CODE> to 
indicate the query could not be proven. This function may be called 
repeatedly until it fails to generate all solutions to the query.
</DD>
<DT class="pubdef"><A NAME="PL_cut_query()"><VAR>void</VAR> <STRONG>PL_cut_query</STRONG>(<VAR>qid</VAR>)</A></DT>
<DD class="defbody">
Discards the query, but does not delete any of the data created by the 
query. It just invalidate <VAR>qid</VAR>, allowing for a new call to
<A class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</A> 
in this context.
</DD>
<DT class="pubdef"><A NAME="PL_close_query()"><VAR>void</VAR> <STRONG>PL_close_query</STRONG>(<VAR>qid</VAR>)</A></DT>
<DD class="defbody">
As <A class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</A>, 
but all data and bindings created by the query are destroyed.
</DD>
<DT class="pubdef"><A NAME="PL_call_predicate()"><VAR>int</VAR> <STRONG>PL_call_predicate</STRONG>(<VAR>module_t 
m, int flags, predicate_t pred, term_t +t0</VAR>)</A></DT>
<DD class="defbody">
Shorthand for <A class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</A>, <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A>, <A class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</A>, 
generating a single solution. The arguments are the same as for
<A class="func" href="foreigninclude.html#PL_open_query()">PL_open_query()</A>, 
the return value is the same as <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_call()"><VAR>int</VAR> <STRONG>PL_call</STRONG>(<VAR>term_t, 
module_t</VAR>)</A></DT>
<DD class="defbody">
Call term just like the Prolog predicate <A NAME="idx:once1:1516"></A><A class="pred" href="metacall.html#once/1">once/1</A>. <VAR>Term</VAR> 
is called in the specified module, or in the context module if module_t 
= NULL. Returns <CODE>TRUE</CODE> if the call succeeds, <CODE>FALSE</CODE> 
otherwise.
<A class="fig" href="foreigninclude.html#fig:calling">Figure 8</A> shows 
an example to obtain the number of defined atoms. All checks are omitted 
to improve readability.
</DD>
</DL>

<H3><A NAME="sec:9.4.10"><SPAN class="sec-nr">9.4.10</SPAN> <SPAN class="sec-title">Discarding 
Data</SPAN></A></H3>

<P>The Prolog data created and term-references needed to setup the call 
and/or analyse the result can in most cases be discarded right after the 
call. <A class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</A> 
allows for destructing the data, while leaving the term-references. The 
calls below may be used to destroy term-references and data. See <A class="fig" href="foreigninclude.html#fig:calling">figure 
8</A> for an example.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_open_foreign_frame()"><VAR>fid_t</VAR> <STRONG>PL_open_foreign_frame</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Created a foreign frame, holding a mark that allows the system to undo 
bindings and destroy data created after it as well as providing the 
environment for creating term-references. This function is called by the 
kernel before calling a foreign predicate.
</DD>
<DT class="pubdef"><A NAME="PL_close_foreign_frame()"><VAR>void</VAR> <STRONG>PL_close_foreign_frame</STRONG>(<VAR>fid_t 
id</VAR>)</A></DT>
<DD class="defbody">
Discard all term-references created after the frame was opened. All 
other Prolog data is retained. This function is called by the kernel 
whenever a foreign function returns control back to Prolog.
</DD>
<DT class="pubdef"><A NAME="PL_discard_foreign_frame()"><VAR>void</VAR> <STRONG>PL_discard_foreign_frame</STRONG>(<VAR>fid_t 
id</VAR>)</A></DT>
<DD class="defbody">
Same as <A class="func" href="foreigninclude.html#PL_close_foreign_frame()">PL_close_foreign_frame()</A>, 
but also undo all bindings made since the open and destroy all Prolog 
data.
</DD>
<DT class="pubdef"><A NAME="PL_rewind_foreign_frame()"><VAR>void</VAR> <STRONG>PL_rewind_foreign_frame</STRONG>(<VAR>fid_t 
id</VAR>)</A></DT>
<DD class="defbody">
Undo all bindings and discard all term-references created since the 
frame was created, but does not pop the frame. I.e. the same frame can 
be rewinded multiple times, and must eventually be closed or discarded.
</DD>
</DL>

<P>It is obligatory to call either of the two closing functions to 
discard a foreign frame. Foreign frames may be nested.

<PRE class="code">
int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(goal, NULL);         /* call it in current module */

  PL_get_integer(a2, &amp;atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}
</PRE>

<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Figure 8 : </B>Calling Prolog</TABLE>

<A NAME="fig:calling"></A>

<H3><A NAME="sec:9.4.11"><SPAN class="sec-nr">9.4.11</SPAN> <SPAN class="sec-title">Foreign 
Code and Modules</SPAN></A></H3>

<P>Modules are identified via a unique handle. The following functions 
are available to query and manipulate modules.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_context()"><VAR>module_t</VAR> <STRONG>PL_context</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Return the module identifier of the context module of the currently 
active foreign predicate.
</DD>
<DT class="pubdef"><A NAME="PL_strip_module()"><VAR>int</VAR> <STRONG>PL_strip_module</STRONG>(<VAR>term_t 
+raw, module_t *m, term_t -plain</VAR>)</A></DT>
<DD class="defbody">
Utility function. If <VAR>raw</VAR> is a term, possibly holding the 
module construct &lt;<VAR>module</VAR>&gt;<TT>:</TT>&lt;<VAR>rest</VAR>&gt; 
this function will make
<VAR>plain</VAR> a reference to &lt;<VAR>rest</VAR>&gt; and fill <VAR>module 
*</VAR> with &lt;<VAR>module</VAR>&gt;. For further nested module 
constructs the inner most module is returned via <VAR>module *</VAR>. If <VAR>raw</VAR> 
is not a module construct <VAR>arg</VAR> will simply be put in <VAR>plain</VAR>. 
If <VAR>module *</VAR> is <CODE>NULL</CODE> it will be set to the 
context module. Otherwise it will be left untouched. The following 
example shows how to obtain the plain term and module if the default 
module is the user module:

<PRE class="code">
{ module m = PL_new_module(PL_new_atom("user"));
  term_t plain = PL_new_term_ref();

  PL_strip_module(term, &amp;m, plain);
  ...
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_module_name()"><VAR>atom_t</VAR> <STRONG>PL_module_name</STRONG>(<VAR>module_t</VAR>)</A></DT>
<DD class="defbody">
Return the name of <VAR>module</VAR> as an atom.
</DD>
<DT class="pubdef"><A NAME="PL_new_module()"><VAR>module_t</VAR> <STRONG>PL_new_module</STRONG>(<VAR>atom_t 
name</VAR>)</A></DT>
<DD class="defbody">
Find an existing or create a new module with name specified by the atom
<VAR>name</VAR>.
</DD>
</DL>

<H3><A NAME="sec:9.4.12"><SPAN class="sec-nr">9.4.12</SPAN> <SPAN class="sec-title">Prolog 
exceptions in foreign code</SPAN></A></H3>

<P>This section discusses <A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A>, <A class="func" href="foreigninclude.html#PL_throw()">PL_throw()</A> 
and
<A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A>, 
the interface functions to detect and generate Prolog exceptions from 
C-code. <A class="func" href="foreigninclude.html#PL_throw()">PL_throw()</A> 
and <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A> 
from the C-interface to raise an exception from foreign code. <A class="func" href="foreigninclude.html#PL_throw()">PL_throw()</A> 
exploits the C-function longjmp() to return immediately to the innermost
<A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A>. <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A> 
registers the exception term and returns <CODE>FALSE</CODE>. If a 
foreign predicate returns FALSE, while and exception-term is registered 
a Prolog exception will be raised by the virtual machine.

<P>Calling these functions outside the context of a function 
implementing a foreign predicate results in undefined behaviour.

<P><A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A> 
may be used after a call to <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
fails, and returns a term reference to an exception term if an exception 
was raised, and 0 otherwise.

<P>If a C-function, implementing a predicate calls Prolog and detects an 
exception using <A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A>, 
it can handle this exception, or return with the exception. Some caution 
is required though. It is
<STRONG>not</STRONG> allowed to call <A class="func" href="foreigninclude.html#PL_close_query()">PL_close_query()</A> 
or
<A class="func" href="foreigninclude.html#PL_discard_foreign_frame()">PL_discard_foreign_frame()</A> 
afterwards, as this will invalidate the exception term. Below is the 
code that calls a Prolog defined arithmetic function (see <A NAME="idx:arithmeticfunction1:1517"></A><SPAN class="pred-ext">arithmetic_function/1</SPAN>).

<P>If <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
succeeds, the result is analysed and translated to a number, after which 
the query is closed and all Prolog data created after <A class="func" href="foreigninclude.html#PL_open_foreign_frame()">PL_open_foreign_frame()</A> 
is destroyed. On the other hand, if
<A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
fails and if an exception was raised, just pass it. Otherwise generate 
an exception (<B>PL_error()</B> is an internal call for building the 
standard error terms and calling <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A>). 
After this, the Prolog environment should be discarded using
<A class="func" href="foreigninclude.html#PL_cut_query()">PL_cut_query()</A> 
and <A class="func" href="foreigninclude.html#PL_close_foreign_frame()">PL_close_foreign_frame()</A> 
to avoid invalidating the exception term.

<PRE class="code">
static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f-&gt;proc-&gt;definition-&gt;functor-&gt;arity;
  fid_t fid = PL_open_foreign_frame();
  qid_t qid;
  int rval;

  qid = PL_open_query(NULL, PL_Q_NORMAL, f-&gt;proc, av);

  if ( PL_next_solution(qid) )
  { rval = valueExpression(av+arity-1, r);
    PL_close_query(qid);
    PL_discard_foreign_frame(fid);
  } else
  { term_t except;

    if ( (except = PL_exception(qid)) )
    { rval = PL_throw(except);          /* pass exception */
    } else
    { char *name = stringAtom(f-&gt;proc-&gt;definition-&gt;functor-&gt;name);

                                        /* generate exception */
      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f-&gt;proc);
    }

    PL_cut_query(qid);                  /* donot destroy data */
    PL_close_foreign_frame(fid);        /* same */
  }

  return rval;
}
</PRE>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_raise_exception()"><VAR>int</VAR> <STRONG>PL_raise_exception</STRONG>(<VAR>term_t 
exception</VAR>)</A></DT>
<DD class="defbody">
Generate an exception (as <A NAME="idx:throw1:1518"></A><A class="pred" href="exception.html#throw/1">throw/1</A>) 
and return <CODE>FALSE</CODE>. Below is an example returning an 
exception from foreign predicate:

<PRE class="code">
foreign_t
pl_hello(term_t to)
{ char *s;

  if ( PL_get_atom_chars(to, &amp;s) )
  { Sprintf("Hello \"%s\"\n", s);

    PL_succeed;
  } else
  { term_t except = PL_new_term_ref();

    PL_unify_term(except,
                  PL_FUNCTOR_CHARS, "type_error", 2,
                    PL_CHARS, "atom",
                    PL_TERM, to);

    return PL_raise_exception(except);
  }
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_throw()"><VAR>int</VAR> <STRONG>PL_throw</STRONG>(<VAR>term_t 
exception</VAR>)</A></DT>
<DD class="defbody">
Similar to <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A>, 
but returns using the C longjmp() function to the innermost <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A>.</DD>
<DT class="pubdef"><A NAME="PL_exception()"><VAR>term_t</VAR> <STRONG>PL_exception</STRONG>(<VAR>qid_t 
qid</VAR>)</A></DT>
<DD class="defbody">
If <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
fails, this can be due to normal failure of the Prolog call, or because 
an exception was raised using <A NAME="idx:throw1:1519"></A><A class="pred" href="exception.html#throw/1">throw/1</A>. 
This function returns a handle to the exception term if an exception was 
raised, or 0 if the Prolog goal simply failed. If there is an exception,
<A class="func" href="foreigninclude.html#PL_exception()">PL_exception()</A> 
allocates a term-handle using <A class="func" href="foreigntypes.html#PL_new_term_ref()">PL_new_term_ref()</A> 
that is used to return the exception term.<SUP class="fn">90<SPAN class="fn-text">This 
interface differs in two ways from Quintus. The calling predicates 
simply signal failure if an exception was raised, and a term referenced 
is returned, rather passed and filled with the error term. Exceptions 
can only be handled using the <A class="func" href="foreigninclude.html#PL_next_solution()">PL_next_solution()</A> 
interface, as a handle to the query is required.</SPAN></SUP>

<P>Additionally, <CODE>\funcref{PL_exception}{0}</CODE> returns the 
pending exception in the current query or 0 if no exception is pending. 
This can be used to check the error-status after a failing call to e.g., 
one of the unification functions.</DD>
<DT class="pubdef"><A NAME="void()"><VAR>PL_clear_exception</VAR> <STRONG>void</STRONG>(<VAR>void</VAR>)</A></DT>
<DD class="defbody">
ells Prolog that the encountered exception must be ignored. This 
function must be called if control remains in C after an previous API 
calls fails with an exception.<SUP class="fn">91<SPAN class="fn-text">This 
feature is non-portable. Other Prolog systems (e.g., YAP) has no 
facilities to ignore raised exceptions and the design of YAP's exception 
handling does not support such a facility</SPAN></SUP>.
</DD>
</DL>

<H3><A NAME="sec:9.4.13"><SPAN class="sec-nr">9.4.13</SPAN> <SPAN class="sec-title">Catching 
Signals (Software Interrupts)</SPAN></A></H3>

<A NAME="sec:csignal"></A>

<P>SWI-Prolog offers both a C and Prolog interface to deal with software 
interrupts (signals). The Prolog mapping is defined in
<A class="sec" href="signal.html">section 4.10</A>. This subsection 
deals with handling signals from C.

<P>If a signal is not used by Prolog and the handler does not call 
Prolog in any way, the native signal interface routines may be used.

<P>Some versions of SWI-Prolog, notably running on popular Unix 
platforms, handle <CODE>SIG_SEGV</CODE> for guarding the Prolog stacks. 
If the application wishes to handle this signal too, it should use <A class="func" href="foreigninclude.html#PL_signal()">PL_signal()</A> 
to install its handler after initialising Prolog. SWI-Prolog will pass
<CODE>SIG_SEGV</CODE> to the user code if it detected the signal is not 
related to a Prolog stack overflow.

<P>Any handler that wishes to call one of the Prolog interface functions 
should call <A class="func" href="foreigninclude.html#PL_signal()">PL_signal()</A> 
for its installation.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_signal()"><VAR>void (*)()</VAR> <STRONG>PL_signal</STRONG>(<VAR>sig, 
func</VAR>)</A></DT>
<DD class="defbody">
This function is equivalent to the BSD-Unix signal() function, 
regardless of the platform used. The signal handler is blocked while the 
signal routine is active, and automatically reactivated after the 
handler returns.

<P>After a signal handler is registered using this function, the native 
signal interface redirects the signal to a generic signal handler inside 
SWI-Prolog. This generic handler validates the environment, creates a 
suitable environment for calling the interface functions described in 
this chapter and finally calls the registered user-handler.

<P>By default, signals are handled asynchronously (i.e. at the time they 
arrive). It is inherently dangerous to call extensive code fragments, 
and especially exception related code from asynchronous handlers. The 
interface allows for <EM>synchronous</EM> handling of signals. In this 
case the native OS handler just schedules the signal using <A class="func" href="foreigninclude.html#PL_raise()">PL_raise()</A>, 
which is checked by <A class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</A> 
at the call- and redo-port. This behaviour is realised by or-ing <VAR>sig</VAR> 
with the constant
<CODE>PL_SIGSYNC</CODE>.<SUP class="fn">92<SPAN class="fn-text">A better 
default would be to use synchronous handling, but this interface 
preserves backward compatibility.</SPAN></SUP>

<P>Signal handling routines may raise exceptions using
<A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A>. 
The use of <A class="func" href="foreigninclude.html#PL_throw()">PL_throw()</A> 
is not safe. If a synchronous handler raises an exception, the exception 
is delayed to the next call to <A class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</A>;</DD>
<DT class="pubdef"><A NAME="PL_raise()"><VAR>int</VAR> <STRONG>PL_raise</STRONG>(<VAR>int 
sig</VAR>)</A></DT>
<DD class="defbody">
Register <VAR>sig</VAR> for <EM>synchronous</EM> handling by Prolog. 
Synchronous signals are handled at the call-port or if foreign code 
calls <A class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</A>. 
See also <A NAME="idx:threadsignal2:1520"></A><A class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</A>.</DD>
<DT class="pubdef"><A NAME="PL_handle_signals()"><VAR>int</VAR> <STRONG>PL_handle_signals</STRONG>(<VAR>void</VAR>)</A></DT>
<DD class="defbody">
Handle any signals pending from <A class="func" href="foreigninclude.html#PL_raise()">PL_raise()</A>. <A class="func" href="foreigninclude.html#PL_handle_signals()">PL_handle_signals()</A> 
is called at each pass through the call- and redo-port at a safe point. 
Exceptions raised by the handler using <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A> 
are properly passed to the environment.

<P>The user may call this function inside long-running foreign functions 
to handle scheduled interrupts. This routine returns the number of 
signals handled. If a handler raises an exception, the return value is 
-1 and the calling routine should return with <CODE>FALSE</CODE> as soon 
as possible.</DD>
<DT class="pubdef"><A NAME="PL_get_signum_ex()"><VAR>int</VAR> <STRONG>PL_get_signum_ex</STRONG>(<VAR>term_t 
t, int *sig</VAR>)</A></DT>
<DD class="defbody">
Extract a signal specification from a Prolog term and store as integer 
signal number in <VAR>sig</VAR>. The specification is an integer, 
lowercase signal name without <CODE>SIG</CODE> or the full signal name. 
These refer to the same: <CODE>9</CODE>, <CODE>kill</CODE> and <CODE>SIGKILL</CODE>. 
Leaves a typed, domain or instantiation error if the conversion fails.
</DD>
</DL>

<H3><A NAME="sec:9.4.14"><SPAN class="sec-nr">9.4.14</SPAN> <SPAN class="sec-title">Miscellaneous</SPAN></A></H3>

<H4><A NAME="sec:9.4.14.1"><SPAN class="sec-nr">9.4.14.1</SPAN> <SPAN class="sec-title">Term 
Comparison</SPAN></A></H4>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_compare()"><VAR>int</VAR> <STRONG>PL_compare</STRONG>(<VAR>term_t 
t1, term_t t2</VAR>)</A></DT>
<DD class="defbody">
Compares two terms using the standard order of terms and returns -1, 0 
or 1. See also <A NAME="idx:compare3:1521"></A><A class="pred" href="compare.html#compare/3">compare/3</A>.
</DD>
<DT class="pubdef"><A NAME="PL_same_compound()"><VAR>int</VAR> <STRONG>PL_same_compound</STRONG>(<VAR>term_t 
t1, term_t t2</VAR>)</A></DT>
<DD class="defbody">
Yields <CODE>TRUE</CODE> if <VAR>t1</VAR> and <VAR>t2</VAR> refer to 
physically the same compound term and <CODE>FALSE</CODE> otherwise.
</DD>
</DL>

<H4><A NAME="sec:9.4.14.2"><SPAN class="sec-nr">9.4.14.2</SPAN> <SPAN class="sec-title">Recorded 
database</SPAN></A></H4>

<P>In some applications it is useful to store and retrieve Prolog terms 
from C-code. For example, the XPCE graphical environment does this for 
storing arbitrary Prolog data as slot-data of XPCE objects.

<P>Please note that the returned handles have no meaning at the Prolog 
level and the recorded terms are not visible from Prolog. The functions
<A class="func" href="foreigninclude.html#PL_recorded()">PL_recorded()</A> 
and <A class="func" href="foreigninclude.html#PL_erase()">PL_erase()</A> 
are the only functions that can operate on the stored term.

<P>Two groups of functions are provided. The first group (<A class="func" href="foreigninclude.html#PL_record()">PL_record()</A> 
and friends) store Prolog terms on the Prolog heap for retrieval during 
the same session. These functions are also used by <A NAME="idx:recorda3:1522"></A><A class="pred" href="db.html#recorda/3">recorda/3</A> 
and friends. The recorded database may be used to communicate Prolog 
terms between threads.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_record()"><VAR>record_t</VAR> <STRONG>PL_record</STRONG>(<VAR>term_t 
+t</VAR>)</A></DT>
<DD class="defbody">
Record the term <VAR>t</VAR> into the Prolog database as <A NAME="idx:recorda3:1523"></A><A class="pred" href="db.html#recorda/3">recorda/3</A> 
and return an opaque handle to the term. The returned handle remains 
valid until <A class="func" href="foreigninclude.html#PL_erase()">PL_erase()</A> 
is called on it. <A class="func" href="foreigninclude.html#PL_recorded()">PL_recorded()</A> 
is used to copy recorded terms back to the Prolog stack.</DD>
<DT class="pubdef"><A NAME="PL_recorded()"><VAR>int</VAR> <STRONG>PL_recorded</STRONG>(<VAR>record_t 
record, term_t -t</VAR>)</A></DT>
<DD class="defbody">
Copy a recorded term back to the Prolog stack. The same record may be 
used to copy multiple instances at any time to the Prolog stack. Returns <CODE>TRUE</CODE> 
on success, and <CODE>FALSE</CODE> if there is not enough space on the 
stack to accomodate the term. See also <A class="func" href="foreigninclude.html#PL_record()">PL_record()</A> 
and <A class="func" href="foreigninclude.html#PL_erase()">PL_erase()</A>.</DD>
<DT class="pubdef"><A NAME="PL_erase()"><VAR>void</VAR> <STRONG>PL_erase</STRONG>(<VAR>record_t 
record</VAR>)</A></DT>
<DD class="defbody">
Remove the recorded term from the Prolog database, reclaiming all 
associated memory resources.
</DD>
</DL>

<P>The second group (headed by <A class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</A>) 
provides the same functionality, but the returned data has properties 
that enable storing the data on an external device. It has been designed 
to make it possible to store Prolog terms fast an compact in an external 
database. Here are the main features:

<P>
<UL class="latex">
<LI><I>Independent of session</I><BR>
Records can be communicated to another Prolog session and made visible 
using <A class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</A>.
<LI><I>Binary</I><BR>
The representation is binary for maximum performance. The returned data 
may contain 0-bytes.
<LI><I>Byte-order independent</I><BR>
The representation can be transferred between machines with different 
byte-order.
<LI><I>No alignment restrictions</I><BR>
There are no memory alignment restrictions and copies of the record can 
thus be moved freely. For example, it is possible to use this 
representation to exchange terms using shared memory between different 
Prolog processes.
<LI><I>Compact</I><BR>
It is assumed that a smaller memory footprint will eventually outperform 
slightly faster representations.
<LI><I>Stable</I><BR>
The format is designed for future enhancements without breaking 
compatibility with older records.
</UL>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_record_external()"><VAR>char *</VAR> <STRONG>PL_record_external</STRONG>(<VAR>term_t 
+t, size_t *len</VAR>)</A></DT>
<DD class="defbody">
Record the term <VAR>t</VAR> into the Prolog database as <A NAME="idx:recorda3:1524"></A><A class="pred" href="db.html#recorda/3">recorda/3</A> 
and return an opaque handle to the term. The returned handle remains 
valid until <A class="func" href="foreigninclude.html#PL_erase_external()">PL_erase_external()</A> 
is called on it.

<P>It is allowed to copy the data and use <A class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</A> 
on the copy. The user is responsible for the memory management of the 
copy. After copying, the original may be discarded using
<A class="func" href="foreigninclude.html#PL_erase_external()">PL_erase_external()</A>.

<P><A class="func" href="foreigninclude.html#PL_recorded_external()">PL_recorded_external()</A> 
is used to copy such recorded terms back to the Prolog stack.
</DD>
<DT class="pubdef"><A NAME="PL_recorded_external()"><VAR>int</VAR> <STRONG>PL_recorded_external</STRONG>(<VAR>const 
char *record, term_t -t</VAR>)</A></DT>
<DD class="defbody">
Copy a recorded term back to the Prolog stack. The same record may be 
used to copy multiple instances at any time to the Prolog stack. See 
also <A class="func" href="foreigninclude.html#PL_record_external()">PL_record_external()</A> 
and <A class="func" href="foreigninclude.html#PL_erase_external()">PL_erase_external()</A>.
</DD>
<DT class="pubdef"><A NAME="PL_erase_external()"><VAR>int</VAR> <STRONG>PL_erase_external</STRONG>(<VAR>char 
*record</VAR>)</A></DT>
<DD class="defbody">
Remove the recorded term from the Prolog database, reclaiming all 
associated memory resources.
</DD>
</DL>

<H4><A NAME="sec:9.4.14.3"><SPAN class="sec-nr">9.4.14.3</SPAN> <SPAN class="sec-title">Getting 
file names</SPAN></A></H4>

<A NAME="sec:cfilenames"></A>

<P>The function <A class="func" href="foreigninclude.html#PL_get_file_name()">PL_get_file_name()</A> 
provides access to Prolog filenames and its file-search mechanism 
described with <A NAME="idx:absolutefilename3:1525"></A><A class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</A>. 
Its existence is motivated to realise a uniform interface to deal with 
file-properties, search, naming conventions etc. from foreign code.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_get_file_name()"><VAR>int</VAR> <STRONG>PL_get_file_name</STRONG>(<VAR>term_t 
spec, char **name, int flags</VAR>)</A></DT>
<DD class="defbody">
Translate a Prolog term into a file name. The name is stored in the 
static buffer ring described with <A class="func" href="foreigninclude.html#PL_get_chars()">PL_get_chars()</A> 
option
<CODE>BUF_RING</CODE>. Conversion from the internal UNICODE encoding is 
done using standard C library functions. <VAR>flags</VAR> is a bit-mask 
controlling the conversion process. Options are:

<DL class="latex">
<DT><B><CODE>PL_FILE_ABSOLUTE</CODE></B></DT>
<DD class="defbody">
Return an absolute path to the requested file.
</DD>
<DT><B><CODE>PL_FILE_OSPATH</CODE></B></DT>
<DD class="defbody">
Return a the name using the hosting OS conventions. On MS-Windows,
<CODE><CODE>\</CODE></CODE> is used to separate directories rather than 
the canonical
<CODE><CODE>/</CODE></CODE>.
</DD>
<DT><B><CODE>PL_FILE_SEARCH</CODE></B></DT>
<DD class="defbody">
Invoke <A NAME="idx:absolutefilename3:1526"></A><A class="pred" href="files.html#absolute_file_name/3">absolute_file_name/3</A>. 
This implies rules from <A NAME="idx:filesearchpath2:1527"></A><A class="pred" href="consulting.html#file_search_path/2">file_search_path/2</A> 
are used.
</DD>
<DT><B><CODE>PL_FILE_EXIST</CODE></B></DT>
<DD class="defbody">
Demand the path to refer to an existing entity.
</DD>
<DT><B><CODE>PL_FILE_READ</CODE></B></DT>
<DD class="defbody">
Demand read-access on the result.
</DD>
<DT><B><CODE>PL_FILE_WRITE</CODE></B></DT>
<DD class="defbody">
Demand write-access on the result.
</DD>
<DT><B><CODE>PL_FILE_EXECUTE</CODE></B></DT>
<DD class="defbody">
Demand execute-access on the result.
</DD>
<DT><B><CODE>PL_FILE_NOERRORS</CODE></B></DT>
<DD class="defbody">
Do not raise any exceptions.
</DD>
</DL>

</DD>
<DT class="pubdef"><A NAME="PL_get_file_nameW()"><VAR>int</VAR> <STRONG>PL_get_file_nameW</STRONG>(<VAR>term_t 
spec, wchar_t **name, int flags</VAR>)</A></DT>
<DD class="defbody">
Same as <A class="func" href="foreigninclude.html#PL_get_file_name()">PL_get_file_name()</A>, 
but returns the filename as a wide-character string. This is intended 
for Windows to access the Unicode version of the Win32 API. Note that 
the flag <CODE>PL_FILE_OSPATH</CODE> must be provided to fetch a file 
name in OS native (e.g., <CODE>C:\x\y</CODE>) notation.
</DD>
</DL>

<H3><A NAME="sec:9.4.15"><SPAN class="sec-nr">9.4.15</SPAN> <SPAN class="sec-title">Errors 
and warnings</SPAN></A></H3>

<P><A class="func" href="foreigninclude.html#PL_warning()">PL_warning()</A> 
prints a standard Prolog warning message to the standard error (<CODE>user_error</CODE>) 
stream. Please note that new code should consider using <A class="func" href="foreigninclude.html#PL_raise_exception()">PL_raise_exception()</A> 
to raise a Prolog exception. See also <A class="sec" href="exception.html">section 
4.9</A>.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_warning()"><VAR>int</VAR> <STRONG>PL_warning</STRONG>(<VAR>format, 
a1, ...</VAR>)</A></DT>
<DD class="defbody">
Print an error message starting with `<TT>[WARNING: </TT>', followed by 
the output from <VAR>format</VAR>, followed by a `<CODE>]</CODE>' and a 
newline. Then start the tracer. <VAR>format</VAR> and the arguments are 
the same as for <STRONG>printf</STRONG>(2). Always returns <CODE>FALSE</CODE>.
</DD>
</DL>

<H3><A NAME="sec:9.4.16"><SPAN class="sec-nr">9.4.16</SPAN> <SPAN class="sec-title">Environment 
Control from Foreign Code</SPAN></A></H3>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_action()"><VAR>int</VAR> <STRONG>PL_action</STRONG>(<VAR>int, 
...</VAR>)</A></DT>
<DD class="defbody">
Perform some action on the Prolog system. <VAR>int</VAR> describes the 
action, Remaining arguments depend on the requested action. The actions 
are listed in <A class="tab" href="foreigninclude.html#tab:action">table 
6</A>.
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>PL_ACTION_TRACE</CODE> </TD><TD>Start Prolog 
tracer (<A NAME="idx:trace0:1528"></A><A class="pred" href="debugger.html#trace/0">trace/0</A>). 
Requires no arguments. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_DEBUG</CODE> </TD><TD>Switch on 
Prolog debug mode (<A NAME="idx:debug0:1529"></A><A class="pred" href="debugger.html#debug/0">debug/0</A>). 
Requires no arguments. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_BACKTRACE</CODE> </TD><TD>Print 
backtrace on current output stream. The argument (an int) is the number 
of frames printed. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_HALT</CODE> </TD><TD>Halt Prolog 
execution. This action should be called rather than Unix exit() to give 
Prolog the opportunity to clean up. This call does not return. The 
argument (an int) is the exit code. See <A NAME="idx:halt1:1530"></A><A class="pred" href="toplevel.html#halt/1">halt/1</A>. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_ABORT</CODE> </TD><TD>Generate a 
Prolog abort (<A NAME="idx:abort0:1531"></A><A class="pred" href="toplevel.html#abort/0">abort/0</A>). 
This call does not return. Requires no arguments. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_BREAK</CODE> </TD><TD>Create a 
standard Prolog break environment (<A NAME="idx:break0:1532"></A><A class="pred" href="toplevel.html#break/0">break/0</A>). 
Returns after the user types the end-of-file character. Requires no 
arguments. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_GUIAPP</CODE> </TD><TD>Win32: Used to 
indicate the kernel that the application is a GUI application if the 
argument is not 0 and a console application if the argument is 0. If a 
fatal error occurs, the system uses a windows messagebox to report this 
on a GUI application and simply prints the error and exits otherwise. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_WRITE</CODE> </TD><TD>Write the 
argument, a <CODE>char *</CODE> to the current output stream. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_FLUSH</CODE> </TD><TD>Flush the 
current output stream. Requires no arguments. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_ACTION_ATTACH_CONSOLE</CODE> </TD><TD>Attach 
a console to a thread if it does not have one. See <A NAME="idx:attachconsole0:1533"></A><A class="pred" href="thutil.html#attach_console/0">attach_console/0</A>. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_GMP_SET_ALLOC_FUNCTIONS</CODE> </TD><TD>Takes 
and integer argument. If
<CODE>TRUE</CODE>, the GMP allocation are immediately bound to the 
Prolog functions. If <CODE>FALSE</CODE>, SWI-Prolog will never rebind 
the GMP allocation functions. See mp_set_memory_functions() in the GMP 
documentation. The action returns <CODE>FALSE</CODE> if there is no GMP 
support or GMP is already initialised. </TD></TR>
</TABLE>

</BLOCKQUOTE>
<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Table 6 : </B><A class="func" href="foreigninclude.html#PL_action()">PL_action()</A> 
options</TABLE>

<A NAME="tab:action"></A>
</DD>
</DL>

<H3><A NAME="sec:9.4.17"><SPAN class="sec-nr">9.4.17</SPAN> <SPAN class="sec-title">Querying 
Prolog</SPAN></A></H3>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_query()"><VAR>long</VAR> <STRONG>PL_query</STRONG>(<VAR>int</VAR>)</A></DT>
<DD class="defbody">
Obtain status information on the Prolog system. The actual argument type 
depends on the information required. <VAR>int</VAR> describes what 
information is wanted.<SUP class="fn">93<SPAN class="fn-text">Returning 
pointers and integers as a long is bad style. The signature of this 
function should be changed.</SPAN></SUP> The options are given in <A class="tab" href="foreigninclude.html#tab:query">table 
7</A>.
<BLOCKQUOTE>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>PL_QUERY_ARGC</CODE> </TD><TD>Return an integer 
holding the number of arguments given to Prolog from Unix. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_QUERY_ARGV</CODE> </TD><TD>Return a char ** 
holding the argument vector given to Prolog from Unix. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_QUERY_SYMBOLFILE</CODE> </TD><TD>Return a 
char * holding the current symbol file of the running process. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_MAX_INTEGER</CODE> </TD><TD>Return a long, 
representing the maximal integer value represented by a Prolog integer. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_MIN_INTEGER</CODE> </TD><TD>Return a long, 
representing the minimal integer value. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_QUERY_VERSION</CODE> </TD><TD>Return a long, 
representing the version as
<VAR>10,000 &times; M + 100 &times; m + p</VAR>, where
<VAR>M</VAR> is the major, <VAR>m</VAR> the minor version number and <VAR>p</VAR> 
the patch-level. For example,
<CODE>20717</CODE> means <CODE>2.7.17</CODE>. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_QUERY_ENCODING</CODE> </TD><TD>Return the 
default stream encoding of Prolog (of type <CODE>IOENC</CODE>). </TD></TR>
<TR VALIGN=top><TD><CODE>PL_QUERY_USER_CPU</CODE> </TD><TD>Get amount of 
user CPU time of the process in milliseconds. </TD></TR>
</TABLE>

</BLOCKQUOTE>
<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Table 7 : </B><A class="func" href="foreigninclude.html#PL_query()">PL_query()</A> 
options</TABLE>

<A NAME="tab:query"></A>
</DD>
</DL>

<H3><A NAME="sec:9.4.18"><SPAN class="sec-nr">9.4.18</SPAN> <SPAN class="sec-title">Registering 
Foreign Predicates</SPAN></A></H3>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_register_foreign_in_module()"><VAR>int</VAR> <STRONG>PL_register_foreign_in_module</STRONG>(<VAR>const 
char *module, const char *name, int arity, foreign_t (*function)(), int 
flags</VAR>)</A></DT>
<DD class="defbody">
Register a C-function to implement a Prolog predicate. After this call 
returns successfully a predicate with name <VAR>name</VAR> (a char *) 
and arity <VAR>arity</VAR> (a C int) is created in module <VAR>module</VAR>. 
If
<VAR>module</VAR> is <CODE>NULL</CODE>, the predicate is created in the 
module of the calling context or if no context is present in the module
<CODE>user</CODE>.

<P>When called in Prolog, Prolog will call <VAR>function</VAR>. <VAR>flags</VAR> 
forms bitwise or'ed list of options for the installation. These are:

<P>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><CODE>PL_FA_NOTRACE</CODE> </TD><TD>Predicate cannot 
be seen in the tracer </TD></TR>
<TR VALIGN=top><TD><CODE>PL_FA_TRANSPARENT</CODE> </TD><TD>Predicate is 
module transparent </TD></TR>
<TR VALIGN=top><TD><CODE>PL_FA_NONDETERMINISTIC</CODE> </TD><TD>Predicate 
is non-deterministic. See also <A class="func" href="foreigninclude.html#PL_retry()">PL_retry()</A>. </TD></TR>
<TR VALIGN=top><TD><CODE>PL_FA_VARARGS</CODE> </TD><TD>Use alternative 
calling convention. </TD></TR>
</TABLE>

<P>Predicates may be registered either before or after <A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A>. 
When registered before initialisation the registration is recorded and 
executed after installing the system predicates and before loading the 
saved state.

<P>Default calling (i.e. without <CODE>PL_FA_VARARGS</CODE>) <VAR>function</VAR> 
is passed the same number of term_t arguments as the arity of the 
predicate and, if the predicate is non-deterministic, an extra argument 
of type
<CODE>control_t</CODE> (see <A class="sec" href="foreigninclude.html">section 
9.4.1.1</A>). If <CODE>PL_FA_VARARGS</CODE> is provided, <VAR>function</VAR> 
is called with three arguments. The first argument is a <CODE>term_t</CODE> 
handle to the first argument. Further arguments can be reached by adding 
the offset (see also
<A class="func" href="foreigntypes.html#PL_new_term_refs()">PL_new_term_refs()</A>). 
The second argument is the arity, which defines the number of valid 
term-references in the argument vector. The last argument is used for 
non-deterministic calls. It is currently undocumented and should be 
defined of type <CODE>void*</CODE>. Here is an example:

<PRE class="code">
static foreign_t
atom_checksum(term_t a0, int arity, void* context)
{ char *s;

  if ( PL_get_atom_chars(a0, &amp;s) )
  { int sum;

    for(sum=0; *s; s++)
      sum += *s&amp;0xff;

    return PL_unify_integer(a0+1, sum&amp;0xff);
  }

  return FALSE;
}

install_t
install()
{ PL_register_foreign("atom_checksum", 2, atom_checksum, PL_FA_VARARGS);
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_register_foreign()"><VAR>int</VAR> <STRONG>PL_register_foreign</STRONG>(<VAR>const 
char *name, int arity, foreign_t (*function)(), int flags</VAR>)</A></DT>
<DD class="defbody">
Same as <A class="func" href="foreigninclude.html#PL_register_foreign_in_module()">PL_register_foreign_in_module()</A>, 
passing <CODE>NULL</CODE> for the
<VAR>module</VAR>.</DD>
<DT class="pubdef"><A NAME="PL_register_extensions_in_module()"><VAR>void</VAR> <STRONG>PL_register_extensions_in_module</STRONG>(<VAR>const 
char *module, PL_extension *e</VAR>)</A></DT>
<DD class="defbody">
Register a series of predicates from an array of definitions of the type
<CODE>PL_extension</CODE> in the given <VAR>module</VAR>. If <VAR>module</VAR> 
is
<CODE>NULL</CODE>, the predicate is created in the module of the calling 
context or if no context is present in the module <CODE>user</CODE>. The <CODE>PL_extension</CODE> 
type is defined as

<PRE class="code">
typedef struct PL_extension
{ char          *predicate_name;        /* Name of the predicate */
  short         arity;                  /* Arity of the predicate */
  pl_function_t function;               /* Implementing functions */
  short         flags;                  /* Or of PL_FA_... */
} PL_extension;
</PRE>

<P>For details, see <A class="func" href="foreigninclude.html#PL_register_foreign_in_module()">PL_register_foreign_in_module()</A>. 
Here is an example of its usage:

<PRE class="code">
static PL_extension predicates[] = {
{ "foo",        1,      pl_foo, 0 },
{ "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },
{ NULL,         0,      NULL,   0 }
};

main(int argc, char **argv)
{ PL_register_extensions_in_module("user", predicates);

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  ...
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_register_extensions()"><VAR>void</VAR> <STRONG>PL_register_extensions</STRONG>(<VAR> 
PL_extension *e</VAR>)</A></DT>
<DD class="defbody">
Same as <A class="func" href="foreigninclude.html#PL_register_extensions_in_module()">PL_register_extensions_in_module()</A> 
using <CODE>NULL</CODE> for the <VAR>module</VAR> argument.
</DD>
</DL>

<H3><A NAME="sec:9.4.19"><SPAN class="sec-nr">9.4.19</SPAN> <SPAN class="sec-title">Foreign 
Code Hooks</SPAN></A></H3>

<P>For various specific applications some hooks re provided.

<DL class="latex">
<DT class="pubdef"><A NAME="PL_dispatch_hook()"><VAR>PL_dispatch_hook_t</VAR> <STRONG>PL_dispatch_hook</STRONG>(<VAR>PL_dispatch_hook_t</VAR>)</A></DT>
<DD class="defbody">
If this hook is not NULL, this function is called when reading from the 
terminal. It is supposed to dispatch events when SWI-Prolog is connected 
to a window environment. It can return two values:
<CODE>PL_DISPATCH_INPUT</CODE> indicates Prolog input is available on 
file descriptor 0 or <CODE>PL_DISPATCH_TIMEOUT</CODE> to indicate a 
timeout. The old hook is returned. The type <CODE>PL_dispatch_hook_t</CODE> 
is defined as:

<PRE class="code">
typedef int  (*PL_dispatch_hook_t)(void);
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_abort_hook()"><VAR>void</VAR> <STRONG>PL_abort_hook</STRONG>(<VAR>PL_abort_hook_t</VAR>)</A></DT>
<DD class="defbody">
Install a hook when <A NAME="idx:abort0:1534"></A><A class="pred" href="toplevel.html#abort/0">abort/0</A> 
is executed. SWI-Prolog <A NAME="idx:abort0:1535"></A><A class="pred" href="toplevel.html#abort/0">abort/0</A> 
is implemented using C setjmp()/longjmp() construct. The hooks are 
executed in the reverse order of their registration after the longjmp() 
took place and before the Prolog top-level is reinvoked. The type
<CODE>PL_abort_hook_t</CODE> is defined as:

<PRE class="code">
typedef void (*PL_abort_hook_t)(void);
</PRE>

</DD>
<DT class="pubdef"><A NAME="PL_abort_unhook()"><VAR>int</VAR> <STRONG>PL_abort_unhook</STRONG>(<VAR>PL_abort_hook_t</VAR>)</A></DT>
<DD class="defbody">
Remove a hook installed with <A class="func" href="foreigninclude.html#PL_abort_hook()">PL_abort_hook()</A>. 
Returns <CODE>FALSE</CODE> if no such hook is found, <CODE>TRUE</CODE> 
otherwise.
</DD>
<DT class="pubdef"><A NAME="PL_on_halt()"><VAR>void</VAR> <STRONG>PL_on_halt</STRONG>(<VAR>void 
(*f)(int, void *), void *closure</VAR>)</A></DT>
<DD class="defbody">
Register the function <VAR>f</VAR> to be called if SWI-Prolog is halted. 
The function is called with two arguments: the exit code of the process 
(0 if this cannot be determined on your operating system) and the
<VAR>closure</VAR> argument passed to the <A class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</A> 
call. See also
<A NAME="idx:athalt1:1536"></A><A class="pred" href="consulting.html#at_halt/1">at_halt/1</A>.
</DD>
<DT class="pubdef"><A NAME="PL_agc_hook()"><VAR>PL_agc_hook_t</VAR> <STRONG>PL_agc_hook</STRONG>(<VAR>PL_agc_hook_t 
new</VAR>)</A></DT>
<DD class="defbody">
Register a hook with the atom-garbage collector (see
<A NAME="idx:garbagecollectatoms0:1537"></A><A class="pred" href="memory.html#garbage_collect_atoms/0">garbage_collect_atoms/0</A> 
that is called on any atom that is reclaimed. The old hook is returned. 
If no hook is currently defined, <CODE>NULL</CODE> is returned. The 
argument of the called hook is the atom that is to be garbage collected. 
The return value is an <CODE>int</CODE>. If the return value is zero, 
the atom is <B>not</B> reclaimed. The hook may invoke any Prolog 
predicate.

<P>The example below defines a foreign library for printing the garbage 
collected atoms for debugging purposes.

<PRE class="code">
#include &lt;SWI-Stream.h&gt;
#include &lt;SWI-Prolog.h&gt;

static int
atom_hook(atom_t a)
{ Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));

  return TRUE;
}

static PL_agc_hook_t old;

install_t
install()
{ old = PL_agc_hook(atom_hook);
}

install_t
uninstall()
{ PL_agc_hook(old);
}
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:9.4.20"><SPAN class="sec-nr">9.4.20</SPAN> <SPAN class="sec-title">Storing 
foreign data</SPAN></A></H3>

<A NAME="sec:foreigndata"></A>

<P>This section provides some hints for handling foreign data in Prolog. 
With foreign data, we refer to data that is used by foreign language 
predicates and needs to be passed around in Prolog. Excluding 
combinations, there are three principal options for storing such data

<P>
<UL class="latex">
<LI><I>Natural Prolog data</I><BR>
E.i. using the representation one would choose if there was no foreign 
interface required.
<LI><I>Opaque packed Prolog data</I><BR>
Data can also be represented in a foreign structure and stored on the 
Prolog stacks using <A class="func" href="foreigninclude.html#PL_put_string_nchars()">PL_put_string_nchars()</A> 
and retrieved using
<A class="func" href="foreigninclude.html#PL_get_string_chars()">PL_get_string_chars()</A>. 
It is generally good practice to wrap the string in a compound term with 
arity 1, so Prolog can identify the type. <A NAME="idx:portray1:1538"></A><A class="pred" href="termrw.html#portray/1">portray/1</A> 
rules may be used to streamline printing such terms during development.
<LI><I>Natural foreign data, passing a pointer</I><BR>
An alternative is to pass a pointer to the foreign data. Again, this 
functor may be wrapped in a compound term.
</UL>

<P>The choice may be guided using the following distinctions

<P>
<UL class="latex">
<LI><I>Is the data opaque to Prolog</I><BR>
With `opaque' data, we refer to data handled in foreign functions, 
passed around in Prolog, but of which Prolog never examines the contents 
of the data itself. If the data is opaque to Prolog, the chosen 
representation does not depend on simple analysis by Prolog, and the 
selection will be driven solely by simplicity of the interface and 
performance (both in time and space).
<LI><I>How big is the data</I><BR>
Is efficient encoding required? For examine, a boolean array may be 
expressed as a compound term, holding integers each of which contains a 
number of bits, or as a list of <CODE>true</CODE> and <CODE>false</CODE>.
<LI><I>What is the nature of the data</I><BR>
For examples in C, constants are often expressed using `enum' or
#define'd integer values. If prolog needs to handle this data, atoms are 
a more logical choice. Whether or not this mapping is used depends on 
whether Prolog needs to interpret the data, how important debugging is 
and how important performance is.
<LI><I>What is the lifetime of the data</I><BR>
We can distinguish three cases.
<OL class="latex">
<LI>The lifetime is dictated by the accessibility of the data on the 
Prolog stacks. Their is no way by which the foreign code when the data 
becomes `garbage', and the data thus needs to be represented on the 
Prolog stacks using Prolog data-types. (2),
<LI>The data lives on the `heap' and is explicitly allocated and 
deallocated. In this case, representing the data using native foreign 
representation and passing a pointer to it is a sensible choice.
<LI>The data lives as during the lifetime of a foreign predicate. If the 
predicate is deterministic, foreign automatic variables are suitable. if 
the predicate is non-deterministic, the data may be allocated using 
malloc() and a pointer may be passed. See <A class="sec" href="foreigninclude.html">section 
9.4.1.1</A>.
</OL>
</UL>

<H4><A NAME="sec:9.4.20.1"><SPAN class="sec-nr">9.4.20.1</SPAN> <SPAN class="sec-title">Examples 
for storing foreign data</SPAN></A></H4>

<P>In this section, we will outline some examples, covering typical 
cases. In the first example, we will deal with extending Prolog's data 
representation with integer-sets, represented as bit-vectors. Finally, 
we discuss the outline of the DDE interface.

<P><B>Integer sets</B> with not-too-far-apart upper- and lower-bounds 
can be represented using bit-vectors. Common set operations, such as 
union, intersection, etc. are reduced to simple and'ing and or'ing the 
bit-vectors. This can be done using Prolog's unbounded integers.

<P>For really demanding applications, foreign representation will 
perform better, especially time-wise. Bit-vectors are naturally 
expressed using string objects. If the string is wrapped in <CODE>bitvector/1</CODE>, 
lower-bound of the vector is 0, and the upper-bound is not defined, an 
implementation for getting and putting the sets as well as the union 
predicate for it is below.

<PRE class="code">
#include &lt;SWI-Prolog.h&gt;

#define max(a, b) ((a) &gt; (b) ? (a) : (b))
#define min(a, b) ((a) &lt; (b) ? (a) : (b))

static functor_t FUNCTOR_bitvector1;

static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, in, a);
    return PL_get_string(a, (char **)data, len);
  }

  PL_fail;
}

static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, out, a);

    return PL_unify_string_nchars(a, len, (const char *)data);
  }

  PL_fail;
}

static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
  int l1, l2;

  if ( get_bitvector(t1, &amp;l1, &amp;s1) &amp;&amp;
       get_bitvector(t2, &amp;l2, &amp;s2) )
  { int l = max(l1, l2);
    unsigned char *s3 = alloca(l);

    if ( s3 )
    { int n;
      int ml = min(l1, l2);

      for(n=0; n&lt;ml; n++)
        s3[n] = s1[n] | s2[n];
      for( ; n &lt; l1; n++)
        s3[n] = s1[n];
      for( ; n &lt; l2; n++)
        s3[n] = s2[n];

      return unify_bitvector(u, l, s3);
    }

    return PL_warning("Not enough memory");
  }

  PL_fail;
}


install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);

  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}
</PRE>

<P><B>The DDE interface</B> (see <A class="sec" href="DDE.html">section 
4.40</A>) represents another common usage of the foreign interface: 
providing communication to new operating system features. The DDE 
interface requires knowledge about active DDE server and client 
channels. These channels contains various foreign data-types. Such an 
interface is normally achieved using an open/close protocol that creates 
and destroys a <EM>handle</EM>. The handle is a reference to a foreign 
data-structure containing the relevant information.

<P>There are a couple of possibilities for representing the handle. The 
choice depends on responsibilities and debugging facilities. The 
simplest approach is to using <A class="func" href="foreigninclude.html#PL_unify_pointer()">PL_unify_pointer()</A> 
and <A class="func" href="foreigninclude.html#PL_get_pointer()">PL_get_pointer()</A>. 
This approach is fast and easy, but has the drawbacks of (untyped) 
pointers: there is no reliable way to detect the validity of the 
pointer, not to verify it is pointing to a structure of the desired 
type. The pointer may be wrapped into a compound term with arity 1 
(i.e., <CODE>dde_channel(&lt;<VAR>Pointer</VAR>&gt;)</CODE>), making the 
type-problem less serious.

<P>Alternatively (used in the DDE interface), the interface code can 
maintain a (preferably variable length) array of pointers and return the 
index in this array. This provides better protection. Especially for 
debugging purposes, wrapping the handle in a compound is a good 
suggestion.

<H3><A NAME="sec:9.4.21"><SPAN class="sec-nr">9.4.21</SPAN> <SPAN class="sec-title">Embedding 
SWI-Prolog in other applications</SPAN></A></H3>

<A NAME="sec:embedded"></A>

<P>With embedded Prolog we refer to the situation where the `main' 
program is not the Prolog application. Prolog is sometimes embedded in 
C, C++, Java or other languages to provide logic based services in a 
larger application. Embedding loads the Prolog engine as a library to 
the external language. Prolog itself only provides for embedding in the 
C-language (compatible with C++). Embedding in Java is achieved using 
JPL using a C-glue between the Java and Prolog C-interfaces.

<P>The most simple embedded program is below. The interface function
<A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A> <B>must</B> 
be called before any of the other SWI-Prolog foreign language functions 
described in this chapter, except for
<B>PL_initialise_hook()</B>, <A class="func" href="foreigninclude.html#PL_new_atom()">PL_new_atom()</A>, <A class="func" href="foreigninclude.html#PL_new_functor()">PL_new_functor()</A> 
and
<A class="func" href="foreigninclude.html#PL_register_foreign()">PL_register_foreign()</A>. <A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A> 
interprets all the command-line arguments, except for the <STRONG>-t</STRONG> <VAR>toplevel</VAR> 
flag that is interpreted by <A class="func" href="foreigninclude.html#PL_toplevel()">PL_toplevel()</A>.

<PRE class="code">
int
main(int argc, char **argv)
{
#ifdef READLINE /* Remove if you don't want readline */
  PL_initialise_hook(install_readline);
#endif

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_halt(PL_toplevel() ? 0 : 1);
}
</PRE>

<DL class="latex">
<DT class="pubdef"><A NAME="PL_initialise()"><VAR>int</VAR> <STRONG>PL_initialise</STRONG>(<VAR>int 
argc, char **argv</VAR>)</A></DT>
<DD class="defbody">
Initialises the SWI-Prolog heap and stacks, restores the Prolog state, 
loads the system and personal initialisation files, runs the <A NAME="idx:atinitialization1:1539"></A><SPAN class="pred-ext">at_initialization/1</SPAN> 
hooks and finally runs the
<STRONG>-g</STRONG> <VAR>goal</VAR> hook.

<P>Special consideration is required for <CODE>argv[0]</CODE>. On <B>Unix</B>, 
this argument passes the part of the command-line that is used to locate 
the executable. Prolog uses this to find the file holding the running 
executable. The <B>Windows</B> version uses this to find a <EM>module</EM> 
of the running executable. If the specified module cannot be found, it 
tries the module <CODE>libpl.dll</CODE>, containing the Prolog runtime 
kernel. In all these cases, the resulting file is used for two purposes

<P>
<UL class="latex">
<LI>See whether a Prolog saved-state is appended to the file. If this is 
the case, this state will be loaded instead of the default <CODE>boot.prc</CODE> 
file from the SWI-Prolog home directory. See also <A NAME="idx:qsaveprogram12:1540"></A><A class="pred" href="runtime.html#qsave_program/1">qsave_program/[1,2]</A> 
and <A class="sec" href="plld.html">section 9.5</A>.
<LI>Find the Prolog home directory. This process is described in detail 
in <A class="sec" href="findhome.html">section 9.6</A>.
</UL>

<P><A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A> 
returns 1 if all initialisation succeeded and 0 otherwise.<SUP class="fn">bug<SPAN class="fn-text">Various 
fatal errors may cause PL_initialise to call <A class="func" href="foreigninclude.html#PL_halt()">PL_halt(1)</A>, 
preventing it from returning at all.</SPAN></SUP>

<P>In most cases, <VAR>argc</VAR> and <VAR>argv</VAR> will be passed 
from the main program. It is allowed to create your own argument vector, 
provided
<CODE>argv[0]</CODE> is constructed according to the rules above. For 
example:

<PRE class="code">
int
main(int argc, char **argv)
{ char *av[10];
  int ac = 0;

  av[ac++] = argv[0];
  av[ac++] = "-x";
  av[ac++] = "mystate";
  av[ac]   = NULL;

  if ( !PL_initialise(ac, av) )
    PL_halt(1);
  ...
}
</PRE>

<P>Please note that the passed argument vector may be referred from 
Prolog at any time and should therefore be valid as long as the Prolog 
engine is used.

<P>A good setup in Windows is to add SWI-Prolog's <CODE>bin</CODE> 
directory to your <CODE>PATH</CODE> and either pass a module holding a 
saved-state, or
<CODE>"libpl.dll"</CODE> as <CODE>argv[0]</CODE>. If the Prolog state is 
attached to a DLL (see the <STRONG>-dll</STRONG> option of <B>swipl-ld</B>, 
pass the name of this DLL.</DD>
<DT class="pubdef"><A NAME="PL_is_initialised()"><VAR>int</VAR> <STRONG>PL_is_initialised</STRONG>(<VAR>int 
*argc, char ***argv</VAR>)</A></DT>
<DD class="defbody">
Test whether the Prolog engine is already initialised. Returns
<CODE>FALSE</CODE> if Prolog is not initialised and <CODE>TRUE</CODE> 
otherwise. If the engine is initialised and <VAR>argc</VAR> is not <CODE>NULL</CODE>, 
the argument count used with <A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A> 
is stored in <VAR>argc</VAR>. Same for the argument vector <VAR>argv</VAR>.</DD>
<DT class="pubdef"><A NAME="PL_install_readline()"><VAR>void</VAR> <STRONG>PL_install_readline</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Installs the GNU-readline line-editor. Embedded applications that do not 
use the Prolog top-level should normally delete this line, shrinking the 
Prolog kernel significantly. Note that the Windows version does not use 
GNU readline.</DD>
<DT class="pubdef"><A NAME="PL_toplevel()"><VAR>int</VAR> <STRONG>PL_toplevel</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Runs the goal of the <STRONG>-t</STRONG> <VAR>toplevel</VAR> switch 
(default <A NAME="idx:prolog0:1541"></A><A class="pred" href="toplevel.html#prolog/0">prolog/0</A>) 
and returns 1 if successful, 0 otherwise.</DD>
<DT class="pubdef"><A NAME="PL_cleanup()"><VAR>int</VAR> <STRONG>PL_cleanup</STRONG>(<VAR>int 
status</VAR>)</A></DT>
<DD class="defbody">
This function performs the reverse of <A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A>. 
It runs the
<A class="func" href="foreigninclude.html#PL_on_halt()">PL_on_halt()</A> 
and <A NAME="idx:athalt1:1542"></A><A class="pred" href="consulting.html#at_halt/1">at_halt/1</A> 
handlers, closes all streams (except for the `standard I/O' streams 
which are flushed only), deallocates all memory and restores all signal 
handlers. The <VAR>status</VAR> argument is passed to the various 
termination hooks and indicates the <EM>exit-status</EM>.

<P>The function returns <CODE>TRUE</CODE> if successful and <CODE>FALSE</CODE> 
otherwise. Currently, <CODE>FALSE</CODE> is returned when an attempt is 
made to call <A class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</A> 
recursively or if <A class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</A> 
is not called from the main-thread.

<P>In theory, this function allows deleting and restarting the Prolog 
system in the same process. In practice, SWI-Prolog's cleanup process is 
far from complete and trying to revive the system using <A class="func" href="foreigninclude.html#PL_initialise()">PL_initialise()</A> 
will leak memory in the best case. It can also crash the appliction.

<P>In this state, there is little practical use for this function. If 
you want to use Prolog temporary consider running it in a separate 
process. If you want to be able to reset Prolog your options are (again) 
a separate process, modules or threads.</DD>
<DT class="pubdef"><A NAME="PL_cleanup_fork()"><VAR>void</VAR> <STRONG>PL_cleanup_fork</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Close file descriptors associated to Prolog streams except for 0,1&nbsp;and&nbsp;2. 
Stop intervaltimer that may be running on behalf of <A NAME="idx:profile1:1543"></A><A class="pred" href="profile.html#profile/1">profile/1</A>. 
The call is intended to be used in combination with fork():

<PRE class="code">
    if ( (pid=fork()) == 0 )
    { PL_cleanup_fork();
      &lt;some exec variation&gt;
    }
</PRE>

<P>The call behaves the same on Windows, though there is probably no 
meaningful application.</DD>
<DT class="pubdef"><A NAME="PL_halt()"><VAR>int</VAR> <STRONG>PL_halt</STRONG>(<VAR>int 
status</VAR>)</A></DT>
<DD class="defbody">
Cleanup the Prolog environment using <A class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</A> 
and calls exit() with the status argument. As <A class="func" href="foreigninclude.html#PL_cleanup()">PL_cleanup()</A> 
can only be called from the main thread, this function returns <CODE>FALSE</CODE> 
when called from another thread as the main one.<SUP class="fn">bug<SPAN class="fn-text">Eventually 
it may become possible to call <A class="func" href="foreigninclude.html#PL_halt()">PL_halt()</A> 
from any thread.</SPAN></SUP>
</DD>
</DL>

<H4><A NAME="sec:9.4.21.1"><SPAN class="sec-nr">9.4.21.1</SPAN> <SPAN class="sec-title">Threading, 
Signals and embedded Prolog</SPAN></A></H4>

<A NAME="sec:sigembedded"></A>

<P>This section applies to Unix-based environments that have signals or 
multi-threading. The Windows version is compiled for multi-threading and 
Windows lacks proper signals.

<P>We can distinguish two classes of embedded executables. There are 
small C/C++-programs that act as an interfacing layer around Prolog. 
Most of these programs can be replaced using the normal Prolog 
executable extended with a dynamically loaded foreign extension and in 
most cases this is the preferred route. In other cases, Prolog is 
embedded in a complex application that---like Prolog---wants to control 
the process environment. A good example is Java. Embedding Prolog is 
generally the only way to get these environments together in one process 
image. Java applications however are by nature multi-threaded and appear 
to do signal-handling (software interrupts).

<P>On Unix systems, SWI-Prolog uses three signals:

<DL class="latex">
<DT><B>SIGUSR1</B></DT>
<DD>
is used to sychronise atom- and clause garbage collection. The handler 
is installed at the start of GC and reverted to the old setting after 
completing.</DD>
<DT><B>SIGUSR2</B></DT>
<DD>
has an empty signal handler. This signal is sent to a thread after 
sending a thread-signal (see
<A NAME="idx:threadsignal2:1544"></A><A class="pred" href="threadcom.html#thread_signal/2">thread_signal/2</A>). 
It causes blocking system calls to return with <CODE>EINTR</CODE>, which 
gives them to opportunity to react on thread-signals.</DD>
<DT><B>SIGINT</B></DT>
<DD>
is used by the toplevel to activate the tracer (typically bound to 
control-C). The first control-C posts a request for starting the tracer 
in a safe synchronous fashion. If control-C is hit again before the safe 
route is executed, it prompts the user whether or not a forced interrupt 
is desired.
</DD>
</DL>

<P>The <STRONG>--nosignals</STRONG> option can be used to inhibit 
processing of <CODE>SIGINT</CODE>. The other signals are vital for the 
functioning of SWI-Prolog. If they conflict with other applications, 
signal handling of either component must be modified. The SWI-Prolog 
signals are defined in
<CODE>pl-thread.h</CODE> of the source-distribution.

<P></BODY></HTML>