<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.10.5 Reference Manual: Section A.16</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=summary HREF="summary.html">
<LINK REL=previous HREF="option.html">
<LINK REL=next HREF="ordsets.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

dt.multidef
{ background-color: #c8ffc7;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="summary.html"><IMG SRC="info.gif" BORDER=0 ALT="Summary"></A>
<A class="nav" href="option.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="ordsets.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:A.16"><SPAN class="sec-nr">A.16</SPAN> <SPAN class="sec-title">library(optparse): 
command line parsing</SPAN></A></H2>

<P><A NAME="sec:optparse"></A>

<DL>
<DT><B>author</B><DD> Marcus Uneson
<DT><B>version</B><DD> 0.20 (2011-04-27)
<DT><B>To be done</B><DD> : validation? e.g, numbers; file path 
existence; one-out-of-a-set-of-atoms
</DL>

<P>This module helps in building a command-line interface to an 
application. In particular, it provides functions that take an option 
specification and a list of atoms, probably given to the program on the 
command line, and return a parsed representation (a list of the 
customary Key(Val) by default; or optionally, a list of Func(Key, Val) 
terms in the style of <A class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</A>). 
It can also synthesize a simple help text from the options 
specification.

<P>The terminology in the following is partly borrowed from python, see
<A class="url" href="http://docs.python.org/library/optparse.html\#terminology">http://docs.python.org/library/optparse.html\#terminology</A> 
. Very briefly,
<I>arguments</I> is what you provide on the command line and for many 
prologs show up as a list of atoms <CODE>Args</CODE> in <CODE>current_prolog_flag(argv, Args)</CODE>. 
For a typical prolog incantation, they can be divided into

<P>
<UL class="latex">
<LI><I>runtime arguments</I>, which controls the prolog runtime; 
conventionally, they are ended by '--';
<LI><I>options</I>, which are key-value pairs (with a boolean value 
possibly implicit) intended to control your program in one way or 
another; and
<LI><I>positional arguments</I>, which is what remains after all runtime 
arguments and options have been removed (with implicit arguments -- 
true/false for booleans -- filled in).
</UL>

<P>Positional arguments are in particular used for mandatory arguments 
without which your program won't work and for which there are no 
sensible defaults (e.g,, input file names). Options, by contrast, offer 
flexibility by letting you change a default setting. Options are 
optional not only by etymology: this library has no notion of mandatory 
or required options (see the python docs for other rationales than 
laziness).

<P>The command-line arguments enter your program as a list of atoms, but 
the programs perhaps expects booleans, integers, floats or even prolog 
terms. You tell the parser so by providing an <I>options specification</I>. 
This is just a list of individual option specifications. One of those, 
in turn, is a list of ground prolog terms in the customary Name(Value) 
format. The following terms are recognized (any others raise error).

<DL class="latex">
<DT><STRONG>opt</STRONG>(<VAR>Key</VAR>)</DT>
<DD class="defbody">
Key is what the option later will be accessed by, just like for 
current_prolog_flag(Key, Value). This term is mandatory (an error is 
thrown if missing).
</DD>
<DT><STRONG>shortflags</STRONG>(<VAR>ListOfFlags</VAR>)</DT>
<DD class="defbody">
ListOfFlags denotes any single-dashed, single letter args specifying the 
current option (<CODE>-s , -K</CODE>, etc). Uppercase letters must be 
quoted. Usually ListOfFlags will be a singleton list, but sometimes 
aliased flags may be convenient.
</DD>
<DT><STRONG>longflags</STRONG>(<VAR>ListOfFlags</VAR>)</DT>
<DD class="defbody">
ListOfFlags denotes any double-dashed arguments specifying the current 
option (<CODE>--verbose, --no-debug</CODE>, etc). They are basically a 
more readable alternative to short flags, except
</DD>
</DL>

<P>
<OL class="latex">
<LI>long flags can be specified as <CODE>--flag value</CODE> or
<CODE>--flag=value</CODE> (but not as <CODE>--flagvalue</CODE>); short 
flags as
<CODE>-f val</CODE> or <CODE>-fval</CODE> (but not <CODE>-f=val</CODE>)
<LI>boolean long flags can be specified as <CODE>--bool-flag</CODE> or <CODE>--bool-flag=true</CODE> 
or <CODE>--bool-flag true</CODE>; and they can be negated as <CODE>--no-bool-flag</CODE> 
or <CODE>--bool-flag=false</CODE> or
<CODE>--bool-flag false</CODE>.

<P>Except that shortflags must be single characters, the distinction 
between long and short is in calling convention, not in namespaces. 
Thus, if you have shortflags([v]), you can use it as <CODE>-v2</CODE> or <CODE>-v 2</CODE> 
or <CODE>--v=2</CODE> or <CODE>--v 2</CODE> (but not
<CODE>-v=2</CODE> or <CODE>--v2</CODE>).

<P>Shortflags and longflags both default to <CODE>[]</CODE>. It can be 
useful to have flagless options -- see example below.
</OL>

<DL class="latex">
<DT><STRONG>meta</STRONG>(<VAR>Meta</VAR>)</DT>
<DD class="defbody">
Meta is optional and only relevant for the synthesized usage message and 
is the name (an atom) of the metasyntactic variable (possibly) appearing 
in it together with type and default value (e.g,
<CODE>x:integer=3</CODE>, <CODE>interest:float=0.11</CODE>). It may be 
useful to have named variables (<CODE>x</CODE>, <CODE>interest</CODE>) 
in case you wish to mention them again in the help text. If not given 
the <CODE>Meta:</CODE> part is suppressed -- see example below.
</DD>
<DT><STRONG>type</STRONG>(<VAR>Type</VAR>)</DT>
<DD class="defbody">
Type is one of <CODE>boolean, atom, integer, float, term</CODE>. The 
corresponding argument will be parsed appropriately. This term is 
optional; if not given, defaults to <CODE>term</CODE>.
</DD>
<DT><STRONG>default</STRONG>(<VAR>Default</VAR>)</DT>
<DD class="defbody">
Default value. This term is optional; if not given, or if given the 
special value '_', an uninstantiated variable is created (and any type 
declaration is ignored).
</DD>
<DT><STRONG>help</STRONG>(<VAR>Help</VAR>)</DT>
<DD class="defbody">
Help is (usually) an atom of text describing the option in the help 
text. This term is optional (but obviously strongly recommended for all 
options which have flags).

<P>Long lines are subject to basic word wrapping -- split on white 
space, reindent, rejoin. However, you can get more control by supplying 
the line breaking yourself: rather than a single line of text, you can 
provide a list of lines (as atoms). If you do, they will be joined with 
the appropriate indent but otherwise left untouched (see the option <CODE>mode</CODE> 
in the example below).
</DD>
</DL>

<P>Absence of mandatory option specs or the presence of more than one 
for a particular option throws an error, as do unknown or incompatible 
types.

<P>As a concrete example from a fictive application, suppose we want the 
following options to be read from the command line (long flag(s), short 
flag(s), meta:type=default, help)

<PRE class="code">
--mode                  -m     atom=SCAN       data gathering mode, one of
                                                   SCAN: do this
                                                   READ: do that
                                                   MAKE: fabricate some numbers
                                                   WAIT: don't do anything
--rebuild-cache         -r     boolean=true    rebuild cache in each iteration
--heisenberg-threshold  -t,-h  float=0.1       heisenberg threshold
--depths, --iters       -i,-d  K:integer=3     stop after K iterations
--distances                    term=[1,2,3,5]  initial prolog term
--output-file           -o     FILE:atom=_     write output to FILE
--label                 -l     atom=REPORT     report label
--verbosity             -v     V:integer=2     verbosity level, 1 &lt;= V &lt;= 3
</PRE>

<P>We may also have some configuration parameters which we currently 
think not needs to be controlled from the command line, say 
path('/some/file/path').

<P>This interface is described by the following options specification 
(order between the specifications of a particular option is irrelevant).

<PRE class="code">
ExampleOptsSpec =
    [ [opt(mode    ), type(atom), default('SCAN'),
        shortflags([m]),   longflags(['mode'] ),
        help([ 'data gathering mode, one of'
             , '  SCAN: do this'
             , '  READ: do that'
             , '  MAKE: fabricate some numbers'
             , '  WAIT: don''t do anything'])]

    , [opt(cache), type(boolean), default(true),
        shortflags([r]),   longflags(['rebuild-cache']),
        help('rebuild cache in each iteration')]

    , [opt(threshold), type(float), default(0.1),
        shortflags([t,h]),  longflags(['heisenberg-threshold']),
        help('heisenberg threshold')]

    , [opt(depth), meta('K'), type(integer), default(3),
        shortflags([i,d]),longflags([depths,iters]),
        help('stop after K iterations')]

    , [opt(distances), default([1,2,3,5]),
        longflags([distances]),
        help('initial prolog term')]

    , [opt(outfile), meta('FILE'), type(atom),
        shortflags([o]),  longflags(['output-file']),
        help('write output to FILE')]

    , [opt(label), type(atom), default('REPORT'),
        shortflags([l]), longflags([label]),
        help('report label')]

    , [opt(verbose),  meta('V'), type(integer), default(2),
        shortflags([v]),  longflags([verbosity]),
        help('verbosity level, 1 &lt;= V &lt;= 3')]

    , [opt(path), default('/some/file/path/')]
    ].
</PRE>

<P>The help text above was accessed by <CODE>opt_help(ExamplesOptsSpec, HelpText)</CODE>. 
The options appear in the same order as in the OptsSpec.

<P>Given <CODE>ExampleOptsSpec</CODE>, a command line (somewhat 
syntactically inconsistent, in order to demonstrate different calling 
conventions) may look as follows

<PRE class="code">
ExampleArgs = [ '-d5'
              , '--heisenberg-threshold', '0.14'
              , '--distances=[1,1,2,3,5,8]'
              , '--iters', '7'
              , '-ooutput.txt'
              , '--rebuild-cache', 'true'
              , 'input.txt'
              , '--verbosity=2'
              ].
</PRE>

<P>opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs) would 
then succeed with

<PRE class="code">
Opts =    [ mode('SCAN')
          , label('REPORT')
          , path('/some/file/path')
          , threshold(0.14)
          , distances([1,1,2,3,5,8])
          , depth(7)
          , outfile('output.txt')
          , cache(true)
          , verbose(2)
          ],
PositionalArgs = ['input.txt'].
</PRE>

<P>Note that path('/some/file/path') showing up in Opts has a default 
value (of the implicit type 'term'), but no corresponding flags in 
OptsSpec. Thus it can't be set from the command line. The rest of your 
program doesn't need to know that, of course. This provides an 
alternative to the common practice of asserting such hard-coded 
parameters under a single predicate (for instance setting(path, 
'/some/file/path')), with the advantage that you may seamlessly upgrade 
them to command-line options, should you one day find this a good idea. 
Just add an appropriate flag or two and a line of help text. Similarly, 
suppressing an option in a cluttered interface amounts to commenting out 
the flags.

<P><A class="pred" href="optparse.html#opt_parse/5">opt_parse/5</A> 
allows more control through an additional argument list. For instance, 
opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs, 
[output_functor(appl_config)]) would instead return

<PRE class="code">
Opts =    [ appl_config(verbose, 2),
          , appl_config(label, 'REPORT')
          ...
          ]
</PRE>

<P>This representation may be preferable with the empty-flag 
configuration parameter style above (perhaps with asserting <SPAN class="pred-ext">appl_config/2</SPAN>).

<H3><A NAME="sec:A.16.1"><SPAN class="sec-nr">A.16.1</SPAN> <SPAN class="sec-title">Notes 
and tips</SPAN></A></H3>

<P>
<UL class="latex">
<LI>In the example we were mostly explicit about the types. Since the 
default is <CODE>term</CODE>, which subsumes <CODE>integer, float, atom</CODE>, 
it may be possible to get away cheaper (e.g., by only giving booleans). 
However, it is recommended practice to always specify types: parsing 
becomes more reliable and error messages will be easier to interpret.
<LI>Note that <CODE>-sbar</CODE> is taken to mean <CODE>-s bar</CODE>, 
not <CODE>-s -b -a -r</CODE>, that is, there is no clustering of flags.
<LI><CODE>-s=foo</CODE> is disallowed. The rationale is that although 
some command-line parsers will silently interpret this as <CODE>-s =foo</CODE>, 
this is very seldom what you want. To have an option argument start with 
'=' (very un-recommended), say so explicitly.
<LI>The example specifies the option <CODE>depth</CODE> twice: once as
<CODE>-d5</CODE> and once as <CODE>--iters 7</CODE>. The default when 
encountering duplicated flags is to <CODE>keeplast</CODE> (this 
behaviour can be controlled, by ParseOption duplicated_flags).
<LI>The order of the options returned by the parsing functions is the 
same as given on the command line, with non-overridden defaults 
prepended and duplicates removed as in previous item. You should not 
rely on this, however.
<LI>Unknown flags (not appearing in OptsSpec) will throw errors. This is 
usually a Good Thing. Sometimes, however, you may wish to pass along 
flags to an external program (say, one called by <A class="pred" href="system.html#shell/2">shell/2</A>), 
and it means duplicated effort and a maintenance headache to have to 
specify all possible flags for the external program explicitly (if it 
even can be done). On the other hand, simply taking all unknown flags as 
valid makes error checking much less efficient and identification of 
positional arguments uncertain. A better solution is to collect all 
arguments intended for passing along to an indirectly called program as 
a single argument, probably as an atom (if you don't need to inspect 
them first) or as a prolog term (if you do).
</UL>

<DL class="latex">
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="opt_arguments/3"><STRONG>opt_arguments</STRONG>(<VAR>+OptsSpec, 
-Opts, -PositionalArgs</VAR>)</A></DT>
<DD class="defbody">
Convenience predicate, assuming that command-line arguments can be 
accessed by <A class="pred" href="flags.html#current_prolog_flag/2">current_prolog_flag/2</A> 
(as in swi-prolog). For other access mechanisms and/or more control, get 
the args and pass them as a list of atoms to <A class="pred" href="optparse.html#opt_parse/4">opt_parse/4</A> 
or <A class="pred" href="optparse.html#opt_parse/5">opt_parse/5</A> 
instead.

<P><VAR>Opts</VAR> is a list of parsed options in the form Key(Value). 
Dashed args not in <VAR>OptsSpec</VAR> are not permitted and will raise 
error (see tip on how to pass unknown flags in the module description).
<VAR>PositionalArgs</VAR> are the remaining non-dashed args after each 
flag has taken its argument (filling in <CODE>true</CODE> or <CODE>false</CODE> 
for booleans). There are no restrictions on non-dashed arguments and 
they may go anywhere (although it is good practice to put them last). 
Any leading arguments for the runtime (up to and including '--') are 
discarded.</DD>
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="opt_parse/4"><STRONG>opt_parse</STRONG>(<VAR>+OptsSpec, 
+ApplArgs, -Opts, -PositionalArgs</VAR>)</A></DT>
<DD class="defbody">
Equivalent to opt_parse(<VAR>OptsSpec</VAR>, <VAR>ApplArgs</VAR>, <VAR>Opts</VAR>, <VAR>PositionalArgs</VAR>, 
[]).</DD>
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="opt_parse/5"><STRONG>opt_parse</STRONG>(<VAR>+OptsSpec, 
+ApplArgs, -Opts, -PositionalArgs, +ParseOptions</VAR>)</A></DT>
<DD class="defbody">
Parse the arguments Args (as list of atoms) according to <VAR>OptsSpec</VAR>. 
Any runtime arguments (typically terminated by '--') are assumed to be 
removed already.

<P><VAR>Opts</VAR> is a list of parsed options in the form Key(Value), 
or (with the option functor(Func) given) in the form Func(Key, Value). 
Dashed args not in <VAR>OptsSpec</VAR> are not permitted and will raise 
error (see tip on how to pass unknown flags in the module description).
<VAR>PositionalArgs</VAR> are the remaining non-dashed args after each 
flag has taken its argument (filling in <CODE>true</CODE> or <CODE>false</CODE> 
for booleans). There are no restrictions on non-dashed arguments and 
they may go anywhere (although it is good practice to put them last).
<VAR>ParseOptions</VAR> are

<DL class="latex">
<DT><STRONG>output_functor</STRONG>(<VAR>Func</VAR>)</DT>
<DD class="defbody">
Set the functor Func of the returned options Func(Key,Value). Default is 
the special value 'OPTION' (upper-case), which makes the returned 
options have form Key(Value).
</DD>
<DT><STRONG>duplicated_flags</STRONG>(<VAR>Keep</VAR>)</DT>
<DD class="defbody">
Controls how to handle options given more than once on the commad line. 
Keep is one of <CODE>keepfirst, keeplast, keepall</CODE> with the 
obvious meaning. Default is <CODE>keeplast</CODE>.
</DD>
<DT><STRONG>allow_empty_flag_spec</STRONG>(<VAR>Bool</VAR>)</DT>
<DD class="defbody">
If true (default), a flag specification is not required (it is allowed 
that both shortflags and longflags be either[]or absent). Flagless 
options cannot be manipulated from the command line and will not show up 
in the generated help. This is useful when you have (also) general 
configuration parameters in your <VAR>OptsSpec</VAR>, especially if you 
think they one day might need to be controlled externally. See example 
in the module overview. allow_empty_flag_spec(false) gives the more 
customary behaviour of raising error on empty flags.
</DD>
</DL>

</DD>
<DT class="pubdef"><span class="pred-tag">[det]</span><A NAME="opt_help/2"><STRONG>opt_help</STRONG>(<VAR>+OptsSpec, 
-Help</VAR>)</A></DT>
<DD class="defbody">
Returns a help string (atom), synthesized from the help descriptions in <VAR>OptsSpec</VAR>.
</DD>
</DL>

<P></BODY></HTML>