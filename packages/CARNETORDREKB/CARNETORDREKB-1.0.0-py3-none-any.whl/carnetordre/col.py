# -*- coding: utf-8 -*-
"""COL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L--ML7J6x1fvtp0mWpwN8pSV7BCv7gRC
"""

#Maintenant nous allons Faire tombé pas mal d'hypothèses simplificatrice que nous avions fait jusque là 
#Nous allons réellement essayer de faire un système de carnet d'ordre qui puisse non seulement traité 
#Des ordres de marché mais même des ordre limites 
#1 Ordre limite bid marche de la façon suivante nous fixons un prix limite et lorsque le meilleur Bid c'est à dire le max
#Aura atteint ce dernier alors notre ordre sera convertit en ordre au marché. 1 Ordre limite Ask fonctionne similairement, on
#fixe un prix limite et lorsque le meilleur ask c'est à dire le min aura atteint ce prix notre ordre sera convertit en ordre au
#Au marché. Et dans notre système de carnet d'ordre en codant nous nous sommes posé la questions pour un même prix lorsque nous avons
#Plusieurs ordres lequel privilégié et là c'est poser la question de l'ordre de priorité nous avons opté pour une approche FIFO ou le 
#premier arrivé sera lui aussi le premier sortit ce qui parrait plus réelle et pour des raisons de simplifications et aussi de simulations
#De la réalité nous avons intégré une notion de temporalité donc nous attribuons un timestamp à chaque ordre
from decimal import * 
import time, random
import sys
import math
from collections import deque 
from six.moves import cStringIO as StringIO
from decimal import Decimal
from sortedcontainers import SortedDict

class Order(object):
    '''
    La classe Order représente l'élément fondamentale de l'exchange. Chaque bid/ask est un Ordre.
    Les Ordres ont un double lien à un même prix bid/ask et on va définir des fonctions qui nous servirons pour
    actualisé les ordres liées à un même prix que seront next_order, prev_order 
    '''
    def __init__(self, quote, order_list):
        self.timestamp = int(quote['timestamp']) # un integer qui représente le temps de la création de l'ordre
        self.quantity = Decimal(quote['quantity']) # Celà représsente la quantité précisé dans l'ordre on peux avoir des quantité non entières
        self.price = Decimal(quote['price']) # Représente le prix précisé dans l'ordre
        self.order_id = int(quote['order_id'])
        self.trade_id = quote['trade_id']
        # une liste doublement liée pour facilité le réarrangement de la liste des ordres pour un même prix
        self.next_order = None
        self.prev_order = None
        self.order_list = order_list

    # Une fonction d'aide qui nous servira pour la réorganisation des ordres dans l'OrderList
    def next_order(self):
        return self.next_order

    def prev_order(self):
        return self.prev_order

    def update_quantity(self, new_quantity, new_timestamp):
        if new_quantity > self.quantity and self.order_list.tail_order != self:
            # une vérification pour voir si l'ordre n'est pas le dernier de la liste OrderList et que la nouvelle quantité précisé n'est pas supérieur à celle de notre ordre
            self.order_list.move_to_tail(self) # Le mettre en queue de liste
        self.order_list.volume -= (self.quantity - new_quantity) # Actualisé le volume de Order_list
        self.timestamp = new_timestamp
        self.quantity = new_quantity

    def __str__(self):
        return "quantité : {}, prix : {}/ Trade_id : {} - Timestamp de l'ordre : {} secondes".format(self.quantity, self.price,
                                      self.trade_id, self.timestamp)
        

class OrderList(object):
    '''
    Comme pour un même prix nous pouvons avoir plusieurs ordres qui lui sont associé alors ces ordres sont contenues dans OrderList
    qui est une list liée à deux prix quand il y a un match c'est à dire deux ou plusieurs ordres au même prix. Cette list est arrangé
    selon le temps et biensûr les ordres en tête de liste ont priorité sur les ordres en fin de queue.  
    '''

    def __init__(self):
        self.head_order = None # Premier Ordre dans la liste
        self.tail_order = None # Derniet ordre dans la liste
        self.length = 0 # Nombre d'ordres dans la liste
        self.volume = 0 # La somme des quantités des ordres dans la liste ou encore le Volume
        self.last = None # On va s'aider de cette élément pour itérer sur la liste

    def __len__(self):
        '''
        Methode spéciale nous retournant le nombre d'ordres
        '''
        return self.length

    def __iter__(self):
        self.last = self.head_order
        return self

    def next(self):
        '''Prend le prochain ordre dans la liste.
        Définit self.last comme étant le prochain ordre. Si il n'y a pas de prochain ordre
        dans la liste alors à ce moment on renvoie une erreur pour arrêter les itérations.
        '''
        if self.last == None:
            raise StopIteration
        else:
            return_value = self.last
            self.last = self.last.next_order
            return return_value

    __next__ = next 

    def get_head_order(self):
      """
      Renvoie l'ordre ayant la priorité
      """
      return self.head_order

    def append_order(self, order):
        """
        Rajoute un ordre à notre liste. Si jamais notre liste est vide, i.e pas d'ordre
        alors ce nouveau ordre va constituer la queue et la tête et il n'y a aucun ordre avant ou après lui.

        """
        if len(self) == 0:
            order.next_order = None
            order.prev_order = None
            self.head_order = order
            self.tail_order = order
        else:
            order.prev_order = self.tail_order
            order.next_order = None
            self.tail_order.next_order = order
            self.tail_order = order
        self.length +=1
        self.volume += order.quantity

    def remove_order(self, order):
        self.volume -= order.quantity
        self.length -= 1
        if len(self) == 0:# Si il n'y a plus d'ordre on ne peut pas en retirer, donc on return rien
            return

        # Pour enlever un ordre de l'OrderList. En premier lieu on prend le next_order / prev_order
        # De l'ordre que l'on va enlever. Puis on refait toutes les bonnes réassociation. Finalement 
        # on enlève l'Ordre.
        next_order = order.next_order
        prev_order = order.prev_order
        if next_order != None and prev_order != None:
            next_order.prev_order = prev_order
            prev_order.next_order = next_order
        elif next_order != None:  # Si il n'y avait pas d'ordre qui précédait l'ordre que l'on enlève
            next_order.prev_order = None
            self.head_order = next_order # L'ordre qui va à la suite de notre ordre que l'on enlève de OrderList deviens la tête après qu'on enlève l'Ordre en question
        elif prev_order != None: # Et si jamais il n'y avais pas d'ordre qui était avant celui qu'on enlève
            prev_order.next_order = None
            self.tail_order = prev_order # Le prev_order deviens le dernier de l'OrderList après que l'ordre soit enlever

    def move_to_tail(self, order):
        '''
        Après avoir actualisé la quantité de l'ordre, il nous faut le mettre en fin de queue de l'OrderList
        '''
        if order.prev_order != None:  # Si cette ordre n'est pas le prmier dans l'OrderList
            order.prev_order.next_order = order.next_order # faire le lien entre le prev_order et le next_order, Puis bouger l'ordre en fin de queue
        else: # Si l'odre est le premier dans l'OrderList
            self.head_order = order.next_order # Il nous faut faire en sorte que next_order soit le premier

        order.next_order.prev_order = order.prev_order
        order.prev_order = self.tail_order
        order.next_order = None
        # Faire bouger l'Ordre en derniere position.
        self.tail_order.next_order = order
        self.tail_order = order

    def __str__(self):
        from six.moves import cStringIO as StringIO
        temp_file = StringIO()
        for order in self:
            temp_file.write("%s\n" % str(order))
        #temp_file.write("%s\n" % str(self.head_order))
        return temp_file.getvalue()


class OrderTree(object):
    '''Nous allons utilisé un arbre bi-colore cf : https://fr.wikipedia.org/wiki/Arbre_bicolore pour garder nos OrderLists selon l'ordre des prix
    L'exchange utilisera l'OrderTree pour collecter les datas des bid/ask (avec un OrderTree pour chaque coté, i.e coté Bid et coté Ask).
    Le choix de la structure de donnée d'un arbre bicolore nous simplifie et rend plus rapide la détection d'un match entre ordre.
    '''

    def __init__(self):
        self.price_map = SortedDict() # Un dictionnaire contenant {price : et un objet OrderedList}
        self.prices = self.price_map.keys()# Les clés de ce dico seront bien évidemment les prix
        self.order_map = {} # Dictionnaire contenant {order_id : et un objet Order}
        self.volume = 0 # La quantité total de tous les ordres dans un arbre
        self.num_orders = 0 # Contiens le nombre d'ordres dans un arbre
        self.depth = 0 # Nombre des différents prix dans un arbre ce qui nous donne la profondeur d'un marché

    def __len__(self):
        #Renvoie la taille des ordres
        return len(self.order_map)

    def get_price_list(self, price):
        return self.price_map[price]

    def get_order(self, order_id):
        return self.order_map[order_id]

    def create_price(self, price):
        self.depth += 1 # Ajoute un prix à l'arbre soit un nouveau niveau de profondeur au marché
        new_list = OrderList()
        self.price_map[price] = new_list

    def remove_price(self, price):
        self.depth -= 1 # On enlève un prix à l'arbre soit un niveau de profondeur en moins au marché
        del self.price_map[price]

    def price_exists(self, price):
        #Nous servira à vérifier l'existance d'un prix à notre arbre en nous envoyant un booléen
        return price in self.price_map

    def order_exists(self, order):
        #Nous servira à vérifier l'existance d'un ordre à notre arbre en nous envoyant un booléen
        return order in self.order_map

    def insert_order(self, quote):
        if self.order_exists(quote['order_id']):
            self.remove_order_by_id(quote['order_id'])
        self.num_orders += 1
        if quote['price'] not in self.price_map:
            self.create_price(quote['price']) # si le prix de l'ordre n'est pas dans notre arbre, alors on crée un noeud dans notre arbre bicolor
        order = Order(quote, self.price_map[quote['price']]) # On crée un nouvelle Ordre
        self.price_map[order.price].append_order(order) # Ajoute l'ordre dans l'OrderList dans Price Map
        self.order_map[order.order_id] = order
        self.volume += order.quantity

    def update_order(self, order_update):
        order = self.order_map[order_update['order_id']]
        original_quantity = order.quantity
        if order_update['price'] != order.price:
            # Si le prix à changé alors on enlève l'ordre et on actualise l'arbre.
            order_list = self.price_map[order.price]
            order_list.remove_order(order)
            if len(order_list) == 0: # Si OrderList est vide, alors on enlève le prix de l'arbre
                self.remove_price(order.price)
            self.insert_order(order_update)
        else:
            # Si la quantité à changé mais le prix est rester le même
            order.update_quantity(order_update['quantity'], order_update['timestamp'])
        self.volume += order.quantity - original_quantity

    def remove_order_by_id(self, order_id):
        self.num_orders -= 1
        order = self.order_map[order_id]
        self.volume -= order.quantity
        order.order_list.remove_order(order)
        if len(order.order_list) == 0:
            self.remove_price(order.price)
        del self.order_map[order_id]

    def max_price(self):
        if self.depth > 0:
            return self.prices[-1]
        else:
            return None

    def min_price(self):
        if self.depth > 0:
            return self.prices[0]
        else:
            return None

    def max_price_list(self):
        if self.depth > 0:
            return self.get_price_list(self.max_price())
        else:
            return None

    def min_price_list(self):
        if self.depth > 0:
            return self.get_price_list(self.min_price())
        else:
            return None

class OrderBook(object):
    def __init__(self, tick_size = 0.0001):
        self.tape = deque(maxlen=None) # Le premier indice est le plus récent Trade qui a été effectuer
        self.bids = OrderTree()
        self.asks = OrderTree()
        self.last_tick = None
        self.last_timestamp = 0
        self.tick_size = tick_size
        self.time = 0
        self.next_order_id = 0

    def update_time(self):
        self.time += 1

    def process_order(self, quote, from_data, verbose):
        order_type = quote['type']
        order_in_book = None
        if from_data:
            self.time = quote['timestamp']
        else:
            self.update_time()
            quote['timestamp'] = self.time
        if quote['quantity'] <= 0:
            sys.exit('process_order() a été fournit une quantité <= 0')
        if not from_data:
            self.next_order_id += 1
        if order_type == 'market':
            trades = self.process_market_order(quote, verbose)
        elif order_type == 'limit':
            quote['price'] = Decimal(quote['price'])
            trades, order_in_book = self.process_limit_order(quote, from_data, verbose)
        else:
            sys.exit("Erreur order_type fournit a process_order() n'est ni 'market' or 'limit'")
        return trades, order_in_book

    def process_order_list(self, side, order_list, quantity_still_to_trade, quote, verbose):
        '''
        Prend en argument OrderList (collections d'ordres à un prix donné) et l'ordre arrvant et match
        Les bons trades étant donnée la quantité précisé dans l'ordre.
        '''
        trades = []
        quantity_to_trade = quantity_still_to_trade
        while len(order_list) > 0 and quantity_to_trade > 0:
            head_order = order_list.get_head_order()
            traded_price = head_order.price
            counter_party = head_order.trade_id
            new_book_quantity = None
            if quantity_to_trade < head_order.quantity:
                traded_quantity = quantity_to_trade
                # Réalisé la transaction
                new_book_quantity = head_order.quantity - quantity_to_trade
                head_order.update_quantity(new_book_quantity, head_order.timestamp)
                quantity_to_trade = 0
            elif quantity_to_trade == head_order.quantity:
                traded_quantity = quantity_to_trade
                if side == 'bid':
                    self.bids.remove_order_by_id(head_order.order_id)
                else:
                    self.asks.remove_order_by_id(head_order.order_id)
                quantity_to_trade = 0
            else: # Si la quantité à traiter est plus large que l'ordre en tête de queue
                traded_quantity = head_order.quantity
                if side == 'bid':
                    self.bids.remove_order_by_id(head_order.order_id)
                else:
                    self.asks.remove_order_by_id(head_order.order_id)
                quantity_to_trade -= traded_quantity
            if verbose:
                print(("TRADE: Temps - {} secondes, Prix - {}, Quantité - {}, TradeID - {}, Matching TradeID - {}".format(self.time, traded_price, traded_quantity, counter_party, quote['trade_id'])))

            transaction_record = {
                    'timestamp': self.time,
                    'price': traded_price,
                    'quantity': traded_quantity,
                    'time': self.time
                    }

            if side == 'bid':
                transaction_record['party1'] = [counter_party, 'bid', head_order.order_id, new_book_quantity]
                transaction_record['party2'] = [quote['trade_id'], 'ask', None, None]
            else:
                transaction_record['party1'] = [counter_party, 'ask', head_order.order_id, new_book_quantity]
                transaction_record['party2'] = [quote['trade_id'], 'bid', None, None]

            self.tape.append(transaction_record)
            trades.append(transaction_record)
        return quantity_to_trade, trades
                    
    def process_market_order(self, quote, verbose):
        trades = []
        quantity_to_trade = quote['quantity']
        side = quote['side']
        if side == 'bid':
            while quantity_to_trade > 0 and self.asks:
                best_price_asks = self.asks.min_price_list()
                quantity_to_trade, new_trades = self.process_order_list('ask', best_price_asks, quantity_to_trade, quote, verbose)
                trades += new_trades
        elif side == 'ask':
            while quantity_to_trade > 0 and self.bids:
                best_price_bids = self.bids.max_price_list()
                quantity_to_trade, new_trades = self.process_order_list('bid', best_price_bids, quantity_to_trade, quote, verbose)
                trades += new_trades
        else:
            sys.exit('process_market_order() a recu aucun "bid" ou "ask"')
        return trades

    def process_limit_order(self, quote, from_data, verbose):
        order_in_book = None
        trades = []
        quantity_to_trade = quote['quantity']
        side = quote['side']
        price = quote['price']
        if side == 'bid':
            while (self.asks and price >= self.asks.min_price() and quantity_to_trade > 0):
                best_price_asks = self.asks.min_price_list()
                quantity_to_trade, new_trades = self.process_order_list('ask', best_price_asks, quantity_to_trade, quote, verbose)
                trades += new_trades
            if quantity_to_trade > 0:
                if not from_data:
                    quote['order_id'] = self.next_order_id
                quote['quantity'] = quantity_to_trade
                self.bids.insert_order(quote)
                order_in_book = quote
        elif side == 'ask':
            while (self.bids and price <= self.bids.max_price() and quantity_to_trade > 0):
                best_price_bids = self.bids.max_price_list()
                quantity_to_trade, new_trades = self.process_order_list('bid', best_price_bids, quantity_to_trade, quote, verbose)
                trades += new_trades
            if quantity_to_trade > 0:
                if not from_data:
                    quote['order_id'] = self.next_order_id
                quote['quantity'] = quantity_to_trade
                self.asks.insert_order(quote)
                order_in_book = quote
        else:
            sys.exit('process_limit_order() a recu aucun "bid" ou "ask"')
        return trades, order_in_book

    def cancel_order(self, side, order_id, time=None):
        if time:
            self.time = time
        else:
            self.update_time()
        if side == 'bid':
            if self.bids.order_exists(order_id):
                self.bids.remove_order_by_id(order_id)
        elif side == 'ask':
            if self.asks.order_exists(order_id):
                self.asks.remove_order_by_id(order_id)
        else:
            sys.exit('cancel_order() a recu aucun "bid" ou "ask"')

    def modify_order(self, order_id, order_update, time=None):
        if time:
            self.time = time
        else:
            self.update_time()
        side = order_update['side']
        order_update['order_id'] = order_id
        order_update['timestamp'] = self.time
        if side == 'bid':
            if self.bids.order_exists(order_update['order_id']):
                self.bids.update_order(order_update)
        elif side == 'ask':
            if self.asks.order_exists(order_update['order_id']):
                self.asks.update_order(order_update)
        else:
            sys.exit('modify_order() a recu aucun "bid" ou "ask"')

    def get_volume_at_price(self, side, price):
        price = Decimal(price)
        if side == 'bid':
            volume = 0
            if self.bids.price_exists(price):
                volume = self.bids.get_price_list(price).volume
            return volume
        elif side == 'ask':
            volume = 0
            if self.asks.price_exists(price):
                volume = self.asks.get_price_list(price).volume
            return volume
        else:
            sys.exit('get_volume_at_price() a recu aucun "bid" ou "ask"')

    def get_best_bid(self):
        return self.bids.max_price()

    def get_worst_bid(self):
        return self.bids.min_price()

    def get_best_ask(self):
        return self.asks.min_price()

    def get_worst_ask(self):
        return self.asks.max_price()

    def tape_dump(self, filename, filemode, tapemode):
        dumpfile = open(filename, filemode)
        for tapeitem in self.tape:
            dumpfile.write('Temps: %s secondes, Prix: %s, Quantité: %s\n' % (tapeitem['time'],
                                                                    tapeitem['price'],
                                                                    tapeitem['quantity']))
        dumpfile.close()
        if tapemode == 'wipe':
            self.tape = []
    def get_all(self):
        tempfile = StringIO()
        if self.bids != None and len(self.bids) > 0:
          bid_orders = []
          for key, value in reversed(self.bids.price_map.items()):
                #x = tempfile.write(value)
                bid_orders.append(value)
        if self.asks != None and len(self.asks) > 0:
          ask_orders = []
          for key, value in self.asks.price_map.items():
                ask_orders.append(value)
        trades_done = []
        if self.tape != None and len(self.tape) > 0:
          for entry in self.tape:
                dico = {
                        'quantité' : entry['quantity'],
                        'prix' : entry['price'],
                        'timestamp' : entry['timestamp'],
                        'id_contrepartie1' : entry['party1'],
                        'id_contrepartie2' : entry['party2']
                    }
                trades_done.append(dico)
        return bid_orders, ask_orders, trades_done

    def __str__(self):
        tempfile = StringIO()
        tempfile.write("***Bids***\n")
        if self.bids != None and len(self.bids) > 0:
            for key, value in reversed(self.bids.price_map.items()):
                tempfile.write('%s' % value)
        tempfile.write("\n***Asks***\n")
        if self.asks != None and len(self.asks) > 0:
            for key, value in self.asks.price_map.items():
                tempfile.write('%s' % value)
        tempfile.write("\n***Trades***\n")
        if self.tape != None and len(self.tape) > 0:
            num = 0
            for entry in self.tape:
                if num < 10: 
                    tempfile.write('quantité : ' + str(entry['quantity']) + " , Prix : " + str(entry['price']) + " (Temps de réalisation du Trade : " + str(entry['timestamp']) + " secondes), Id_party1 : " + str(entry['party1'][0]) + "/ Id_party2 : " + str(entry['party2'][0]) + "\n")
                    num += 1
                else:
                    break
        tempfile.write("\n")
        return tempfile.getvalue()

